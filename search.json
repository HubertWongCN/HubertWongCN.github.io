[{"title":"13.JUC锁: ReentrantReadWriteLock详解","path":"/2023/12/25/13-JUC锁-ReentrantReadWriteLock详解/","content":"ReentrantReadWriteLock表示可重入读写锁，ReentrantReadWriteLock中包含了两种锁，读锁ReadLock和写锁WriteLock，可以通过这两种锁实现线程间的同步。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 为了有了ReentrantLock还需要ReentrantReadWriteLock? ReentrantReadWriteLock底层实现原理? ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁 读锁和写锁的最大数量是多少? 本地线程计数器ThreadLocalHoldCounter是用来做什么的? 缓存计数器HoldCounter是用来做什么的? 写锁的获取与释放是怎么实现的? 读锁的获取与释放是怎么实现的? RentrantReadWriteLock为什么不支持锁升级? 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级? ReentrantReadWriteLock数据结构ReentrantReadWriteLock底层是基于ReentrantLock和AbstractQueuedSynchronizer来实现的，所以，ReentrantReadWriteLock的数据结构也依托于AQS的数据结构。 ReentrantReadWriteLock源码分析类的继承关系1public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123;&#125; 说明: 可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看到ReentrantReadWriteLock实现了自己的序列化逻辑。 类的内部类ReentrantReadWriteLock有五个内部类，五个内部类之间也是相互关联的。内部类的关系如下图所示。 说明: 如上图所示，Sync继承自AQS、NonfairSync继承自Sync类、FairSync继承自Sync类；ReadLock实现了Lock接口、WriteLock也实现了Lock接口。 内部类 - Sync类 类的继承关系 1abstract static class Sync extends AbstractQueuedSynchronizer &#123;&#125; 说明: Sync抽象类继承自AQS抽象类，Sync类提供了对ReentrantReadWriteLock的支持。 类的内部类 Sync类内部存在两个内部类，分别为HoldCounter和ThreadLocalHoldCounter，其中HoldCounter主要与读锁配套使用，其中，HoldCounter源码如下。 12345678// 计数器static final class HoldCounter &#123; // 计数 int count = 0; // Use id, not reference, to avoid garbage retention // 获取当前线程的TID属性的值 final long tid = getThreadId(Thread.currentThread());&#125; 说明: HoldCounter主要有两个属性，count和tid，其中count表示某个读线程重入的次数，tid表示该线程的tid字段的值，该字段可以用来唯一标识一个线程。ThreadLocalHoldCounter的源码如下 12345678// 本地线程计数器static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123; // 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值 public HoldCounter initialValue() &#123; return new HoldCounter(); &#125;&#125; 说明: ThreadLocalHoldCounter重写了ThreadLocal的initialValue方法，ThreadLocal类可以将线程与对象相关联。在没有进行set的情况下，get到的均是initialValue方法里面生成的那个HolderCounter对象。 类的属性 1234567891011121314151617181920abstract static class Sync extends AbstractQueuedSynchronizer &#123; // 版本序列号 private static final long serialVersionUID = 6317671515068378041L; // 高16位为读锁，低16位为写锁 static final int SHARED_SHIFT = 16; // 读锁单位 static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); // 读锁最大数量 static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; // 写锁最大数量 static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; // 本地线程计数器 private transient ThreadLocalHoldCounter readHolds; // 缓存的计数器 private transient HoldCounter cachedHoldCounter; // 第一个读线程 private transient Thread firstReader = null; // 第一个读线程的计数 private transient int firstReaderHoldCount;&#125; 说明: 该属性中包括了读锁、写锁线程的最大量。本地线程计数器等。 类的构造函数 1234567// 构造函数Sync() &#123; // 本地线程计数器 readHolds = new ThreadLocalHoldCounter(); // 设置AQS的状态 setState(getState()); // ensures visibility of readHolds&#125; 说明: 在Sync的构造函数中设置了本地线程计数器和AQS的状态state。 内部类 - Sync核心函数分析对ReentrantReadWriteLock对象的操作绝大多数都转发至Sync对象进行处理。下面对Sync类中的重点函数进行分析 sharedCount函数 表示占有读锁的线程数量，源码如下 1static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; 说明: 直接将state右移16位，就可以得到读锁的线程数量，因为state的高16位表示读锁，对应的低十六位表示写锁数量。 exclusiveCount函数 表示占有写锁的线程数量，源码如下 1static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 说明: 直接将状态state和(2^16 - 1)做与运算，其等效于将state模上2^16。写锁数量由state的低十六位表示。 tryRelease函数 12345678910111213141516171819/** Note that tryRelease and tryAcquire can be called by* Conditions. So it is possible that their arguments contain* both read and write holds that are all released during a* condition wait and re-established in tryAcquire.*/protected final boolean tryRelease(int releases) &#123; // 判断是否伪独占线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 计算释放资源后的写锁的数量 int nextc = getState() - releases; boolean free = exclusiveCount(nextc) == 0; // 是否释放成功 if (free) setExclusiveOwnerThread(null); // 设置独占线程为空 setState(nextc); // 设置状态 return free;&#125; 说明: 此函数用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为0，表示成功释放，资源不将被占用，否则，表示资源还被占用。其函数流程图如下。 tryAcquire函数 123456789101112131415161718192021222324252627282930313233343536protected final boolean tryAcquire(int acquires) &#123; /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ // 获取当前线程 Thread current = Thread.currentThread(); // 获取状态 int c = getState(); // 写线程数量 int w = exclusiveCount(c); if (c != 0) &#123; // 状态不为0 // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) // 写线程数量为0或者当前线程没有占有独占资源 return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) // 判断是否超过最高写线程数量 throw new Error(&quot;Maximum lock count exceeded&quot;); // Reentrant acquire // 设置AQS状态 setState(c + acquires); return true; &#125; if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 写线程是否应该被阻塞 return false; // 设置独占线程 setExclusiveOwnerThread(current); return true;&#125; 说明: 此函数用于获取写锁，首先会获取state，判断是否为0，若为0，表示此时没有读锁线程，再判断写线程是否应该被阻塞，而在非公平策略下总是不会被阻塞，在公平策略下会进行判断(判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞)，之后在设置状态state，然后返回true。若state不为0，则表示此时存在读锁或写锁线程，若写锁线程数量为0或者当前线程为独占锁线程，则返回false，表示不成功，否则，判断写锁线程的重入次数是否大于了最大值，若是，则抛出异常，否则，设置状态state，返回true，表示成功。其函数流程图如下 tryReleaseShared函数 1234567891011121314151617181920212223242526272829303132333435363738protected final boolean tryReleaseShared(int unused) &#123; // 获取当前线程 Thread current = Thread.currentThread(); if (firstReader == current) &#123; // 当前线程为第一个读线程 // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) // 读线程占用的资源数为1 firstReader = null; else // 减少占用的资源 firstReaderHoldCount--; &#125; else &#123; // 当前线程不为第一个读线程 // 获取缓存的计数器 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid // 获取当前线程对应的计数器 rh = readHolds.get(); // 获取计数 int count = rh.count; if (count &lt;= 1) &#123; // 计数小于等于1 // 移除 readHolds.remove(); if (count &lt;= 0) // 计数小于等于0，抛出异常 throw unmatchedUnlockException(); &#125; // 减少计数 --rh.count; &#125; for (;;) &#123; // 无限循环 // 获取状态 int c = getState(); // 获取状态 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) // 比较并进行设置 // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. return nextc == 0; &#125;&#125; 说明: 此函数表示读锁线程释放锁。首先判断当前线程是否为第一个读线程firstReader，若是，则判断第一个读线程占有的资源数firstReaderHoldCount是否为1，若是，则设置第一个读线程firstReader为空，否则，将第一个读线程占有的资源数firstReaderHoldCount减1；若当前线程不是第一个读线程，那么首先会获取缓存计数器(上一个读锁线程对应的计数器 )，若计数器为空或者tid不等于当前线程的tid值，则获取当前线程的计数器，如果计数器的计数count小于等于1，则移除当前线程对应的计数器，如果计数器的计数count小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态state。其流程图如下 tryAcquireShared函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private IllegalMonitorStateException unmatchedUnlockException() &#123; return new IllegalMonitorStateException( &quot;attempt to unlock read lock, not locked by current thread&quot;);&#125;// 共享模式下获取资源protected final int tryAcquireShared(int unused) &#123; /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ // 获取当前线程 Thread current = Thread.currentThread(); // 获取状态 int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) // 写线程数不为0并且占有资源的不是当前线程 return -1; // 读锁数量 int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; // 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功 if (r == 0) &#123; // 读锁数量为0 // 设置第一个读线程 firstReader = current; // 读线程占用的资源数为1 firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; // 当前线程为第一个读线程 // 占用资源数加1 firstReaderHoldCount++; &#125; else &#123; // 读锁数量不为0并且不为当前线程 // 获取计数器 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) // 计数器为空或者计数器的tid不为当前正在运行的线程的tid // 获取当前线程对应的计数器 cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) // 计数为0 // 设置 readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; 说明: 此函数表示读锁线程获取读锁。首先判断写锁是否为0并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前没有读锁，则设置第一个读线程firstReader和firstReaderHoldCount；若当前线程线程为第一个读线程，则增加firstReaderHoldCount；否则，将设置当前线程对应的HoldCounter对象的值。流程图如下。 fullTryAcquireShared函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final int fullTryAcquireShared(Thread current) &#123; /* * This code is in part redundant with that in * tryAcquireShared but is simpler overall by not * complicating tryAcquireShared with interactions between * retries and lazily reading hold counts. */ HoldCounter rh = null; for (;;) &#123; // 无限循环 // 获取状态 int c = getState(); if (exclusiveCount(c) != 0) &#123; // 写线程数量不为0 if (getExclusiveOwnerThread() != current) // 不为当前线程 return -1; // else we hold the exclusive lock; blocking here // would cause deadlock. &#125; else if (readerShouldBlock()) &#123; // 写线程数量为0并且读线程被阻塞 // Make sure we&#x27;re not acquiring read lock reentrantly if (firstReader == current) &#123; // 当前线程为第一个读线程 // assert firstReaderHoldCount &gt; 0; &#125; else &#123; // 当前线程不为第一个读线程 if (rh == null) &#123; // 计数器不为空 // rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) &#123; // 计数器为空或者计数器的tid不为当前正在运行的线程的tid rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; if (rh.count == 0) return -1; &#125; &#125; if (sharedCount(c) == MAX_COUNT) // 读锁数量为最大值，抛出异常 throw new Error(&quot;Maximum lock count exceeded&quot;); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 比较并且设置成功 if (sharedCount(c) == 0) &#123; // 读线程数量为0 // 设置第一个读线程 firstReader = current; // firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125;&#125; 说明: 在tryAcquireShared函数中，如果下列三个条件不满足(读线程是否应该被阻塞、小于最大值、比较设置成功)则会进行fullTryAcquireShared函数中，它用来保证相关操作可以成功。其逻辑与tryAcquireShared逻辑类似，不再累赘。 而其他内部类的操作基本上都是转化到了对Sync对象的操作，在此不再累赘。 类的属性1234567891011121314151617181920212223242526public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123; // 版本序列号 private static final long serialVersionUID = -6992448646407690164L; // 读锁 private final ReentrantReadWriteLock.ReadLock readerLock; // 写锁 private final ReentrantReadWriteLock.WriteLock writerLock; // 同步队列 final Sync sync; private static final sun.misc.Unsafe UNSAFE; // 线程ID的偏移地址 private static final long TID_OFFSET; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; tk = Thread.class; // 获取线程的tid字段的内存地址 TID_OFFSET = UNSAFE.objectFieldOffset (tk.getDeclaredField(&quot;tid&quot;)); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 说明: 可以看到ReentrantReadWriteLock属性包括了一个ReentrantReadWriteLock.ReadLock对象，表示读锁；一个ReentrantReadWriteLock.WriteLock对象，表示写锁；一个Sync对象，表示同步队列。 类的构造函数 ReentrantReadWriteLock()型构造函数 123public ReentrantReadWriteLock() &#123; this(false);&#125; 说明: 此构造函数会调用另外一个有参构造函数。 ReentrantReadWriteLock(boolean)型构造函数 12345678public ReentrantReadWriteLock(boolean fair) &#123; // 公平策略或者是非公平策略 sync = fair ? new FairSync() : new NonfairSync(); // 读锁 readerLock = new ReadLock(this); // 写锁 writerLock = new WriteLock(this);&#125; 说明: 可以指定设置公平策略或者非公平策略，并且该构造函数中生成了读锁与写锁两个对象。 核心函数分析对ReentrantReadWriteLock的操作基本上都转化为了对Sync对象的操作，而Sync的函数已经分析过，不再累赘。 ReentrantReadWriteLock示例下面给出了一个使用ReentrantReadWriteLock的示例，源代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.concurrent.locks.ReentrantReadWriteLock;class ReadThread extends Thread &#123; private ReentrantReadWriteLock rrwLock; public ReadThread(String name, ReentrantReadWriteLock rrwLock) &#123; super(name); this.rrwLock = rrwLock; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; trying to lock&quot;); try &#123; rrwLock.readLock().lock(); System.out.println(Thread.currentThread().getName() + &quot; lock successfully&quot;); Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; rrwLock.readLock().unlock(); System.out.println(Thread.currentThread().getName() + &quot; unlock successfully&quot;); &#125; &#125;&#125;class WriteThread extends Thread &#123; private ReentrantReadWriteLock rrwLock; public WriteThread(String name, ReentrantReadWriteLock rrwLock) &#123; super(name); this.rrwLock = rrwLock; &#125; public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; trying to lock&quot;); try &#123; rrwLock.writeLock().lock(); System.out.println(Thread.currentThread().getName() + &quot; lock successfully&quot;); &#125; finally &#123; rrwLock.writeLock().unlock(); System.out.println(Thread.currentThread().getName() + &quot; unlock successfully&quot;); &#125; &#125;&#125;public class ReentrantReadWriteLockDemo &#123; public static void main(String[] args) &#123; ReentrantReadWriteLock rrwLock = new ReentrantReadWriteLock(); ReadThread rt1 = new ReadThread(&quot;rt1&quot;, rrwLock); ReadThread rt2 = new ReadThread(&quot;rt2&quot;, rrwLock); WriteThread wt1 = new WriteThread(&quot;wt1&quot;, rrwLock); rt1.start(); rt2.start(); wt1.start(); &#125; &#125; 运行结果(某一次): 123456789rt1 trying to lockrt2 trying to lockwt1 trying to lockrt1 lock successfullyrt2 lock successfullyrt1 unlock successfullyrt2 unlock successfullywt1 lock successfullywt1 unlock successfully 说明: 程序中生成了一个ReentrantReadWriteLock对象，并且设置了两个读线程，一个写线程。根据结果，可能存在如下的时序图。 rt1线程执行rrwLock.readLock().lock操作，主要的函数调用如下。 说明: 此时，AQS的状态state为2^16 次方，即表示此时读线程数量为1。 rt2线程执行rrwLock.readLock().lock操作，主要的函数调用如下。 说明: 此时，AQS的状态state为2 * 2^16次方，即表示此时读线程数量为2。 wt1线程执行rrwLock.writeLock().lock操作，主要的函数调用如下。 说明: 此时，在同步队列Sync queue中存在两个结点，并且wt1线程会被禁止运行。 rt1线程执行rrwLock.readLock().unlock操作，主要的函数调用如下。 说明: 此时，AQS的state为2^16次方，表示还有一个读线程。 rt2线程执行rrwLock.readLock().unlock操作，主要的函数调用如下。 说明: 当rt2线程执行unlock操作后，AQS的state为0，并且wt1线程将会被unpark，其获得CPU资源就可以运行。 wt1线程获得CPU资源，继续运行，需要恢复。由于之前acquireQueued函数中的parkAndCheckInterrupt函数中被禁止的，所以，恢复到parkAndCheckInterrupt函数中，主要的函数调用如下 说明: 最后，sync queue队列中只有一个结点，并且头节点尾节点均指向它，AQS的state值为1，表示此时有一个写线程。 wt1执行rrwLock.writeLock().unlock操作，主要的函数调用如下。 说明: 此时，AQS的state为0，表示没有任何读线程或者写线程了。并且Sync queue结构与上一个状态的结构相同，没有变化。 更深入理解什么是锁升降级?锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程。 接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示： 123456789101112131415161718192021222324public void processData() &#123; readLock.lock(); if (!update) &#123; // 必须先释放读锁 readLock.unlock(); // 锁降级从写锁获取到开始 writeLock.lock(); try &#123; if (!update) &#123; // 准备数据的流程(略) update = true; &#125; readLock.lock(); &#125; finally &#123; writeLock.unlock(); &#125; // 锁降级完成，写锁降级为读锁 &#125; try &#123; // 使用数据的流程(略) &#125; finally &#123; readLock.unlock(); &#125;&#125; 上述示例中，当数据发生变更后，update变量(布尔类型且volatile修饰)被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。 锁降级中读锁的获取是否必要呢? 答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程(记作线程T)获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。 RentrantReadWriteLock不支持锁升级(把持读锁、获取写锁，最后释放读锁的过程)。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。 参考文章 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5419132.html，在此基础上做了增改。 https://blog.csdn.net/jiankunking/article/details/83954263","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"谷歌大模型-Gemini 快速开始","path":"/2023/12/25/谷歌大模型-Gemini-快速开始/","content":"引言近期相信大家都听说了谷歌大模型：Gemini Gemini官网访问官方网站： 官网地址：Google AI for Developers 官方已经提供了体验入口，大家可以很方便地体验谷歌发布的最大且能力最强的AI模型。 「使用条件：」 Google账号 科学上网 如何Gemini使用点击上图中 Get API key in Google AI Studio, 打开Google AI Studio。如果是首次打开，则需要同意相关服务条款： 第一条必须选择，第二条和第三条可以不选! 服务条款 使用Gemini的两种方式如下图，Google目前提供了两种使用Gemini的方式：Google AI Studio 和 Develop in your own environment，即在类似于ChatGPT的页面上直接使用和方便开发者在自己的环境中使用的API方式。 选择使用Gemini方式 方式一：使用Google AI Studio，这里了不起也就探索了一下页面方式 Google AI Studio Google AI Studio提供了三种类型的Prompt方式： 「FreeForm prompt（自由式提示语）」 该提示为生成内容和对应指令的响应提供了开放式的提示体验。您可以使用图像和文本作为提示。 「Structured prompt（结构化提示语）」 这种提示技术允许您通过提供一组示例请求和应答来指导模型输出。当您需要对模型输出的结构进行更多的控制时，可以使用这种方法。 「Chat prompt（对话式提示语）」 使用对话式提示构建对话体验。该提示技术允许多次输入和响应轮流生成输出。 自由格式提示示例：详细了解建筑物Gemini 的多模态功能可让您结合使用图像和文本来提示模型。例如，您可以使用此功能详细了解图片中显示的建筑物。 第 1 步 - 使用文本和图片创建提示如需创建多模态提示，请执行以下操作： 进入 Google AI Studio。 在左侧面板中，依次选择 新建 &gt; 自由格式提示 。 在右侧列的模型字段中，选择支持图像的模型，例如 Gemini Pro Vision 模型。 在提示文本区域中，输入以下文本： 1look at the following picture and tell me who is the architect 从提示区域上方的插入栏中，选择 图片 ，然后选择某个建筑物的示例图片。 在应用窗口的底部，选择 Run 以生成此请求的回复。 第 2 步 - 在提示符中添加可替换的变量在第 1 步中，您使用固定的文本字符串和图像提示模型。但有时，您希望能够动态更改提示的某些部分。例如，如果您要构建交互式应用，可能需要使用不同的用户输入来修改提示。为此，您可以使用变量将提示参数化。 如需向提示添加变量，请执行以下操作： 选择要在问题中替换的字词或短语。在本例中，请选择文本：who is the architect。 从提示上方的 Insert: 标头中，选择 &#123;&#123; &#125;&#125; Test input 。 在提示下方的 Test yourPrompt 表格中，为您的提示添加一个额外的值，方法是选择Add test example并输入额外的提示值。您可以随意添加几个新的输入值。 在应用窗口的底部，选择 Run 以为每个不同的请求生成回复。 第 3 步 - 用模型参数进行实验在对提示进行原型设计时，您还可以在应用右侧的试用模型运行设置。以下是需要了解的关键设置： 模型 - 选择您要回答问题的模型。如需详细了解可用的模型和功能，请参阅模型。 温度 - 控制模型响应可以允许多大程度的随机性。提高此值可让模型生成更意外且更具创造性的响应。 最大输出 - 增加模型为每个请求返回的响应数。此选项能够针对单个提示生成多个响应，有助于快速测试提示。 Safety settings - 调整用于管理模型响应的安全设置。如需详细了解这些控制措施，请参阅安全设置。 第 4 步 - 后续步骤现在，您已经为生成式 AI 应用设计了原型，接下来可以保存您的工作或生成代码，以便在您自己的开发环境中使用此提示。 如需保存您创建的提示，请执行以下操作： 在 Google AI Studio 应用的右上角，选择 保存 。 如果您尚未将应用关联到您的 Google 云端硬盘帐号，请执行此操作。 在保存提示对话框中，输入提示名称和可选的 说明 ，然后选择 保存 。 如需将您创建的提示以代码的形式导出，请执行以下操作： 在 Google AI Studio 应用的右上角，选择 获取代码 。 选择一个编程语言标签页。 选择复制以将此代码复制到剪贴板。 注意 ：您需要使用 API 密钥才能在 Google AI Studio 之外运行提示代码，因此请务必创建一个密钥，并将其包含在提示代码中。注意 ：请将 API 密钥视为密码并妥善保护。请勿将您的密钥嵌入到公开发布的代码中。 结构化提示示例：构建商品文案生成器到目前为止，您已经了解了如何使用指令（“看图片，告诉我架构师是谁”）来提示模型。但是，有时，您可以通过结合说明和示例来向模型发出提示，从而获得更好的结果。Google AI Studio 中的结构化提示可帮助您做到这一点 - 将指令与示例相结合，向模型显示您想要的输出类型，而不是仅仅指示模型要执行什么操作。如果您希望模型保持一致的输出格式（即结构化 json）或难以描述模型的具体风格，这种提示非常有用。在本部分中，您将了解如何在 Google AI Studio 中创建结构化提示。 注意 ：您可以直接在 Google AI Studio 中从示例库中尝试此示例。 第 1 步 - 创建结构化提示在此示例中，您将创建一个结构化提示，用于为产品生成广告文案。首先，您需要创建两列（Product 输入列和 Product copy 输出列）来定义提示的结构。 如需创建结构化提示，请执行以下操作： 在 Google AI Studio Web 应用的左上角，依次选择 新建 &gt; 结构化提示 。 在 Insert: 标头下方，添加结构化提示的说明： 123You are a product marketer targeting a Gen Z audience. Create exciting andfresh advertising copy for products and their simple description. Keep copyunder a few sentences long. 通过将默认的 input: 文本说明替换为 Product:，为 INPUT 添加描述性标题。 通过将默认的 output: 文本说明替换为 Product copy:，为 OUTPUT 添加描述性标题。 提示 ：在列名称末尾添加英文冒号，以便模型更轻松地解析结构。 第 2 步 - 添加示例现在您已为列命名，请提供一些示例行。这些行应包含示例输入（本例中的产品名称）和示例输出（对应的产品说明）。通过为模型提供几个示例产品说明，您可以指导模型在生成自己的输出时复制类似的风格。您可以手动输入示例，也可以使用“导入数据”菜单从文件导入。 要手动输入示例，请执行以下操作： 在顶部的示例数据表中，选择 Product: 标题下方的字段，然后输入产品说明。 选择 Product copy: 标题下的字段，然后为此商品输入 marketing copy。 以下示例展示了此提示的输入和输出值： 产品： 产品文案： 老式运动鞋 让我们系上安全带！这些鞋子的外观和颜色也别具一格，拥有别具一格的风格和功能。 超柔软连帽衫 穿上我们全新的男女通用连帽衫，舒适又时尚！这款连帽衫由 100% 棉制成，柔软舒适，全天佩戴。即使是在最冷的日子，里面的半刷墙也能让你保持温暖。 提示 ：如果您让作者屏蔽或者没有示例产品文案示例，则可以使用自由格式提示让文本模型为您生成一些示例。如需从文件导入示例，请执行以下操作： 在示例表的右上角，依次选择 操作 &gt; 导入示例 。 在对话框中，选择 Google 云端硬盘中的 CSV 或 Google 表格文件，或者从计算机上传。 在“导入示例”对话框中，选择要导入的列，要排除哪些列。通过该对话框，您还可以在结构化提示中指定将哪个数据列导入哪个表列。 第 3 步 - 测试您的提示准备好向模型显示所需内容的示例后，在底部的测试您的提示表中使用新输入来测试提示。与文本提示类型一样，您可以调整模型参数，以测试这些参数是否有助于为您的使用场景生成更好的结果。 查看如何将样本发送到模型从本质上讲，Google AI Studio 会将指令与您提供的示例相结合来构建提示。随着您添加更多样本，这些样本会添加到发送给模型的文本中。根据样本的长度，您可能会开始达到模型的词元限制。所有生成式 AI 模型都有令牌限制，即它们可以接受作为输入的文本的最大长度。 如需查看提示的完整内容，请执行以下操作： 选择 Google AI Studio Web 应用底部的 文本预览 。 注意 ：模型令牌限制显示在预览窗格底部。 第 4 步 - 后续步骤如果您对提示感到满意，可以点击获取代码按钮将其保存或导出到代码中。 您还可以将各个少样本样本导出到 CSV 文件或 Google 表格中。选择操作菜单下的导出示例选项以导出您的示例。 聊天提示示例：构建自定义聊天应用如果您使用过 Bard 等通用聊天机器人，就能亲身体验生成式 AI 模型在开放式对话方面的强大之处。虽然这些通用聊天机器人非常有用，但它们通常需要针对特定使用场景进行定制。例如，您可能希望构建一个客户服务聊天机器人，它仅支持有关公司产品的对话的对话。您可能需要构建一个使用特定语气或风格的聊天机器人：一个可以讲大量笑话、像诗人押韵的机器人，或在回答中使用大量表情符号。 此示例展示了如何使用 Google AI Studio 构建一个友好的聊天机器人，它就像是居住在木星的一颗卫星“欧罗巴”上的外星人一样进行沟通。 第 1 步 - 创建聊天提示在上一部分中，您设计了使用输入和输出示例组合的结构化提示。同样，如需构建聊天机器人，您需要提供用户和聊天机器人之间的互动示例，以指导模型提供您需要的响应。 如需创建聊天提示，请执行以下操作： 在 Google AI Studio Web 应用的左上角，依次选择 新建 &gt; Chat 提示 。 在提示界面的编写提示示例列中，您可以开始提供互动示例。您还可以在第一个示例中提供其他上下文，例如： 123User: You are Tim, a friendly alien that lives on Europa, one ofJupiter&#x27;s moons.Model: Ok User 和 Model 字段中提供了用户和聊天机器人之间的互动示例： 123User: Hi!Model: Hi! My name is Tim and I live on Europa, one of Jupiter&#x27;s moons. Brr!It&#x27;s cold down here! 填写完示例后，通过在聊天提示界面的右侧窗格中与模型聊天来开始测试您的应用。 如需测试聊天机器人的行为，请执行以下操作： 在测试提示面板中，选择底部的输入字段。 输入用户可能提出的问题或观察结果，例如： 1What&#x27;s the weather like? 选择输入字段右侧的菱形按钮，以获取聊天机器人的响应，响应可能如下所示： 1Model:The weather on Europais very cold and icy.... 第 2 步 - 训练聊天机器人更好地聊天通过提供一个语句和响应示例，您可以构建一个基本的欧罗巴外星聊天机器人。但是，单个样本通常不足以确保模型响应的一致性和质量。如果没有进一步输入，模型对天气相关问题的回答往往会很长，听起来像是教科书里的回答，而不是友好的外星人给出的回答。 使用模型响应并对其进行修改，以匹配外星聊天机器人所需的语气和风格，从而自定义聊天机器人的语气。 如需添加和修改聊天机器人定义的示例，请执行以下操作： 在 Test yourPrompt 面板中，将光标悬停在 User 标题的左侧，然后选择 Add to examples 按钮。 在编写提示示例列中，修改复制的输入和响应，以匹配聊天机器人的预期风格和语气。 您可以使用此方法添加更多示例。提出更多问题、修改答案，并提高聊天机器人的质量。继续添加示例，并测试这些示例会如何修改聊天机器人的行为。通常，示例越多，聊天机器人响应的质量越高。 在后台，Google AI Studio 会通过组合以下各项来构建提示： 对话框示例 对话记录 文本块传递给模型。如需查看完整的提示是什么样子，请点击屏幕底部的 Preview ，以调出预览窗格。 请注意，由于模型与用户之间的每条消息都包含在提示中（这就是“对话记录”），因此对话提示可能会随着对话的进行而增长。最终，您可能会达到模型的词元限制，即模型可以接受的文本长度上限。您可以在预览标签页中查看完整的对话和令牌数量。 第 3 步 - 用模型参数进行实验您还可以尝试调整模型参数，以查看它们是否为您的使用场景生成了更合适的结果。 第 4 步 - 后续步骤与其他提示类型类似，一旦对提示的原型设计符合您的要求，您就可以使用获取代码按钮开始编写代码，或保存提示，以便稍后处理并与他人分享。 参考：https://ai.google.dev/tutorials/ai-studio_quickstart","tags":["Google","人工智能","Gemini"],"categories":["人工智能"]},{"title":"12.JUC锁: ReentrantLock详解","path":"/2023/12/25/12-JUC锁-ReentrantLock详解/","content":"可重入锁ReentrantLock的底层是通过AbstractQueuedSynchronizer实现，所以先要学习上一章节AbstractQueuedSynchronizer详解。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 什么是可重入，什么是可重入锁? 它用来解决什么问题? ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。 ReentrantLock是如何实现公平锁的? ReentrantLock是如何实现非公平锁的? ReentrantLock默认实现的是公平还是非公平锁? 使用ReentrantLock实现公平和非公平锁的示例? ReentrantLock和Synchronized的对比? ReentrantLock源码分析类的继承关系ReentrantLock实现了Lock接口，Lock接口中定义了lock与unlock相关操作，并且还存在newCondition方法，表示生成一个条件。 1public class ReentrantLock implements Lock, java.io.Serializable 类的内部类ReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。 说明: ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类，NonfairSync与FairSync类继承自Sync类，Sync类继承自AbstractQueuedSynchronizer抽象类。下面逐个进行分析。 Sync类 Sync类的源码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687abstract static class Sync extends AbstractQueuedSynchronizer &#123; // 序列号 private static final long serialVersionUID = -5179523762034025860L; // 获取锁 abstract void lock(); // 非公平方式获取 final boolean nonfairTryAcquire(int acquires) &#123; // 当前线程 final Thread current = Thread.currentThread(); // 获取状态 int c = getState(); if (c == 0) &#123; // 表示没有线程正在竞争该锁 if (compareAndSetState(0, acquires)) &#123; // 比较并设置状态成功，状态0表示锁没有被占用 // 设置当前线程独占 setExclusiveOwnerThread(current); return true; // 成功 &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 当前线程拥有该锁 int nextc = c + acquires; // 增加重入次数 if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); // 设置状态 setState(nextc); // 成功 return true; &#125; // 失败 return false; &#125; // 试图在共享模式下获取对象状态，此方法应该查询是否允许它在共享模式下获取对象状态，如果允许，则获取它 protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) // 当前线程不为独占线程 throw new IllegalMonitorStateException(); // 抛出异常 // 释放标识 boolean free = false; if (c == 0) &#123; free = true; // 已经释放，清空独占 setExclusiveOwnerThread(null); &#125; // 设置标识 setState(c); return free; &#125; // 判断资源是否被当前线程占有 protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don&#x27;t need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // 新生一个条件 final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; // Methods relayed from outer class // 返回资源的占用线程 final Thread getOwner() &#123; return getState() == 0 ? null : getExclusiveOwnerThread(); &#125; // 返回状态 final int getHoldCount() &#123; return isHeldExclusively() ? getState() : 0; &#125; // 资源是否被占用 final boolean isLocked() &#123; return getState() != 0; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ // 自定义反序列化逻辑 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); setState(0); // reset to unlocked state &#125;&#125; Sync类存在如下方法和作用如下。 NonfairSync类 NonfairSync类继承了Sync类，表示采用非公平策略获取锁，其实现了Sync类中抽象的lock方法，源码如下: 12345678910111213141516171819// 非公平锁static final class NonfairSync extends Sync &#123; // 版本号 private static final long serialVersionUID = 7316153563782823691L; // 获得锁 final void lock() &#123; if (compareAndSetState(0, 1)) // 比较并设置状态成功，状态0表示锁没有被占用 // 把当前线程设置独占了锁 setExclusiveOwnerThread(Thread.currentThread()); else // 锁已经被占用，或者set失败 // 以独占模式获取对象，忽略中断 acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 说明: 从lock方法的源码可知，每一次都尝试获取锁，而并不会按照公平等待的原则进行等待，让等待时间最久的线程获得锁。 FairSyn类 FairSync类也继承了Sync类，表示采用公平策略获取锁，其实现了Sync类中的抽象lock方法，源码如下: 12345678910111213141516171819202122232425262728293031323334353637383940// 公平锁static final class FairSync extends Sync &#123; // 版本序列化 private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; // 以独占模式获取对象，忽略中断 acquire(1); &#125; /** * Fair version of tryAcquire. Don&#x27;t grant access unless * recursive call or no waiters or is first. */ // 尝试公平获取锁 protected final boolean tryAcquire(int acquires) &#123; // 获取当前线程 final Thread current = Thread.currentThread(); // 获取状态 int c = getState(); if (c == 0) &#123; // 状态为0 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; // 不存在已经等待更久的线程并且比较并且设置状态成功 // 设置当前线程独占 setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; // 状态不为0，即资源已经被线程占据 // 下一个状态 int nextc = c + acquires; if (nextc &lt; 0) // 超过了int的表示范围 throw new Error(&quot;Maximum lock count exceeded&quot;); // 设置状态 setState(nextc); return true; &#125; return false; &#125;&#125; 说明: 跟踪lock方法的源码可知，当资源空闲时，它总是会先判断sync队列(AbstractQueuedSynchronizer中的数据结构)是否有等待时间更长的线程，如果存在，则将该线程加入到等待队列的尾部，实现了公平获取原则。其中，FairSync类的lock的方法调用如下，只给出了主要的方法。 说明: 可以看出只要资源被其他线程占用，该线程就会添加到sync queue中的尾部，而不会先尝试获取资源。这也是和Nonfair最大的区别，Nonfair每一次都会尝试去获取资源，如果此时该资源恰好被释放，则会被当前线程获取，这就造成了不公平的现象，当获取不成功，再加入队列尾部。 类的属性ReentrantLock类的sync非常重要，对ReentrantLock类的操作大部分都直接转化为对Sync和AbstractQueuedSynchronizer类的操作。 123456public class ReentrantLock implements Lock, java.io.Serializable &#123; // 序列号 private static final long serialVersionUID = 7373984872572414699L; // 同步队列 private final Sync sync;&#125; 类的构造函数 ReentrantLock()型构造函数 默认是采用的非公平策略获取锁 1234public ReentrantLock() &#123; // 默认非公平策略 sync = new NonfairSync();&#125; ReentrantLock(boolean)型构造函数 可以传递参数确定采用公平策略或者是非公平策略，参数为true表示公平策略，否则，采用非公平策略: 123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 核心函数分析通过分析ReentrantLock的源码，可知对其操作都转化为对Sync对象的操作，由于Sync继承了AQS，所以基本上都可以转化为对AQS的操作。如将ReentrantLock的lock函数转化为对Sync的lock函数的调用，而具体会根据采用的策略(如公平策略或者非公平策略)的不同而调用到Sync的不同子类。 所以可知，在ReentrantLock的背后，是AQS对其服务提供了支持，由于之前我们分析AQS的核心源码，遂不再累赘。下面还是通过例子来更进一步分析源码。 示例分析公平锁12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class MyThread extends Thread &#123; private Lock lock; public MyThread(String name, Lock lock) &#123; super(name); this.lock = lock; &#125; public void run () &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread() + &quot; running&quot;); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;public class AbstractQueuedSynchronizerDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Lock lock = new ReentrantLock(true); MyThread t1 = new MyThread(&quot;t1&quot;, lock); MyThread t2 = new MyThread(&quot;t2&quot;, lock); MyThread t3 = new MyThread(&quot;t3&quot;, lock); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果(某一次): 123Thread[t1,5,main] runningThread[t2,5,main] runningThread[t3,5,main] running 说明: 该示例使用的是公平策略，由结果可知，可能会存在如下一种时序。 说明: 首先，t1线程的lock操作 -&gt; t2线程的lock操作 -&gt; t3线程的lock操作 -&gt; t1线程的unlock操作 -&gt; t2线程的unlock操作 -&gt; t3线程的unlock操作。根据这个时序图来进一步分析源码的工作流程。 t1线程执行lock.lock，下图给出了方法调用中的主要方法。 说明: 由调用流程可知，t1线程成功获取了资源，可以继续执行。 t2线程执行lock.lock，下图给出了方法调用中的主要方法。 说明: 由上图可知，最后的结果是t2线程会被禁止，因为调用了LockSupport.park。 t3线程执行lock.lock，下图给出了方法调用中的主要方法。 说明: 由上图可知，最后的结果是t3线程会被禁止，因为调用了LockSupport.park。 t1线程调用了lock.unlock，下图给出了方法调用中的主要方法。 说明: 如上图所示，最后，head的状态会变为0，t2线程会被unpark，即t2线程可以继续运行。此时t3线程还是被禁止。 t2获得cpu资源，继续运行，由于t2之前被park了，现在需要恢复之前的状态，下图给出了方法调用中的主要方法。 说明: 在setHead函数中会将head设置为之前head的下一个结点，并且将pre域与thread域都设置为null，在acquireQueued返回之前，sync queue就只有两个结点了。 t2执行lock.unlock，下图给出了方法调用中的主要方法。 说明: 由上图可知，最终unpark t3线程，让t3线程可以继续运行。 t3线程获取cpu资源，恢复之前的状态，继续运行。 说明: 最终达到的状态是sync queue中只剩下了一个结点，并且该节点除了状态为0外，其余均为null。 t3执行lock.unlock，下图给出了方法调用中的主要方法。 说明: 最后的状态和之前的状态是一样的，队列中有一个空节点，头节点为尾节点均指向它。 使用公平策略和Condition的情况可以参考上一篇关于AQS的源码示例分析部分，不再累赘。 参考文章 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5383609.html，在此基础上做了增改。","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"11.JUC锁: 锁核心类AQS详解","path":"/2023/12/25/11-JUC锁-锁核心类AQS详解/","content":"AbstractQueuedSynchronizer抽象类是核心，需要重点掌握。它提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 什么是AQS? 为什么它是核心? AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等 AQS有哪些核心的方法? AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。 AQS底层使用了什么样的设计模式? 模板 AQS的应用示例? AbstractQueuedSynchronizer简介AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。 AQS 核心思想AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。 AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。 1private volatile int state;//共享变量，使用volatile修饰保证线程可见性 状态信息通过procted类型的getState，setState，compareAndSetState进行操作 123456789101112//返回同步状态的当前值protected final int getState() &#123; return state;&#125; // 设置同步状态的值protected final void setState(int newState) &#123; state = newState;&#125;//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; AQS 对资源的共享方式AQS定义两种资源共享方式 Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的 Share(共享)：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。 ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。 不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队&#x2F;唤醒出队等)，AQS已经在上层已经帮我们实现好了。 AQS底层使用了模板方法模式 同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样(模板方法模式很经典的一个应用)： 使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。 这和我们以往通过实现接口的方式有很大区别，模板方法模式请参看：设计模式行为型 - 模板方法(Template Method)详解 AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法： 12345isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。 默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 AbstractQueuedSynchronizer数据结构AbstractQueuedSynchronizer类底层的数据结构是使用CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。 AbstractQueuedSynchronizer源码分析类的继承关系AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。 1public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable 其中AbstractOwnableSynchronizer抽象类的源码如下: 12345678910111213141516171819public abstract class AbstractOwnableSynchronizer implements java.io.Serializable &#123; // 版本序列号 private static final long serialVersionUID = 3737899427754241961L; // 构造方法 protected AbstractOwnableSynchronizer() &#123; &#125; // 独占模式下的线程 private transient Thread exclusiveOwnerThread; // 设置独占线程 protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread; &#125; // 获取独占线程 protected final Thread getExclusiveOwnerThread() &#123; return exclusiveOwnerThread; &#125;&#125; AbstractOwnableSynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。 AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类。下面分别做介绍。 类的内部类 - Node类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static final class Node &#123; // 模式，分为共享与独占 // 共享模式 static final Node SHARED = new Node(); // 独占模式 static final Node EXCLUSIVE = null; // 结点状态 // CANCELLED，值为1，表示当前的线程被取消 // SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark // CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中 // PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行 // 值为0，表示当前节点在sync队列中，等待着获取锁 static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; // 结点状态 volatile int waitStatus; // 前驱结点 volatile Node prev; // 后继结点 volatile Node next; // 结点所对应的线程 volatile Thread thread; // 下一个等待者 Node nextWaiter; // 结点是否在共享模式下等待 final boolean isShared() &#123; return nextWaiter == SHARED; &#125; // 获取前驱结点，若前驱结点为空，抛出异常 final Node predecessor() throws NullPointerException &#123; // 保存前驱结点 Node p = prev; if (p == null) // 前驱结点为空，抛出异常 throw new NullPointerException(); else // 前驱结点不为空，返回 return p; &#125; // 无参构造方法 Node() &#123; // Used to establish initial head or SHARED marker &#125; // 构造方法 Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; // 构造方法 Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下。 CANCELLED，值为1，表示当前的线程被取消。 SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。 CONDITION，值为-2，表示当前节点在等待condition，也就是在condition queue中。 PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行。 值为0，表示当前节点在sync queue中，等待着获取锁。 类的内部类 - ConditionObject类这个类有点长，耐心看下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472// 内部类public class ConditionObject implements Condition, java.io.Serializable &#123; // 版本号 private static final long serialVersionUID = 1173984872572414699L; /** First node of condition queue. */ // condition队列的头节点 private transient Node firstWaiter; /** Last node of condition queue. */ // condition队列的尾结点 private transient Node lastWaiter; /** * Creates a new &#123;@code ConditionObject&#125; instance. */ // 构造方法 public ConditionObject() &#123; &#125; // Internal methods /** * Adds a new waiter to wait queue. * @return its new wait node */ // 添加新的waiter到wait队列 private Node addConditionWaiter() &#123; // 保存尾结点 Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; // 尾结点不为空，并且尾结点的状态不为CONDITION // 清除状态为CONDITION的结点 unlinkCancelledWaiters(); // 将最后一个结点重新赋值给t t = lastWaiter; &#125; // 新建一个结点 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) // 尾结点为空 // 设置condition队列的头节点 firstWaiter = node; else // 尾结点不为空 // 设置为节点的nextWaiter域为node结点 t.nextWaiter = node; // 更新condition队列的尾结点 lastWaiter = node; return node; &#125; /** * Removes and transfers nodes until hit non-cancelled one or * null. Split out from signal in part to encourage compilers * to inline the case of no waiters. * @param first (non-null) the first node on condition queue */ private void doSignal(Node first) &#123; // 循环 do &#123; if ( (firstWaiter = first.nextWaiter) == null) // 该节点的nextWaiter为空 // 设置尾结点为空 lastWaiter = null; // 设置first结点的nextWaiter域 first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); // 将结点从condition队列转移到sync队列失败并且condition队列中的头节点不为空，一直循环 &#125; /** * Removes and transfers all nodes. * @param first (non-null) the first node on condition queue */ private void doSignalAll(Node first) &#123; // condition队列的头节点尾结点都设置为空 lastWaiter = firstWaiter = null; // 循环 do &#123; // 获取first结点的nextWaiter域结点 Node next = first.nextWaiter; // 设置first结点的nextWaiter域为空 first.nextWaiter = null; // 将first结点从condition队列转移到sync队列 transferForSignal(first); // 重新设置first first = next; &#125; while (first != null); &#125; /** * Unlinks cancelled waiter nodes from condition queue. * Called only while holding lock. This is called when * cancellation occurred during condition wait, and upon * insertion of a new waiter when lastWaiter is seen to have * been cancelled. This method is needed to avoid garbage * retention in the absence of signals. So even though it may * require a full traversal, it comes into play only when * timeouts or cancellations occur in the absence of * signals. It traverses all nodes rather than stopping at a * particular target to unlink all pointers to garbage nodes * without requiring many re-traversals during cancellation * storms. */ // 从condition队列中清除状态为CANCEL的结点 private void unlinkCancelledWaiters() &#123; // 保存condition队列头节点 Node t = firstWaiter; Node trail = null; while (t != null) &#123; // t不为空 // 下一个结点 Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; // t结点的状态不为CONDTION状态 // 设置t节点的nextWaiter域为空 t.nextWaiter = null; if (trail == null) // trail为空 // 重新设置condition队列的头节点 firstWaiter = next; else // trail不为空 // 设置trail结点的nextWaiter域为next结点 trail.nextWaiter = next; if (next == null) // next结点为空 // 设置condition队列的尾结点 lastWaiter = trail; &#125; else // t结点的状态为CONDTION状态 // 设置trail结点 trail = t; // 设置t结点 t = next; &#125; &#125; // public methods /** * Moves the longest-waiting thread, if one exists, from the * wait queue for this condition to the wait queue for the * owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。 public final void signal() &#123; if (!isHeldExclusively()) // 不被当前线程独占，抛出异常 throw new IllegalMonitorStateException(); // 保存condition队列头节点 Node first = firstWaiter; if (first != null) // 头节点不为空 // 唤醒一个等待线程 doSignal(first); &#125; /** * Moves all threads from the wait queue for this condition to * the wait queue for the owning lock. * * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。 public final void signalAll() &#123; if (!isHeldExclusively()) // 不被当前线程独占，抛出异常 throw new IllegalMonitorStateException(); // 保存condition队列头节点 Node first = firstWaiter; if (first != null) // 头节点不为空 // 唤醒所有等待线程 doSignalAll(first); &#125; /** * Implements uninterruptible condition wait. * &lt;ol&gt; * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;/ol&gt; */ // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断 public final void awaitUninterruptibly() &#123; // 添加一个结点到等待队列 Node node = addConditionWaiter(); // 获取释放的状态 int savedState = fullyRelease(node); boolean interrupted = false; while (!isOnSyncQueue(node)) &#123; // // 阻塞当前线程 LockSupport.park(this); if (Thread.interrupted()) // 当前线程被中断 // 设置interrupted状态 interrupted = true; &#125; if (acquireQueued(node, savedState) || interrupted) // selfInterrupt(); &#125; /* * For interruptible waits, we need to track whether to throw * InterruptedException, if interrupted while blocked on * condition, versus reinterrupt current thread, if * interrupted while blocked waiting to re-acquire. */ /** Mode meaning to reinterrupt on exit from wait */ private static final int REINTERRUPT = 1; /** Mode meaning to throw InterruptedException on exit from wait */ private static final int THROW_IE = -1; /** * Checks for interrupt, returning THROW_IE if interrupted * before signalled, REINTERRUPT if after signalled, or * 0 if not interrupted. */ private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0; &#125; /** * Throws InterruptedException, reinterrupts current thread, or * does nothing, depending on mode. */ private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt(); &#125; /** * Implements interruptible condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled or interrupted. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ // // 等待，当前线程在接到信号或被中断之前一直处于等待状态 public final void await() throws InterruptedException &#123; if (Thread.interrupted()) // 当前线程被中断，抛出异常 throw new InterruptedException(); // 在wait队列上添加一个结点 Node node = addConditionWaiter(); // int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; // 阻塞当前线程 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) // 检查结点等待时的中断类型 break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;/ol&gt; */ // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime(); &#125; /** * Implements absolute timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态 public final boolean awaitUntil(Date deadline) throws InterruptedException &#123; long abstime = deadline.getTime(); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (System.currentTimeMillis() &gt; abstime) &#123; timedout = transferAfterCancelledWait(node); break; &#125; LockSupport.parkUntil(this, abstime); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; /** * Implements timed condition wait. * &lt;ol&gt; * &lt;li&gt; If current thread is interrupted, throw InterruptedException. * &lt;li&gt; Save lock state returned by &#123;@link #getState&#125;. * &lt;li&gt; Invoke &#123;@link #release&#125; with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li&gt; Block until signalled, interrupted, or timed out. * &lt;li&gt; Reacquire by invoking specialized version of * &#123;@link #acquire&#125; with saved state as argument. * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException. * &lt;li&gt; If timed out while blocked in step 4, return false, else true. * &lt;/ol&gt; */ // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0 public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; long nanosTimeout = unit.toNanos(time); if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; if (nanosTimeout &lt;= 0L) &#123; timedout = transferAfterCancelledWait(node); break; &#125; if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return !timedout; &#125; // support for instrumentation /** * Returns true if this condition was created by the given * synchronization object. * * @return &#123;@code true&#125; if owned */ final boolean isOwnedBy(AbstractQueuedSynchronizer sync) &#123; return sync == AbstractQueuedSynchronizer.this; &#125; /** * Queries whether any threads are waiting on this condition. * Implements &#123;@link AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;. * * @return &#123;@code true&#125; if there are any waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ // 查询是否有正在等待此条件的任何线程 protected final boolean hasWaiters() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) return true; &#125; return false; &#125; /** * Returns an estimate of the number of threads waiting on * this condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;. * * @return the estimated number of waiting threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ // 返回正在等待此条件的线程数估计值 protected final int getWaitQueueLength() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int n = 0; for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) ++n; &#125; return n; &#125; /** * Returns a collection containing those threads that may be * waiting on this Condition. * Implements &#123;@link AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;. * * @return the collection of threads * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125; * returns &#123;@code false&#125; */ // 返回包含那些可能正在等待此条件的线程集合 protected final Collection&lt;Thread&gt; getWaitingThreads() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); ArrayList&lt;Thread&gt; list = new ArrayList&lt;Thread&gt;(); for (Node w = firstWaiter; w != null; w = w.nextWaiter) &#123; if (w.waitStatus == Node.CONDITION) &#123; Thread t = w.thread; if (t != null) list.add(t); &#125; &#125; return list; &#125;&#125; 此类实现了Condition接口，Condition接口定义了条件操作规范，具体如下 1234567891011121314151617181920212223public interface Condition &#123; // 等待，当前线程在接到信号或被中断之前一直处于等待状态 void await() throws InterruptedException; // 等待，当前线程在接到信号之前一直处于等待状态，不响应中断 void awaitUninterruptibly(); //等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态 long awaitNanos(long nanosTimeout) throws InterruptedException; // 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。此方法在行为上等效于: awaitNanos(unit.toNanos(time)) &gt; 0 boolean await(long time, TimeUnit unit) throws InterruptedException; // 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态 boolean awaitUntil(Date deadline) throws InterruptedException; // 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从 await 返回之前，该线程必须重新获取锁。 void signal(); // 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在从 await 返回之前，每个线程都必须重新获取锁。 void signalAll();&#125; Condition接口中定义了await、signal方法，用来等待条件、释放条件。之后会详细分析CondtionObject的源码。 类的属性属性中包含了头节点head，尾结点tail，状态state、自旋时间spinForTimeoutThreshold，还有AbstractQueuedSynchronizer抽象的属性在内存中的偏移地址，通过该偏移地址，可以获取和设置该属性的值，同时还包括一个静态初始化块，用于加载内存偏移地址。 123456789101112131415161718192021222324252627282930313233343536373839404142public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable &#123; // 版本号 private static final long serialVersionUID = 7373984972572414691L; // 头节点 private transient volatile Node head; // 尾结点 private transient volatile Node tail; // 状态 private volatile int state; // 自旋时间 static final long spinForTimeoutThreshold = 1000L; // Unsafe类实例 private static final Unsafe unsafe = Unsafe.getUnsafe(); // state内存偏移地址 private static final long stateOffset; // head内存偏移地址 private static final long headOffset; // state内存偏移地址 private static final long tailOffset; // tail内存偏移地址 private static final long waitStatusOffset; // next内存偏移地址 private static final long nextOffset; // 静态初始化块 static &#123; try &#123; stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;)); headOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;head&quot;)); tailOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;tail&quot;)); waitStatusOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(&quot;waitStatus&quot;)); nextOffset = unsafe.objectFieldOffset (Node.class.getDeclaredField(&quot;next&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125;&#125; 类的构造方法此类构造方法为从抽象构造方法，供子类调用。 1protected AbstractQueuedSynchronizer() &#123; &#125; 类的核心方法 - acquire方法该方法以独占模式获取(资源)，忽略中断，即线程在aquire过程中，中断此线程是无效的。源码如下: 1234public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 由上述源码可以知道，当一个线程调用acquire时，调用方法流程如下 首先调用tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。 若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。 调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。 由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。 首先分析addWaiter方法 12345678910111213141516171819// 添加等待者private Node addWaiter(Node mode) &#123; // 新生成一个结点，默认为独占模式 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 保存尾结点 Node pred = tail; if (pred != null) &#123; // 尾结点不为空，即已经被初始化 // 将node结点的prev域连接到尾结点 node.prev = pred; if (compareAndSetTail(pred, node)) &#123; // 比较pred是否为尾结点，是则将尾结点设置为node // 设置尾结点的next域为node pred.next = node; return node; // 返回新生成的结点 &#125; &#125; enq(node); // 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列 return node;&#125; addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下 123456789101112131415161718private Node enq(final Node node) &#123; for (;;) &#123; // 无限循环，确保结点能够成功入队列 // 保存尾结点 Node t = tail; if (t == null) &#123; // 尾结点为空，即还没被初始化 if (compareAndSetHead(new Node())) // 头节点为空，并设置头节点为新生成的结点 tail = head; // 头节点与尾结点都指向同一个新生结点 &#125; else &#123; // 尾结点不为空，即已经被初始化过 // 将node结点的prev域连接到尾结点 node.prev = t; if (compareAndSetTail(t, node)) &#123; // 比较结点t是否为尾结点，若是则将尾结点设置为node // 设置尾结点的next域为node t.next = node; return t; // 返回尾结点 &#125; &#125; &#125;&#125; enq方法会使用无限循环来确保节点的成功插入。 现在，分析acquireQueue方法。其源码如下 12345678910111213141516171819202122232425// sync队列中的结点在独占且忽略中断的模式下获取(资源)final boolean acquireQueued(final Node node, int arg) &#123; // 标志 boolean failed = true; try &#123; // 中断标志 boolean interrupted = false; for (;;) &#123; // 无限循环 // 获取node节点的前驱结点 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 前驱为头节点并且成功获得锁 setHead(node); // 设置头节点 p.next = null; // help GC failed = false; // 设置标志 return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 首先获取当前节点的前驱节点，如果前驱节点是头节点并且能够获取(资源)，代表该当前节点能够占有锁，设置头节点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法，首先，我们看shouldParkAfterFailedAcquire方法，代码如下 123456789101112131415161718192021222324252627282930313233// 当获取(资源)失败后，检查并且更新结点状态private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 获取前驱结点的状态 int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 状态为SIGNAL，为-1 /* * This node has already set status asking a release * to signal it, so it can safely park. */ // 可以进行park操作 return true; if (ws &gt; 0) &#123; // 表示状态为CANCELLED，为1 /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); // 找到pred结点前面最近的一个状态不为CANCELLED的结点 // 赋值pred结点的next域 pred.next = node; &#125; else &#123; // 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don&#x27;t park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ // 比较并设置前驱结点的状态为SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; // 不能进行park操作 return false;&#125; 只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt方法，源码如下 123456// 进行park操作并且返回该线程是否被中断private final boolean parkAndCheckInterrupt() &#123; // 在许可可用之前禁用当前线程，并且设置了blocker LockSupport.park(this); return Thread.interrupted(); // 当前线程是否已被中断，并清除中断标记位&#125; parkAndCheckInterrupt方法里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire方法，其源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 取消继续获取(资源)private void cancelAcquire(Node node) &#123; // Ignore if node doesn&#x27;t exist // node为空，返回 if (node == null) return; // 设置node结点的thread为空 node.thread = null; // Skip cancelled predecessors // 保存node的前驱结点 Node pred = node.prev; while (pred.waitStatus &gt; 0) // 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点 node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. // 获取pred结点的下一个结点 Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. // 设置node结点的状态为CANCELLED node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; // node结点为尾结点，则设置尾结点为pred结点 // 比较并设置pred结点的next节点为null compareAndSetNext(pred, predNext, null); &#125; else &#123; // node结点不为尾结点，或者比较设置不成功 // If successor needs signal, try to set pred&#x27;s next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; // (pred结点不为头节点，并且pred结点的状态为SIGNAL)或者 // pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空 // 保存结点的后继 Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) // 后继不为空并且后继的状态小于等于0 compareAndSetNext(pred, predNext, next); // 比较并设置pred.next = next; &#125; else &#123; unparkSuccessor(node); // 释放node的前一个结点 &#125; node.next = node; // help GC &#125;&#125; 该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor方法，源码如下 123456789101112131415161718192021222324252627282930313233// 释放后继结点private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ // 获取node结点的等待状态 int ws = node.waitStatus; if (ws &lt; 0) // 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3 // 比较并且设置结点等待状态，设置为0 compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ // 获取node节点的下一个结点 Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; // 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED // s赋值为空 s = null; // 从尾结点开始从后往前开始遍历 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) // 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点 // 保存结点 s = t; &#125; if (s != null) // 该结点不为为空，释放许可 LockSupport.unpark(s.thread);&#125; 该方法的作用就是为了释放node节点的后继结点。 对于cancelAcquire与unparkSuccessor方法，如下示意图可以清晰的表示: 其中node为参数，在执行完cancelAcquire方法后的效果就是unpark了s结点所包含的t4线程。 现在，再来看acquireQueued方法的整个的逻辑。逻辑如下: 判断结点的前驱是否为head并且是否成功获取(资源)。 若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。 若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。 若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。 类的核心方法 - release方法以独占模式释放对象，其源码如下: 12345678910public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; // 释放成功 // 保存头节点 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) // 头节点不为空并且头节点状态不为0 unparkSuccessor(h); //释放头节点的后继结点 return true; &#125; return false;&#125; 其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头节点不为空并且头节点的状态不为0，则释放头节点的后继结点，unparkSuccessor方法已经分析过，不再累赘。 对于其他方法我们也可以分析，与前面分析的方法大同小异，所以，不再累赘。 AbstractQueuedSynchronizer示例详解一借助下面示例来分析AbstractQueuedSyncrhonizer内部的工作机制。示例源码如下 1234567891011121314151617181920212223242526272829import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class MyThread extends Thread &#123; private Lock lock; public MyThread(String name, Lock lock) &#123; super(name); this.lock = lock; &#125; public void run () &#123; lock.lock(); try &#123; System.out.println(Thread.currentThread() + &quot; running&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;public class AbstractQueuedSynchronizerDemo &#123; public static void main(String[] args) &#123; Lock lock = new ReentrantLock(); MyThread t1 = new MyThread(&quot;t1&quot;, lock); MyThread t2 = new MyThread(&quot;t2&quot;, lock); t1.start(); t2.start(); &#125;&#125; 运行结果(可能的一种): 12Thread[t1,5,main] runningThread[t2,5,main] running 结果分析: 从示例可知，线程t1与t2共用了一把锁，即同一个lock。可能会存在如下一种时序。 说明: 首先线程t1先执行lock.lock操作，然后t2执行lock.lock操作，然后t1执行lock.unlock操作，最后t2执行lock.unlock操作。基于这样的时序，分析AbstractQueuedSynchronizer内部的工作机制。 t1线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。 说明: 其中，前面的部分表示哪个类，后面是具体的类中的哪个方法，AQS表示AbstractQueuedSynchronizer类，AOS表示AbstractOwnableSynchronizer类。 t2线程调用lock.lock方法，其方法调用顺序如下，只给出了主要的方法调用。 说明: 经过一系列的方法调用，最后达到的状态是禁用t2线程，因为调用了LockSupport.park。 t1线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。 说明: t1线程中调用lock.unlock后，经过一系列的调用，最终的状态是释放了许可，因为调用了LockSupport.unpark。这时，t2线程就可以继续运行了。此时，会继续恢复t2线程运行环境，继续执行LockSupport.park后面的语句，即进一步调用如下。 说明: 在上一步调用了LockSupport.unpark后，t2线程恢复运行，则运行parkAndCheckInterrupt，之后，继续运行acquireQueued方法，最后达到的状态是头节点head与尾结点tail均指向了t2线程所在的结点，并且之前的头节点已经从sync队列中断开了。 t2线程调用lock.unlock，其方法调用顺序如下，只给出了主要的方法调用。 说明: t2线程执行lock.unlock后，最终达到的状态还是与之前的状态一样。 AbstractQueuedSynchronizer示例详解二下面我们结合Condition实现生产者与消费者，来进一步分析AbstractQueuedSynchronizer的内部工作机制。 Depot(仓库)类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Depot &#123; private int size; private int capacity; private Lock lock; private Condition fullCondition; private Condition emptyCondition; public Depot(int capacity) &#123; this.capacity = capacity; lock = new ReentrantLock(); fullCondition = lock.newCondition(); emptyCondition = lock.newCondition(); &#125; public void produce(int no) &#123; lock.lock(); int left = no; try &#123; while (left &gt; 0) &#123; while (size &gt;= capacity) &#123; System.out.println(Thread.currentThread() + &quot; before await&quot;); fullCondition.await(); System.out.println(Thread.currentThread() + &quot; after await&quot;); &#125; int inc = (left + size) &gt; capacity ? (capacity - size) : left; left -= inc; size += inc; System.out.println(&quot;produce = &quot; + inc + &quot;, size = &quot; + size); emptyCondition.signal(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume(int no) &#123; lock.lock(); int left = no; try &#123; while (left &gt; 0) &#123; while (size &lt;= 0) &#123; System.out.println(Thread.currentThread() + &quot; before await&quot;); emptyCondition.await(); System.out.println(Thread.currentThread() + &quot; after await&quot;); &#125; int dec = (size - left) &gt; 0 ? left : size; left -= dec; size -= dec; System.out.println(&quot;consume = &quot; + dec + &quot;, size = &quot; + size); fullCondition.signal(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 测试类 123456789101112131415161718192021222324252627282930313233343536373839404142class Consumer &#123; private Depot depot; public Consumer(Depot depot) &#123; this.depot = depot; &#125; public void consume(int no) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; depot.consume(no); &#125; &#125;, no + &quot; consume thread&quot;).start(); &#125;&#125;class Producer &#123; private Depot depot; public Producer(Depot depot) &#123; this.depot = depot; &#125; public void produce(int no) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; depot.produce(no); &#125; &#125;, no + &quot; produce thread&quot;).start(); &#125;&#125;public class ReentrantLockDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Depot depot = new Depot(500); new Producer(depot).produce(500); new Producer(depot).produce(200); new Consumer(depot).consume(500); new Consumer(depot).consume(200); &#125;&#125; 运行结果(可能的一种): 12345678produce = 500, size = 500Thread[200 produce thread,5,main] before awaitconsume = 500, size = 0Thread[200 consume thread,5,main] before awaitThread[200 produce thread,5,main] after awaitproduce = 200, size = 200Thread[200 consume thread,5,main] after awaitconsume = 200, size = 0 说明: 根据结果，我们猜测一种可能的时序如下 说明: p1代表produce 500的那个线程，p2代表produce 200的那个线程，c1代表consume 500的那个线程，c2代表consume 200的那个线程。 p1线程调用lock.lock，获得锁，继续运行，方法调用顺序在前面已经给出。 p2线程调用lock.lock，由前面的分析可得到如下的最终状态。 说明: p2线程调用lock.lock后，会禁止p2线程的继续运行，因为执行了LockSupport.park操作。 c1线程调用lock.lock，由前面的分析得到如下的最终状态。 说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含p2的结点)的waitStatus变为了SIGNAL。 c2线程调用lock.lock，由前面的分析得到如下的最终状态。 说明: 最终c1线程会在sync queue队列的尾部，并且其结点的前驱结点(包含c1的结点)的waitStatus变为了SIGNAL。 p1线程执行emptyCondition.signal，其方法调用顺序如下，只给出了主要的方法调用。 说明: AQS.CO表示AbstractQueuedSynchronizer.ConditionObject类。此时调用signal方法不会产生任何其他效果。 p1线程执行lock.unlock，根据前面的分析可知，最终的状态如下。 说明: 此时，p2线程所在的结点为头节点，并且其他两个线程(c1、c2)依旧被禁止，所以，此时p2线程继续运行，执行用户逻辑。 p2线程执行fullCondition.await，其方法调用顺序如下，只给出了主要的方法调用。 说明: 最终到达的状态是新生成了一个结点，包含了p2线程，此结点在condition queue中；并且sync queue中p2线程被禁止了，因为在执行了LockSupport.park操作。从方法一些调用可知，在await操作中线程会释放锁资源，供其他线程获取。同时，head结点后继结点的包含的线程的许可被释放了，故其可以继续运行。由于此时，只有c1线程可以运行，故运行c1。 继续运行c1线程，c1线程由于之前被park了，所以此时恢复，继续之前的步骤，即还是执行前面提到的acquireQueued方法，之后，c1判断自己的前驱结点为head，并且可以获取锁资源，最终到达的状态如下。 说明: 其中，head设置为包含c1线程的结点，c1继续运行。 c1线程执行fullCondtion.signal，其方法调用顺序如下，只给出了主要的方法调用。 说明: signal方法达到的最终结果是将包含p2线程的结点从condition queue中转移到sync queue中，之后condition queue为null，之前的尾结点的状态变为SIGNAL。 c1线程执行lock.unlock操作，根据之前的分析，经历的状态变化如下。 说明: 最终c2线程会获取锁资源，继续运行用户逻辑。 c2线程执行emptyCondition.await，由前面的第七步分析，可知最终的状态如下。 说明: await操作将会生成一个结点放入condition queue中与之前的一个condition queue是不相同的，并且unpark头节点后面的结点，即包含线程p2的结点。 p2线程被unpark，故可以继续运行，经过CPU调度后，p2继续运行，之后p2线程在AQS:await方法中被park，继续AQS.CO:await方法的运行，其方法调用顺序如下，只给出了主要的方法调用。 p2继续运行，执行emptyCondition.signal，根据第九步分析可知，最终到达的状态如下。 说明: 最终，将condition queue中的结点转移到sync queue中，并添加至尾部，condition queue会为空，并且将head的状态设置为SIGNAL。 p2线程执行lock.unlock操作，根据前面的分析可知，最后的到达的状态如下。 说明: unlock操作会释放c2线程的许可，并且将头节点设置为c2线程所在的结点。 c2线程继续运行，执行fullCondition. signal，由于此时fullCondition的condition queue已经不存在任何结点了，故其不会产生作用。 c2执行lock.unlock，由于c2是sync队列中最后一个结点，故其不会再调用unparkSuccessor了，直接返回true。即整个流程就完成了。 AbstractQueuedSynchronizer总结对于AbstractQueuedSynchronizer的分析，最核心的就是sync queue的分析。 每一个结点都是由前一个结点唤醒 当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。 condition queue中的结点向sync queue中转移是通过signal操作完成的。 当结点的状态为SIGNAL时，表示后面的结点需要运行。 参考文章 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5350186.html，在此基础上做了增改。 http://ifeve.com/introduce-abstractqueuedsynchronizer/ http://blog.csdn.net/chen77716/article/details/6641477 https://blog.csdn.net/mulinsen77/article/details/84583716","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"10.JUC锁: LockSupport详解","path":"/2023/12/25/10-JUC锁-LockSupport详解/","content":"LockSupport是锁中的基础，是一个提供锁机制的工具类，所以先对其进行分析。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park&#x2F;unpark操作) 写出分别通过wait&#x2F;notify和LockSupport的park&#x2F;unpark实现同步? LockSupport.park()会释放锁资源吗? 那么Condition.await()呢? Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点 如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样? LockSupport简介LockSupport用来创建锁和其他同步类的基本线程阻塞原语。简而言之，当调用LockSupport.park时，表示当前线程将会等待，直至获得许可，当调用LockSupport.unpark时，必须把等待获得许可的线程作为参数进行传递，好让此线程继续运行。 LockSupport源码分析类的属性123456789101112131415161718192021222324252627282930313233public class LockSupport &#123; // Hotspot implementation via intrinsics API private static final sun.misc.Unsafe UNSAFE; // 表示内存偏移地址 private static final long parkBlockerOffset; // 表示内存偏移地址 private static final long SEED; // 表示内存偏移地址 private static final long PROBE; // 表示内存偏移地址 private static final long SECONDARY; static &#123; try &#123; // 获取Unsafe实例 UNSAFE = sun.misc.Unsafe.getUnsafe(); // 线程类类型 Class&lt;?&gt; tk = Thread.class; // 获取Thread的parkBlocker字段的内存偏移地址 parkBlockerOffset = UNSAFE.objectFieldOffset (tk.getDeclaredField(&quot;parkBlocker&quot;)); // 获取Thread的threadLocalRandomSeed字段的内存偏移地址 SEED = UNSAFE.objectFieldOffset (tk.getDeclaredField(&quot;threadLocalRandomSeed&quot;)); // 获取Thread的threadLocalRandomProbe字段的内存偏移地址 PROBE = UNSAFE.objectFieldOffset (tk.getDeclaredField(&quot;threadLocalRandomProbe&quot;)); // 获取Thread的threadLocalRandomSecondarySeed字段的内存偏移地址 SECONDARY = UNSAFE.objectFieldOffset (tk.getDeclaredField(&quot;threadLocalRandomSecondarySeed&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125;&#125; 说明: UNSAFE字段表示sun.misc.Unsafe类，查看其源码，点击在这里，一般程序中不允许直接调用，而long型的表示实例对象相应字段在内存中的偏移地址，可以通过该偏移地址获取或者设置该字段的值。 类的构造函数12// 私有构造函数，无法被实例化private LockSupport() &#123;&#125; 说明: LockSupport只有一个私有构造函数，无法被实例化。 核心函数分析在分析LockSupport函数之前，先引入sun.misc.Unsafe类中的park和unpark函数，因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义: 12public native void park(boolean isAbsolute, long time);public native void unpark(Thread thread); 说明: 对两个函数的说明如下: park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，释放该线程的许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。 unpark函数，释放线程的许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。 park函数park函数有两个重载版本，方法摘要如下 12public static void park()；public static void park(Object blocker)； 说明: 两个函数的区别在于park()函数没有没有blocker，即没有设置线程的parkBlocker字段。park(Object)型函数如下。 12345678910public static void park(Object blocker) &#123; // 获取当前线程 Thread t = Thread.currentThread(); // 设置Blocker setBlocker(t, blocker); // 获取许可 UNSAFE.park(false, 0L); // 重新可运行后再此设置Blocker setBlocker(t, null);&#125; 说明: 调用park函数时，首先获取当前线程，然后设置当前线程的parkBlocker字段，即调用setBlocker函数，之后调用Unsafe类的park函数，之后再调用setBlocker函数。那么问题来了，为什么要在此park函数中要调用两次setBlocker函数呢? 原因其实很简单，调用park函数时，当前线程首先设置好parkBlocker字段，然后再调用Unsafe的park函数，此后，当前线程就已经阻塞了，等待该线程的unpark函数被调用，所以后面的一个setBlocker函数无法运行，unpark函数被调用，该线程获得许可后，就可以继续运行了，也就运行第二个setBlocker，把该线程的parkBlocker字段设置为null，这样就完成了整个park函数的逻辑。如果没有第二个setBlocker，那么之后没有调用park(Object blocker)，而直接调用getBlocker函数，得到的还是前一个park(Object blocker)设置的blocker，显然是不符合逻辑的。总之，必须要保证在park(Object blocker)整个函数执行完后，该线程的parkBlocker字段又恢复为null。所以，park(Object)型函数里必须要调用setBlocker函数两次。setBlocker方法如下。 1234private static void setBlocker(Thread t, Object arg) &#123; // 设置线程t的parkBlocker字段的值为arg UNSAFE.putObject(t, parkBlockerOffset, arg);&#125; 说明: 此方法用于设置线程t的parkBlocker字段的值为arg。 另外一个无参重载版本，park()函数如下。 1234public static void park() &#123; // 获取许可，设置时间为无限长，直到可以获取许可 UNSAFE.park(false, 0L);&#125; 说明: 调用了park函数后，会禁用当前线程，除非许可可用。在以下三种情况之一发生之前，当前线程都将处于休眠状态，即下列情况发生时，当前线程会获取许可，可以继续运行。 其他某个线程将当前线程作为目标调用 unpark。 其他某个线程中断当前线程。 该调用不合逻辑地(即毫无理由地)返回。 parkNanos函数此函数表示在许可可用前禁用当前线程，并最多等待指定的等待时间。具体函数如下。 123456789101112public static void parkNanos(Object blocker, long nanos) &#123; if (nanos &gt; 0) &#123; // 时间大于0 // 获取当前线程 Thread t = Thread.currentThread(); // 设置Blocker setBlocker(t, blocker); // 获取许可，并设置了时间 UNSAFE.park(false, nanos); // 设置许可 setBlocker(t, null); &#125;&#125; 说明: 该函数也是调用了两次setBlocker函数，nanos参数表示相对时间，表示等待多长时间。 parkUntil函数此函数表示在指定的时限前禁用当前线程，除非许可可用, 具体函数如下: 123456789public static void parkUntil(Object blocker, long deadline) &#123; // 获取当前线程 Thread t = Thread.currentThread(); // 设置Blocker setBlocker(t, blocker); UNSAFE.park(true, deadline); // 设置Blocker为null setBlocker(t, null);&#125; 说明: 该函数也调用了两次setBlocker函数，deadline参数表示绝对时间，表示指定的时间。 unpark函数此函数表示如果给定线程的许可尚不可用，则使其可用。如果线程在 park 上受阻塞，则它将解除其阻塞状态。否则，保证下一次调用 park 不会受阻塞。如果给定线程尚未启动，则无法保证此操作有任何效果。具体函数如下: 1234public static void unpark(Thread thread) &#123; if (thread != null) // 线程为不空 UNSAFE.unpark(thread); // 释放该线程许可&#125; 说明: 释放许可，指定线程可以继续运行。 LockSupport示例说明使用wait&#x2F;notify实现线程同步1234567891011121314151617181920212223242526272829class MyThread extends Thread &#123; public void run() &#123; synchronized (this) &#123; System.out.println(&quot;before notify&quot;); notify(); System.out.println(&quot;after notify&quot;); &#125; &#125;&#125;public class WaitAndNotifyDemo &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread myThread = new MyThread(); synchronized (myThread) &#123; try &#123; myThread.start(); // 主线程睡眠3s Thread.sleep(3000); System.out.println(&quot;before wait&quot;); // 阻塞主线程 myThread.wait(); System.out.println(&quot;after wait&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果 1234before waitbefore notifyafter notifyafter wait 说明: 具体的流程图如下 使用wait&#x2F;notify实现同步时，必须先调用wait，后调用notify，如果先调用notify，再调用wait，将起不了作用。具体代码如下 12345678910111213141516171819202122232425262728class MyThread extends Thread &#123; public void run() &#123; synchronized (this) &#123; System.out.println(&quot;before notify&quot;); notify(); System.out.println(&quot;after notify&quot;); &#125; &#125;&#125;public class WaitAndNotifyDemo &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread myThread = new MyThread(); myThread.start(); // 主线程睡眠3s Thread.sleep(3000); synchronized (myThread) &#123; try &#123; System.out.println(&quot;before wait&quot;); // 阻塞主线程 myThread.wait(); System.out.println(&quot;after wait&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行结果: 123before notifyafter notifybefore wait 说明: 由于先调用了notify，再调用的wait，此时主线程还是会一直阻塞。 使用park&#x2F;unpark实现线程同步12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.concurrent.locks.LockSupport;class MyThread extends Thread &#123; private Object object; public MyThread(Object object) &#123; this.object = object; &#125; public void run() &#123; System.out.println(&quot;before unpark&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 获取blocker System.out.println(&quot;Blocker info &quot; + LockSupport.getBlocker((Thread) object)); // 释放许可 LockSupport.unpark((Thread) object); // 休眠500ms，保证先执行park中的setBlocker(t, null); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 再次获取blocker System.out.println(&quot;Blocker info &quot; + LockSupport.getBlocker((Thread) object)); System.out.println(&quot;after unpark&quot;); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(Thread.currentThread()); myThread.start(); System.out.println(&quot;before park&quot;); // 获取许可 LockSupport.park(&quot;ParkAndUnparkDemo&quot;); System.out.println(&quot;after park&quot;); &#125;&#125; 运行结果: 123456before parkbefore unparkBlocker info ParkAndUnparkDemoafter parkBlocker info nullafter unpark 说明: 本程序先执行park，然后在执行unpark，进行同步，并且在unpark的前后都调用了getBlocker，可以看到两次的结果不一样，并且第二次调用的结果为null，这是因为在调用unpark之后，执行了Lock.park(Object blocker)函数中的setBlocker(t, null)函数，所以第二次调用getBlocker时为null。 上例是先调用park，然后调用unpark，现在修改程序，先调用unpark，然后调用park，看能不能正确同步。具体代码如下 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.locks.LockSupport;class MyThread extends Thread &#123; private Object object; public MyThread(Object object) &#123; this.object = object; &#125; public void run() &#123; System.out.println(&quot;before unpark&quot;); // 释放许可 LockSupport.unpark((Thread) object); System.out.println(&quot;after unpark&quot;); &#125;&#125;public class ParkAndUnparkDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(Thread.currentThread()); myThread.start(); try &#123; // 主线程睡眠3s Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;before park&quot;); // 获取许可 LockSupport.park(&quot;ParkAndUnparkDemo&quot;); System.out.println(&quot;after park&quot;); &#125;&#125; 运行结果: 1234before unparkafter unparkbefore parkafter park 说明: 可以看到，在先调用unpark，再调用park时，仍能够正确实现同步，不会造成由wait&#x2F;notify调用顺序不当所引起的阻塞。因此park&#x2F;unpark相比wait&#x2F;notify更加的灵活。 中断响应看下面示例 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.locks.LockSupport;class MyThread extends Thread &#123; private Object object; public MyThread(Object object) &#123; this.object = object; &#125; public void run() &#123; System.out.println(&quot;before interrupt&quot;); try &#123; // 休眠3s Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread thread = (Thread) object; // 中断线程 thread.interrupt(); System.out.println(&quot;after interrupt&quot;); &#125;&#125;public class InterruptDemo &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(Thread.currentThread()); myThread.start(); System.out.println(&quot;before park&quot;); // 获取许可 LockSupport.park(&quot;ParkAndUnparkDemo&quot;); System.out.println(&quot;after park&quot;); &#125;&#125; 运行结果: 1234before parkbefore interruptafter interruptafter park 说明: 可以看到，在主线程调用park阻塞后，在myThread线程中发出了中断信号，此时主线程会继续运行，也就是说明此时interrupt起到的作用与unpark一样。 更深入的理解Thread.sleep()和Object.wait()的区别首先，我们先来看看Thread.sleep()和Object.wait()的区别，这是一个烂大街的题目了，大家应该都能说上来两点。 Thread.sleep()不会释放占有的锁，Object.wait()会释放占有的锁； Thread.sleep()必须传入时间，Object.wait()可传可不传，不传表示一直阻塞下去； Thread.sleep()到时间了会自动唤醒，然后继续执行； Object.wait()不带时间的，需要另一个线程使用Object.notify()唤醒； Object.wait()带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁； 其实，他们俩最大的区别就是Thread.sleep()不会释放锁资源，Object.wait()会释放锁资源。 Object.wait()和Condition.await()的区别Object.wait()和Condition.await()的原理是基本一致的，不同的是Condition.await()底层是调用LockSupport.park()来实现阻塞当前线程的。 实际上，它在阻塞当前线程之前还干了两件事，一是把当前线程添加到条件队列中，二是“完全”释放锁，也就是让state状态变量变为0，然后才是调用LockSupport.park()阻塞当前线程。 Thread.sleep()和LockSupport.park()的区别LockSupport.park()还有几个兄弟方法——parkNanos()、parkUtil()等，我们这里说的park()方法统称这一类方法。 从功能上来说，Thread.sleep()和LockSupport.park()方法类似，都是阻塞当前线程的执行，且都不会释放当前线程占有的锁资源； Thread.sleep()没法从外部唤醒，只能自己醒过来； LockSupport.park()方法可以被另一个线程调用LockSupport.unpark()方法唤醒； Thread.sleep()方法声明上抛出了InterruptedException中断异常，所以调用者需要捕获这个异常或者再抛出； LockSupport.park()方法不需要捕获中断异常； Thread.sleep()本身就是一个native方法； LockSupport.park()底层是调用的Unsafe的native方法； Object.wait()和LockSupport.park()的区别二者都会阻塞当前线程的运行，他们有什么区别呢? 经过上面的分析相信你一定很清楚了，真的吗? 往下看！ Object.wait()方法需要在synchronized块中执行； LockSupport.park()可以在任意地方执行； Object.wait()方法声明抛出了中断异常，调用者需要捕获或者再抛出； LockSupport.park()不需要捕获中断异常； Object.wait()不带超时的，需要另一个线程执行notify()来唤醒，但不一定继续执行后续内容； LockSupport.park()不带超时的，需要另一个线程执行unpark()来唤醒，一定会继续执行后续内容； park()&#x2F;unpark()底层的原理是“二元信号量”，你可以把它相像成只有一个许可证的Semaphore，只不过这个信号量在重复执行unpark()的时候也不会再增加许可证，最多只有一个许可证。 如果在wait()之前执行了notify()会怎样?如果当前的线程不是此对象锁的所有者，却调用该对象的notify()或wait()方法时抛出IllegalMonitorStateException异常； 如果当前线程是此对象锁的所有者，wait()将一直阻塞，因为后续将没有其它notify()唤醒它。 如果在park()之前执行了unpark()会怎样?线程不会被阻塞，直接跳过park()，继续执行后续内容 LockSupport.park()会释放锁资源吗?不会，它只负责阻塞当前线程，释放锁资源实际上是在Condition的await()方法中实现的。 参考文章 文章主要参考自leesf的https://www.cnblogs.com/leesf456/p/5347293.html，在此基础上做了增改。 https://blog.csdn.net/tangtong1/article/details/102829724","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"9.JUC原子类: CAS, Unsafe和原子类详解","path":"/2023/12/25/9-JUC原子类-CAS-Unsafe和原子类详解/","content":"JUC中多数类是通过volatile和CAS来实现的，CAS本质上提供的是一种无锁方案，而Synchronized和Lock是互斥锁方案; java原子类本质上使用的是CAS，而CAS底层是通过Unsafe类实现的。所以本章将对CAS, Unsafe和原子类详解。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 线程安全的实现方法有哪些? 什么是CAS? CAS使用示例，结合AtomicInteger给出示例? CAS会有哪些问题? 针对这这些问题，Java提供了哪几个解决的? AtomicInteger底层实现? CAS+volatile 请阐述你对Unsafe类的理解? 说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景。 AtomicStampedReference是什么? AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号 java中还有哪些类可以解决ABA的问题? AtomicMarkableReference CAS前面我们说到，线程安全的实现方法包含: 互斥同步: synchronized 和 ReentrantLock 非阻塞同步: CAS, AtomicXXXX 无同步方案: 栈封闭，Thread Local，可重入代码 具体可以参看：线程安全的实现方法，这里我们将对CAS重点阐释。 什么是CASCAS的全称为Compare-And-Swap，直译就是对比交换。是一条CPU的原子指令，其作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说CAS是靠硬件实现的，JVM只是封装了汇编调用，那些AtomicInteger类便是使用了这些封装后的接口。 简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。 CAS操作是原子性的，所以多线程并发使用CAS更新数据时，可以不使用锁。JDK中大量使用了CAS来更新数据而防止加锁(synchronized 重量级锁)来保持原子更新。 相信sql大家都熟悉，类似sql中的条件更新一样：update set id&#x3D;3 from table where id&#x3D;2。因为单条sql执行具有原子性，如果有多个线程同时执行此sql语句，只有一条能更新成功。 CAS使用示例如果不使用CAS，在高并发下，多线程同时修改一个变量的值我们需要synchronized加锁(可能有人说可以用Lock加锁，Lock底层的AQS也是基于CAS进行获取锁的)。 123456public class Test &#123; private int i=0; public synchronized int add()&#123; return i++; &#125;&#125; java中为我们提供了AtomicInteger 原子类(底层基于CAS进行更新数据的)，不需要加锁就在多线程并发场景下实现数据的一致性。 123456public class Test &#123; private AtomicInteger i = new AtomicInteger(0); public int add()&#123; return i.addAndGet(1); &#125;&#125; CAS 问题CAS 方式为乐观锁，synchronized 为悲观锁。因此使用 CAS 解决并发问题通常情况下性能更优。 但使用 CAS 方式也会有几个问题： ABA问题因为CAS需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时则会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。 从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行命令(de-pipeline)，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突(Memory Order Violation)而引起CPU流水线被清空(CPU Pipeline Flush)，从而提高CPU的执行效率。 只能保证一个共享变量的原子操作当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i &#x3D; 2，j &#x3D; a，合并一下ij &#x3D; 2a，然后用CAS来操作ij。 从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。 UnSafe类详解 上文我们了解到Java原子类是通过UnSafe类实现的，这节主要分析下UnSafe类。UnSafe类在J.U.C中CAS操作有很广泛的应用。 Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。 这个类尽管里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。 先来看下这张图，对UnSafe类总体功能： 如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。 Unsafe与CAS反编译出来的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final int getAndAddInt(Object paramObject, long paramLong, int paramInt) &#123; int i; do i = getIntVolatile(paramObject, paramLong); while (!compareAndSwapInt(paramObject, paramLong, i, i + paramInt)); return i; &#125; public final long getAndAddLong(Object paramObject, long paramLong1, long paramLong2) &#123; long l; do l = getLongVolatile(paramObject, paramLong1); while (!compareAndSwapLong(paramObject, paramLong1, l, l + paramLong2)); return l; &#125; public final int getAndSetInt(Object paramObject, long paramLong, int paramInt) &#123; int i; do i = getIntVolatile(paramObject, paramLong); while (!compareAndSwapInt(paramObject, paramLong, i, paramInt)); return i; &#125; public final long getAndSetLong(Object paramObject, long paramLong1, long paramLong2) &#123; long l; do l = getLongVolatile(paramObject, paramLong1); while (!compareAndSwapLong(paramObject, paramLong1, l, paramLong2)); return l; &#125; public final Object getAndSetObject(Object paramObject1, long paramLong, Object paramObject2) &#123; Object localObject; do localObject = getObjectVolatile(paramObject1, paramLong); while (!compareAndSwapObject(paramObject1, paramLong, localObject, paramObject2)); return localObject; &#125; 从源码中发现，内部使用自旋的方式进行CAS更新(while循环进行CAS更新，如果更新失败，则循环再次重试)。 又从Unsafe类中发现，原子操作其实只支持下面三个方法。 12345public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3); 我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong。都是native方法。 Unsafe底层不妨再看看Unsafe的compareAndSwap*方法来实现CAS操作，它是一个本地方法，实现位于unsafe.cpp中。 123456UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END 可以看到它通过 Atomic::cmpxchg 来实现比较和替换操作。其中参数x是即将更新的值，参数e是原内存的值。 如果是Linux的x86，Atomic::cmpxchg方法的实现如下： 12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot; : &quot;=a&quot; (exchange_value) : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp) : &quot;cc&quot;, &quot;memory&quot;); return exchange_value;&#125; 而windows的x86的实现如下： 12345678910111213141516171819inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::isMP(); //判断是否是多处理器 _asm &#123; mov edx, dest mov ecx, exchange_value mov eax, compare_value LOCK_IF_MP(mp) cmpxchg dword ptr [edx], ecx &#125;&#125;// Adding a lock prefix to an instruction on MP machine// VC++ doesn&#x27;t like the lock prefix to be on a single line// so we can&#x27;t insert a label after the lock prefix.// By emitting a lock prefix, we can define a label after it.#define LOCK_IF_MP(mp) __asm cmp mp, 0 \\ __asm je L0 \\ __asm _emit 0xF0 \\ __asm L0: 如果是多处理器，为cmpxchg指令添加lock前缀。反之，就省略lock前缀(单处理器会不需要lock前缀提供的内存屏障效果)。这里的lock前缀就是使用了处理器的总线锁(最新的处理器都使用缓存锁代替总线锁来提高性能)。 cmpxchg(void* ptr, int old, int new)，如果ptr和old的值一样，则把new写到ptr内存，否则返回ptr的值，整个操作是原子的。在Intel平台下，会用lock cmpxchg来实现，使用lock触发缓存锁，这样另一个线程想访问ptr的内存，就会被block住。 Unsafe其它功能Unsafe 提供了硬件级别的操作，比如说获取某个属性在内存中的位置，比如说修改对象的字段值，即使它是私有的。不过 Java 本身就是为了屏蔽底层的差异，对于一般的开发而言也很少会有这样的需求。 举两个例子，比方说： 1public native long staticFieldOffset(Field paramField); 这个方法可以用来获取给定的 paramField 的内存地址偏移量，这个值对于给定的 field 是唯一的且是固定不变的。 再比如说： 12public native int arrayBaseOffset(Class paramClass);public native int arrayIndexScale(Class paramClass); 前一个方法是用来获取数组第一个元素的偏移地址，后一个方法是用来获取数组的转换因子即数组中元素的增量地址的。 最后看三个方法： 123public native long allocateMemory(long paramLong);public native long reallocateMemory(long paramLong1, long paramLong2);public native void freeMemory(long paramLong); 分别用来分配内存，扩充内存和释放内存的。 更多相关功能，推荐你看下这篇文章：来自美团技术团队：Java魔法类：Unsafe应用解析在 AtomicInteger使用举例以 AtomicInteger 为例，常用 API： 123456public final int get()：获取当前的值public final int getAndSet(int newValue)：获取当前的值，并设置新的值public final int getAndIncrement()：获取当前的值，并自增public final int getAndDecrement()：获取当前的值，并自减public final int getAndAdd(int delta)：获取当前的值，并加上预期的值void lazySet(int newValue): 最终会设置成newValue,使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 相比 Integer 的优势，多线程中让变量自增： 12345678private volatile int count = 0;// 若要线程安全执行执行 count++，需要加锁public synchronized void increment() &#123; count++;&#125;public int getCount() &#123; return count;&#125; 使用 AtomicInteger 后： 12345678private AtomicInteger count = new AtomicInteger();public void increment() &#123; count.incrementAndGet();&#125;// 使用 AtomicInteger 后，不需要加锁，也可以实现线程安全public int getCount() &#123; return count.get();&#125; 源码解析1234567891011121314151617181920212223242526272829public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; //用于获取value字段相对当前对象的“起始地址”的偏移量 valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; //返回当前值 public final int get() &#123; return value; &#125; //递增加detla public final int getAndAdd(int delta) &#123; //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。 return unsafe.getAndAddInt(this, valueOffset, delta); &#125; //递增加1 public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125;...&#125; 我们可以看到 AtomicInteger 底层用的是volatile的变量和CAS来进行更改数据的。 volatile保证线程的可见性，多线程并发时，一个线程修改数据，可以保证其它线程立马看到修改后的值 CAS 保证数据更新的原子性。 延伸到所有原子类：共12个 JDK中提供了12个原子操作类。 原子更新基本类型使用原子的方式更新基本类型，Atomic包提供了以下3个类。 AtomicBoolean: 原子更新布尔类型。 AtomicInteger: 原子更新整型。 AtomicLong: 原子更新长整型。 以上3个类提供的方法几乎一模一样，可以参考上面AtomicInteger中的相关方法。 原子更新数组通过原子的方式更新数组里的某个元素，Atomic包提供了以下的3个类： AtomicIntegerArray: 原子更新整型数组里的元素。 AtomicLongArray: 原子更新长整型数组里的元素。 AtomicReferenceArray: 原子更新引用类型数组里的元素。 这三个类的最常用的方法是如下两个方法： get(int index)：获取索引为index的元素值。 compareAndSet(int i,E expect,E update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置为update值。 举个AtomicIntegerArray例子： 12345678910import java.util.concurrent.atomic.AtomicIntegerArray;public class Demo5 &#123; public static void main(String[] args) throws InterruptedException &#123; AtomicIntegerArray array = new AtomicIntegerArray(new int[] &#123; 0, 0 &#125;); System.out.println(array); System.out.println(array.getAndAdd(1, 2)); System.out.println(array); &#125;&#125; 输出结果： 123[0, 0]0[0, 2] 原子更新引用类型Atomic包提供了以下三个类： AtomicReference: 原子更新引用类型。 AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。 AtomicMarkableReferce: 原子更新带有标记位的引用类型。 这三个类提供的方法都差不多，首先构造一个引用对象，然后把引用对象set进Atomic类，然后调用compareAndSet等一些方法去进行原子操作，原理都是基于Unsafe实现，但AtomicReferenceFieldUpdater略有不同，更新的字段必须用volatile修饰。 举个AtomicReference例子： 1234567891011121314151617181920212223242526272829import java.util.concurrent.atomic.AtomicReference;public class AtomicReferenceTest &#123; public static void main(String[] args)&#123; // 创建两个Person对象，它们的id分别是101和102。 Person p1 = new Person(101); Person p2 = new Person(102); // 新建AtomicReference对象，初始化它的值为p1对象 AtomicReference ar = new AtomicReference(p1); // 通过CAS设置ar。如果ar的值为p1的话，则将其设置为p2。 ar.compareAndSet(p1, p2); Person p3 = (Person)ar.get(); System.out.println(&quot;p3 is &quot;+p3); System.out.println(&quot;p3.equals(p1)=&quot;+p3.equals(p1)); &#125;&#125;class Person &#123; volatile long id; public Person(long id) &#123; this.id = id; &#125; public String toString() &#123; return &quot;id:&quot;+id; &#125;&#125; 结果输出： 12p3 is id:102p3.equals(p1)=false 结果说明： 新建AtomicReference对象ar时，将它初始化为p1。 紧接着，通过CAS函数对它进行设置。如果ar的值为p1的话，则将其设置为p2。 最后，获取ar对应的对象，并打印结果。p3.equals(p1)的结果为false，这是因为Person并没有覆盖equals()方法，而是采用继承自Object.java的equals()方法；而Object.java中的equals()实际上是调用”&#x3D;&#x3D;”去比较两个对象，即比较两个对象的地址是否相等。 原子更新字段类Atomic包提供了四个类进行原子字段更新： AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。 AtomicLongFieldUpdater: 原子更新长整型字段的更新器。 AtomicReferenceFieldUpdater: 上面已经说过此处不在赘述。 这四个类的使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步: 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。 第二步，更新类的字段必须使用public volatile修饰。 举个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestAtomicIntegerFieldUpdater &#123; public static void main(String[] args)&#123; TestAtomicIntegerFieldUpdater tIA = new TestAtomicIntegerFieldUpdater(); tIA.doIt(); &#125; public AtomicIntegerFieldUpdater&lt;DataDemo&gt; updater(String name)&#123; return AtomicIntegerFieldUpdater.newUpdater(DataDemo.class,name); &#125; public void doIt()&#123; DataDemo data = new DataDemo(); System.out.println(&quot;publicVar = &quot;+updater(&quot;publicVar&quot;).getAndAdd(data, 2)); /* * 由于在DataDemo类中属性value2/value3,在TestAtomicIntegerFieldUpdater中不能访问 * */ //System.out.println(&quot;protectedVar = &quot;+updater(&quot;protectedVar&quot;).getAndAdd(data,2)); //System.out.println(&quot;privateVar = &quot;+updater(&quot;privateVar&quot;).getAndAdd(data,2)); //System.out.println(&quot;staticVar = &quot;+updater(&quot;staticVar&quot;).getAndIncrement(data));//报java.lang.IllegalArgumentException /* * 下面报异常：must be integer * */ //System.out.println(&quot;integerVar = &quot;+updater(&quot;integerVar&quot;).getAndIncrement(data)); //System.out.println(&quot;longVar = &quot;+updater(&quot;longVar&quot;).getAndIncrement(data)); &#125;&#125;class DataDemo&#123; public volatile int publicVar=3; protected volatile int protectedVar=4; private volatile int privateVar=5; public volatile static int staticVar = 10; //public final int finalVar = 11; public volatile Integer integerVar = 19; public volatile Long longVar = 18L;&#125; 再说下对于AtomicIntegerFieldUpdater 的使用稍微有一些限制和约束，约束如下： 字段必须是volatile类型的，在线程之间共享变量时保证立即可见.eg:volatile int value &#x3D; 3 字段的描述类型(修饰符public&#x2F;protected&#x2F;default&#x2F;private)是与调用者与操作对象字段的关系一致。也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段。 只能是实例变量，不能是类变量，也就是说不能加static关键字。 只能是可修改变量，不能使final变量，因为final的语义就是不可修改。实际上final的语义和volatile是有冲突的，这两个关键字不能同时存在。 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater只能修改int&#x2F;long类型的字段，不能修改其包装类型(Integer&#x2F;Long)。如果要修改包装类型就需要使用AtomicReferenceFieldUpdater。 再讲讲AtomicStampedReference解决CAS的ABA问题AtomicStampedReference解决ABA问题AtomicStampedReference主要维护包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象来解决ABA问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AtomicStampedReference&lt;V&gt; &#123; private static class Pair&lt;T&gt; &#123; final T reference; //维护对象引用 final int stamp; //用于标志版本 private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125; &#125; private volatile Pair&lt;V&gt; pair; .... /** * expectedReference ：更新之前的原始值 * newReference : 将要更新的新值 * expectedStamp : 期待更新的标志版本 * newStamp : 将要更新的标志版本 */ public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; // 获取当前的(元素值，版本号)对 Pair&lt;V&gt; current = pair; return // 引用没变 expectedReference == current.reference &amp;&amp; // 版本号没变 expectedStamp == current.stamp &amp;&amp; // 新引用等于旧引用 ((newReference == current.reference &amp;&amp; // 新版本号等于旧版本号 newStamp == current.stamp) || // 构造新的Pair对象并CAS更新 casPair(current, Pair.of(newReference, newStamp))); &#125; private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123; // 调用Unsafe的compareAndSwapObject()方法CAS更新pair的引用为新引用 return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val); &#125; 如果元素值和版本号都没有变化，并且和新的也相同，返回true； 如果元素值和版本号都没有变化，并且和新的不完全相同，就构造一个新的Pair对象并执行CAS更新pair。 可以看到，java中的实现跟我们上面讲的ABA的解决方法是一致的。 首先，使用版本号控制； 其次，不重复使用节点(Pair)的引用，每次都新建一个新的Pair来作为CAS比较的对象，而不是复用旧的； 最后，外部传入元素值及版本号，而不是节点(Pair)的引用。 使用举例12345678910111213141516171819202122232425262728293031323334public class AtomicTester &#123; private static AtomicStampedReference&lt;Integer&gt; atomicStampedRef = new AtomicStampedReference&lt;&gt;(1, 0); public static void main(String[] args)&#123; first().start(); second().start(); &#125; private static Thread first() &#123; return new Thread(() -&gt; &#123; System.out.println(&quot;操作线程&quot; + Thread.currentThread() +&quot;,初始值 a = &quot; + atomicStampedRef.getReference()); int stamp = atomicStampedRef.getStamp(); //获取当前标识别 try &#123; Thread.sleep(1000); //等待1秒 ，以便让干扰线程执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; boolean isCASSuccess = atomicStampedRef.compareAndSet(1,2,stamp,stamp +1); //此时expectedReference未发生改变，但是stamp已经被修改了,所以CAS失败 System.out.println(&quot;操作线程&quot; + Thread.currentThread() +&quot;,CAS操作结果: &quot; + isCASSuccess); &#125;,&quot;主操作线程&quot;); &#125; private static Thread second() &#123; return new Thread(() -&gt; &#123; Thread.yield(); // 确保thread-first 优先执行 atomicStampedRef.compareAndSet(1,2,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1); System.out.println(&quot;操作线程&quot; + Thread.currentThread() +&quot;,【increment】 ,值 = &quot;+ atomicStampedRef.getReference()); atomicStampedRef.compareAndSet(2,1,atomicStampedRef.getStamp(),atomicStampedRef.getStamp() +1); System.out.println(&quot;操作线程&quot; + Thread.currentThread() +&quot;,【decrement】 ,值 = &quot;+ atomicStampedRef.getReference()); &#125;,&quot;干扰线程&quot;); &#125;&#125; 输出结果： 1234操作线程Thread[主操作线程,5,main],初始值 a = 1操作线程Thread[干扰线程,5,main],【increment】 ,值 = 2操作线程Thread[干扰线程,5,main],【decrement】 ,值 = 1操作线程Thread[主操作线程,5,main],CAS操作结果: false java中还有哪些类可以解决ABA的问题?AtomicMarkableReference，它不是维护一个版本号，而是维护一个boolean类型的标记，标记值有修改，了解一下。 参考文章 https://benjaminwhx.com/2018/05/03/%E3%80%90%E7%BB%86%E8%B0%88Java%E5%B9%B6%E5%8F%91%E3%80%91%E8%B0%88%E8%B0%88CAS/ https://www.jianshu.com/p/9a1e6940987a https://www.jianshu.com/p/a533cbb740c6 https://blog.csdn.net/qq_36236890/article/details/81914871 https://www.cnblogs.com/lodor/p/7492805.html https://blog.csdn.net/u010412719/article/details/52068888 https://www.jianshu.com/p/18dfc5fa0171 https://www.jianshu.com/p/8b227a8adbc1 https://www.jianshu.com/p/77f75b398be9 https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"8.JUC - 类汇总和学习指南","path":"/2023/12/25/8-JUC-类汇总和学习指南/","content":"提示 本文对J.U.C进行知识体系解读，后续的文章还针对几乎所有的核心的类以及常用的工具类作了详细的解读; 如果没有时间详细阅读相关章节，可以跟着本文站在一定的高度了解JUC下包的设计和实现；同时对重要的章节提供跳转链接，您可以链接过去详读。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解相关知识点。 JUC框架包含几个部分? 每个部分有哪些核心的类? 最最核心的类有哪些? Overview阅读前，推荐你学习下并发相关基础 Java 并发 - 理论基础 Java 并发 - 线程基础 关键字: synchronized详解 关键字: volatile详解 关键字: final详解 正式学习时先了解五个部分： 主要包含: (注意: 上图是网上找的图，无法表述一些继承关系，同时少了部分类；但是主体上可以看出其分类关系也够了) Lock框架和Tools类(把图中这两个放到一起理解) Collections: 并发集合 Atomic: 原子类 Executors: 线程池 Lock框架和Tools类类结构总览 接口: Condition Condition为接口类型，它将 Object 监视器方法(wait、notify 和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中，Lock 替代了 synchronized 方法和语句的使用，Condition 替代了 Object 监视器方法的使用。可以通过await(),signal()来休眠&#x2F;唤醒线程。 在JUC锁: AbstractQueuedSynchronizer详解中类的内部类-conditionobject类有具体分析。 接口: Lock Lock为接口类型，Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。 接口: ReadWriteLock ReadWriteLock为接口类型， 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。 抽象类: AbstractOwnableSynchonizer AbstractOwnableSynchonizer为抽象类，可以由线程以独占方式拥有的同步器。此类为创建锁和相关同步器(伴随着所有权的概念)提供了基础。AbstractOwnableSynchronizer 类本身不管理或使用此信息。但是，子类和工具可以使用适当维护的值帮助控制和监视访问以及提供诊断。 抽象类(long): AbstractQueuedLongSynchronizer AbstractQueuedLongSynchronizer为抽象类，以 long 形式维护同步状态的一个 AbstractQueuedSynchronizer 版本。此类具有的结构、属性和方法与 AbstractQueuedSynchronizer 完全相同，但所有与状态相关的参数和结果都定义为 long 而不是 int。当创建需要 64 位状态的多级别锁和屏障等同步器时，此类很有用。 核心抽象类(int): AbstractQueuedSynchronizer AbstractQueuedSynchronizer为抽象类，其为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁和相关同步器(信号量、事件，等等)提供一个框架。此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。 详细分析请看: JUC锁: AbstractQueuedSynchronizer详解 锁常用类: LockSupport LockSupport为常用类，用来创建锁和其他同步类的基本线程阻塞原语。LockSupport的功能和”Thread中的 Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 详细分析请看: JUC锁: LockSupport详解 锁常用类: ReentrantLock ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。 详细分析请看: JUC锁: ReentrantLock详解 锁常用类: ReentrantReadWriteLock ReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括Lock子类ReadLock和WriteLock。ReadLock是共享锁，WriteLock是独占锁。 详细分析请看: JUC工具类: ReentrantReadWriteLock详解 锁常用类: StampedLock 它是java8在java.util.concurrent.locks新增的一个API。StampedLock控制锁有三种模式(写，读，乐观读)，一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。 详细分析请看: Java 8 - StampedLock详解 工具常用类: CountDownLatch CountDownLatch为常用类，它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 详细分析请看: JUC工具类: CountDownLatch详解 工具常用类: CyclicBarrier CyclicBarrier为常用类，其是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 详细分析请看: JUC工具类: CyclicBarrier详解 工具常用类: Phaser Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。 详细分析请看: JUC工具类: Phaser详解 工具常用类: Semaphore Semaphore为常用类，其是一个计数信号量，从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。通常用于限制可以访问某些资源(物理或逻辑的)的线程数目。 详细分析请看: JUC工具类: Semaphore详解 工具常用类: Exchanger Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange()方法交换数据，当一个线程先执行exchange()方法后，它会一直等待第二个线程也执行exchange()方法，当这两个线程到达同步点时，这两个线程就可以交换数据了。 详细分析请看: JUC工具类: Exchanger详解 Collections: 并发集合类结构关系 Queue: ArrayBlockingQueue 一个由数组支持的有界阻塞队列。此队列按 FIFO(先进先出)原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 详细分析请看: JUC并发集合: BlockingQueue详解 Queue: LinkedBlockingQueue 一个基于已链接节点的、范围任意的 blocking queue。此队列按 FIFO(先进先出)排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列获取操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低。 详细分析请看: JUC并发集合: BlockingQueue详解 Queue: LinkedBlockingDeque 一个基于已链接节点的、任选范围的阻塞双端队列。 详细分析请看: JUC并发集合: BlockingQueue详解 Queue: ConcurrentLinkedQueue 一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。 详细分析请看: JUC并发集合: ConcurrentLinkedQueue详解 Queue: ConcurrentLinkedDeque 是双向链表实现的无界队列，该队列同时支持FIFO和FILO两种操作方式。 Queue: DelayQueue 延时无界阻塞队列，使用Lock机制实现并发访问。队列里只允许放可以“延期”的元素，队列中的head是最先“到期”的元素。如果队里中没有元素到“到期”，那么就算队列中有元素也不能获取到。 Queue: PriorityBlockingQueue 无界优先级阻塞队列，使用Lock机制实现并发访问。priorityQueue的线程安全版，不允许存放null值，依赖于comparable的排序，不允许存放不可比较的对象类型。 Queue: SynchronousQueue 没有容量的同步队列，通过CAS实现并发访问，支持FIFO和FILO。 Queue: LinkedTransferQueue JDK 7新增，单向链表实现的无界阻塞队列，通过CAS实现并发访问，队列元素使用 FIFO(先进先出)方式。LinkedTransferQueue可以说是ConcurrentLinkedQueue、SynchronousQueue(公平模式)和LinkedBlockingQueue的超集, 它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。 List: CopyOnWriteArrayList ArrayList 的一个线程安全的变体，其中所有可变操作(add、set 等等)都是通过对底层数组进行一次新的复制来实现的。这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时，它也很有用。 详细分析请看: JUC并发集合: CopyOnWriteArrayList详解 Set: CopyOnWriteArraySet 对其所有操作使用内部CopyOnWriteArrayList的Set。即将所有操作转发至CopyOnWriteArayList来进行操作，能够保证线程安全。在add时，会调用addIfAbsent，由于每次add时都要进行数组遍历，因此性能会略低于CopyOnWriteArrayList。 Set: ConcurrentSkipListSet 一个基于ConcurrentSkipListMap 的可缩放并发 NavigableSet 实现。set 的元素可以根据它们的自然顺序进行排序，也可以根据创建 set 时所提供的 Comparator 进行排序，具体取决于使用的构造方法。 Map: ConcurrentHashMap 是线程安全HashMap的。ConcurrentHashMap在JDK 7之前是通过Lock和segment(分段锁)实现，JDK 8 之后改为CAS+synchronized来保证并发安全。 详细分析请看: JUC并发集合: ConcurrentHashMap详解, 包含了对JDK 7和JDK 8版本的源码分析。 Map: ConcurrentSkipListMap 线程安全的有序的哈希表(相当于线程安全的TreeMap);映射可以根据键的自然顺序进行排序，也可以根据创建映射时所提供的 Comparator 进行排序，具体取决于使用的构造方法。 Atomic: 原子类其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。 对CAS，Unsafe类，以及13个原子类详解请参考：详细分析请看: JUC原子类: CAS, Unsafe和原子类详解 基础类型：AtomicBoolean，AtomicInteger，AtomicLong AtomicBoolean，AtomicInteger，AtomicLong是类似的，分别针对bool，interger，long的原子类。 数组：AtomicIntegerArray，AtomicLongArray，BooleanArray AtomicIntegerArray，AtomicLongArray，AtomicBooleanArray是数组原子类。 引用：AtomicReference，AtomicMarkedReference，AtomicStampedReference AtomicReference，AtomicMarkedReference，AtomicStampedReference是引用相关的原子类。 FieldUpdater：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater是FieldUpdater原子类。 Executors: 线程池类结构关系 接口: Executor Executor接口提供一种将任务提交与每个任务将如何运行的机制(包括线程使用的细节、调度等)分离开来的方法。通常使用 Executor 而不是显式地创建线程。 ExecutorService ExecutorService继承自Executor接口，ExecutorService提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。 可以关闭 ExecutorService，这将导致其停止接受新任务。关闭后，执行程序将最后终止，这时没有任务在执行，也没有任务在等待执行，并且无法提交新任务。 ScheduledExecutorService ScheduledExecutorService继承自ExecutorService接口，可安排在给定的延迟后运行或定期执行的命令。 AbstractExecutorService AbstractExecutorService继承自ExecutorService接口，其提供 ExecutorService 执行方法的默认实现。此类使用 newTaskFor 返回的 RunnableFuture 实现 submit、invokeAny 和 invokeAll 方法，默认情况下，RunnableFuture 是此包中提供的 FutureTask 类。 FutureTask FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。 详细分析请看: JUC线程池: FutureTask详解 核心: ThreadPoolExecutor ThreadPoolExecutor实现了AbstractExecutorService接口，也是一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。 线程池可以解决两个不同问题: 由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源(包括执行任务集时使用的线程)的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 详细分析请看: JUC线程池: ThreadPoolExecutor详解 核心: ScheduledThreadExecutor ScheduledThreadPoolExecutor实现ScheduledExecutorService接口，可安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 详细分析请看: JUC线程池: ScheduledThreadExecutor详解 核心: Fork&#x2F;Join框架 ForkJoinPool 是JDK 7加入的一个线程池类。Fork&#x2F;Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。 详细分析请看: JUC线程池: Fork&#x2F;Join框架详解 工具类: Executors Executors是一个工具类，用其可以创建ExecutorService、ScheduledExecutorService、ThreadFactory、Callable等对象。它的使用融入到了ThreadPoolExecutor, ScheduledThreadExecutor和ForkJoinPool中。 参考文章 https://www.cnblogs.com/leesf456/p/5344133.html https://www.cnblogs.com/leesf456/p/5428630.html https://www.cnblogs.com/leesf456/p/5550043.html https://www.jianshu.com/p/8cb5d816cb69 泰迪的bagwell https://www.jianshu.com/p/af9c0f404a93","tags":["Java","多线程与并发","JUC"],"categories":["Java","多线程与并发","JUC"]},{"title":"7.关键字: final详解","path":"/2023/12/25/7-关键字-final详解/","content":"final 关键字看上去简单，但是真正深入理解的人可以说少之又少，读完本文你就知道我在说什么了。本文将常规的用法简化，提出一些用法和深入的思考。 带着BAT大厂的面试问题去理解final 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解final。 所有的final修饰的字段都是编译期常量吗? 如何理解private所修饰的方法是隐式的final? 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? final方法可以被重载吗? 可以 父类的final方法能不能够被子类重写? 不可以 说说final域重排序规则? 说说final的原理? 使用 final 的限制条件和局限性? 看本文最后的一个思考题 final基础使用修饰类当某个类的整体定义为final时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。 注意：final类中的所有方法都隐式为final，因为无法覆盖他们，所以在final类中给任何方法添加final关键字是没有任何意义的。 这里顺道说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? @pdai 设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合, 如下代码大概写个组合实现的意思： 12345678910111213141516171819/*** @pdai*/class MyString&#123; private String innerString; // ...init &amp; other methods // 支持老的方法 public int length()&#123; return innerString.length(); // 通过innerString调用老的方法 &#125; // 添加新方法 public String toMyString()&#123; //... &#125;&#125; 修饰方法 常规的使用就不说了，这里说下: private 方法是隐式的final final方法是可以被重载的 private final类中所有private方法都隐式地指定为final的，由于无法取用private方法，所以也就不能覆盖它。可以对private方法增添final关键字，但这样做并没有什么好处。看下下面的例子： 1234567891011121314public class Base &#123; private void test() &#123; &#125;&#125;public class Son extends Base&#123; public void test() &#123; &#125; public static void main(String[] args) &#123; Son son = new Son(); Base father = son; //father.test(); &#125;&#125; Base和Son都有方法test(),但是这并不是一种覆盖，因为private所修饰的方法是隐式的final，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是father.test()是不可执行的，因为Base中的test方法是private的，无法被访问到。 final方法是可以被重载的我们知道父类的final方法是不能够被子类重写的，那么final方法可以被重载吗? 答案是可以的，下面代码是正确的。 1234567public class FinalExampleParent &#123; public final void test() &#123; &#125; public final void test(String str) &#123; &#125;&#125; 修饰参数Java允许在参数列表中以声明的方式将参数指明为final，这意味这你无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。 修饰变量 常规的用法比较简单，这里通过下面三个问题进一步说明。 所有的final修饰的字段都是编译期常量吗?现在来看编译期常量和非编译期常量, 如： 12345678910111213public class Test &#123; //编译期常量 final int i = 1; final static int J = 1; final int[] a = &#123;1,2,3,4&#125;; //非编译期常量 Random r = new Random(); final int k = r.nextInt(); public static void main(String[] args) &#123; &#125;&#125; k的值由随机数对象决定，所以不是所有的final修饰的字段都是编译期常量，只是k的值在被初始化后无法被更改。 static final一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。 123456789101112import java.util.Random;public class Test &#123; static Random r = new Random(); final int k = r.nextInt(10); static final int k2 = r.nextInt(10); public static void main(String[] args) &#123; Test t1 = new Test(); System.out.println(&quot;k=&quot;+t1.k+&quot; k2=&quot;+t1.k2); Test t2 = new Test(); System.out.println(&quot;k=&quot;+t2.k+&quot; k2=&quot;+t2.k2); &#125;&#125; 上面代码某次输出结果： 12k=2 k2=7k=8 k2=7 我们可以发现对于不同的对象k的值是不同的，但是k2的值却是相同的，这是为什么呢? 因为static关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为static final所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。 blank finalJava允许生成空白final，也就是说被声明为final但又没有给出定值的字段,但是必须在该字段被使用之前被赋值，这给予我们两种选择： 在定义处进行赋值(这不叫空白final) 在构造器中进行赋值，保证了该值在被使用前赋值。 这增强了final的灵活性。 看下面代码: 12345678910public class Test &#123; final int i1 = 1; final int i2;//空白final public Test() &#123; i2 = 1; &#125; public Test(int x) &#123; this.i2 = x; &#125;&#125; 可以看到i2的赋值更为灵活。但是请注意，如果字段由static和final修饰，仅能在声明时赋值或声明后在静态代码块中赋值，因为该字段不属于对象，属于这个类。 final域重排序规则上面我们聊的final使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗? 有考虑过final在多线程并发的情况吗? 在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下,final会进行怎样的重排序? 会导致线程安全的问题吗? 下面，就来看看final的重排序。 final域为基本类型先看一段示例性的代码： 1234567891011121314151617181920public class FinalDemo &#123; private int a; //普通域 private final int b; //final域 private static FinalDemo finalDemo; public FinalDemo() &#123; a = 1; // 1. 写普通域 b = 2; // 2. 写final域 &#125; public static void writer() &#123; finalDemo = new FinalDemo(); &#125; public static void reader() &#123; FinalDemo demo = finalDemo; // 3.读对象引用 int a = demo.a; //4.读普通域 int b = demo.b; //5.读final域 &#125;&#125; 假设线程A在执行writer()方法，线程B执行reader()方法。 写final域重排序规则写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面： JMM禁止编译器把final域的写重排序到构造函数之外； 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。 我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情： 构造了一个FinalDemo对象； 把这个对象赋值给成员变量finalDemo。 我们来画下存在的一种可能执行时序图，如下： 由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。 因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。 读final域重排序规则读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。 read()方法主要包含了三个操作： 初次读引用变量finalDemo; 初次读引用变量finalDemo的普通域a; 初次读引用变量finalDemo的final域b; 假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图： 读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。 读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。 final域为引用类型我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了? 如果是引用数据类型了? 我们接着继续来探讨。 对final修饰的对象的成员域写操作针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。 1234567891011121314151617181920212223public class FinalReferenceDemo &#123; final int[] arrays; private FinalReferenceDemo finalReferenceDemo; public FinalReferenceDemo() &#123; arrays = new int[1]; //1 arrays[0] = 1; //2 &#125; public void writerOne() &#123; finalReferenceDemo = new FinalReferenceDemo(); //3 &#125; public void writerTwo() &#123; arrays[0] = 2; //4 &#125; public void reader() &#123; if (finalReferenceDemo != null) &#123; //5 int temp = finalReferenceDemo.arrays[0]; //6 &#125; &#125;&#125; 针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论(耐心看完才有收获)。 由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。 对final修饰的对象的成员域读操作JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。 关于final重排序的总结按照final修饰的数据类型分类： 基本数据类型: final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。 final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。 引用数据类型： 额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序 final再深入理解final的实现原理上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。 很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读&#x2F;写的内存屏障都会被省略！具体是否插入还是得看是什么处理器 为什么final引用不能从构造函数中“溢出”这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“溢出”。以下面的例子来说： 12345678910111213141516171819public class FinalReferenceEscapeDemo &#123; private final int a; private FinalReferenceEscapeDemo referenceDemo; public FinalReferenceEscapeDemo() &#123; a = 1; //1 referenceDemo = this; //2 &#125; public void writer() &#123; new FinalReferenceEscapeDemo(); &#125; public void reader() &#123; if (referenceDemo != null) &#123; //3 int temp = referenceDemo.a; //4 &#125; &#125;&#125; 可能的执行时序如图所示： 假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。 使用 final 的限制条件和局限性当声明一个 final 成员时，必须在构造函数退出前设置它的值。 123456public class MyClass &#123; private final int myField = 1; public MyClass() &#123; ... &#125;&#125; 或者 12345678public class MyClass &#123; private final int myField; public MyClass() &#123; ... myField = 1; ... &#125;&#125; 将指向对象的成员声明为 final 只能将该引用设为不可变的，而非所指的对象。 下面的方法仍然可以修改该 list。 12private final List myList = new ArrayList();myList.add(&quot;Hello&quot;); 声明为 final 可以保证如下操作不合法 12myList = new ArrayList();myList = someOtherList; 如果一个对象将会在多个线程中访问并且你并没有将其成员声明为 final，则必须提供其他方式保证线程安全。 “ 其他方式 “ 可以包括声明成员为 volatile，使用 synchronized 或者显式 Lock 控制所有该成员的访问。 再思考一个有趣的现象：123byte b1=1;byte b2=3;byte b3=b1+b2;//当程序执行到这一行的时候会出错，因为b1、b2可以自动转换成int类型的变量，运算时java虚拟机对它进行了转换，结果导致把一个int赋值给byte-----出错 如果对b1 b2加上final就不会出错 123final byte b1=1;final byte b2=3;byte b3=b1+b2;//不会出错，相信你看了上面的解释就知道原因了。 参考文章 https://www.jianshu.com/p/1e82c75034b7 《java并发编程的艺术》 《疯狂java讲义》","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"6.关键字: volatile详解","path":"/2023/12/25/6-关键字-volatile详解/","content":"相比Sychronized(重量级锁，对系统性能影响较大)，volatile提供了另一种解决可见性和有序性问题的方案。 带着BAT大厂的面试问题去理解volatile 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解volatile。 volatile关键字的作用是什么? volatile能保证原子性吗? 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢? i++为什么不能保证原子性? volatile是如何实现可见性的? 内存屏障。 volatile是如何实现有序性的? happens-before等 说下volatile的应用场景? volatile的作用详解防重排序我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用双重检查加锁(DCL)的方式来实现。其源码如下： 1234567891011121314151617public class Singleton &#123; public static volatile Singleton singleton; /** * 构造函数私有，禁止外部实例化 */ private Singleton() &#123;&#125;; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 现在我们分析一下为什么要在变量singleton之间加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤： 分配内存空间。 初始化对象。 将内存空间的地址赋值给对应的引用。 但是由于操作系统可以对指令进行重排序，所以上面的过程也可能会变成如下过程： 分配内存空间。 将内存空间的地址赋值给对应的引用。 初始化对象 如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为volatile类型的变量。 实现可见性可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile关键字能有效的解决这个问题，我们看下下面的例子，就可以知道其作用： 123456789101112131415161718192021222324public class TestVolatile &#123; private static boolean stop = false; public static void main(String[] args) &#123; // Thread-A new Thread(&quot;Thread A&quot;) &#123; @Override public void run() &#123; while (!stop) &#123; &#125; System.out.println(Thread.currentThread() + &quot; stopped&quot;); &#125; &#125;.start(); // Thread-main try &#123; TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread() + &quot; after 1 seconds&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; stop = true; &#125;&#125; 执行输出如下 123Thread[main,5,main] after 1 seconds// Thread A一直在loop, 因为Thread A 由于可见性原因看不到Thread Main 已经修改stop的值 可以看到 Thread-main 休眠1秒之后，设置 stop &#x3D; ture，但是Thread A根本没停下来，这就是可见性问题。如果通过在stop变量前面加上volatile关键字则会真正stop: 1234Thread[main,5,main] after 1 secondsThread[Thread A,5,main] stoppedProcess finished with exit code 0 保证原子性:单次读&#x2F;写volatile不能保证完全的原子性，只能保证单次的读&#x2F;写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）： 问题1： i++为什么不能保证原子性?对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读&#x2F;写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。 现在我们就通过下列程序来演示一下这个问题： 1234567891011121314151617181920212223242526public class VolatileTest01 &#123; volatile int i; public void addI()&#123; i++; &#125; public static void main(String[] args) throws InterruptedException &#123; final VolatileTest01 test01 = new VolatileTest01(); for (int n = 0; n &lt; 1000; n++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test01.addI(); &#125; &#125;).start(); &#125; Thread.sleep(10000);//等待10秒，保证上面程序执行完成 System.out.println(test01.i); &#125;&#125; 大家可能会误认为对变量i加上关键字volatile后，这段程序就是线程安全的。大家可以尝试运行上面的程序。下面是我本地运行的结果：981 可能每个人运行的结果不相同。不过应该能看出，volatile是无法保证原子性的(否则结果应该是1000)。原因也很简单，i++其实是一个复合操作，包括三步骤： 读取i的值。 对i加1。 将i的值写回内存。 volatile是无法保证这三个操作是具有原子性的，我们可以通过AtomicInteger或者Synchronized来保证+1操作的原子性。 注：上面几段代码中多处执行了Thread.sleep()方法，目的是为了增加并发问题的产生几率，无其他作用。 问题2： 共享的long和double变量的为什么要用volatile?因为long和double两种数据类型的操作可分为高32位和低32位两部分，因此普通的long或double类型读&#x2F;写可能不是原子的。因此，鼓励大家将共享的long和double变量设置为volatile类型，这样能保证任何情况下对long和double的单次读&#x2F;写操作都具有原子性。 如下是JLS中的解释： 17.7 Non-Atomic Treatment of double and long For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32-bit or 64-bit values. Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32-bit values. For efficiency’s sake, this behavior is implementation-specific; an implementation of the Java Virtual Machine is free to perform writes to long and double values atomically or in two parts. Implementations of the Java Virtual Machine are encouraged to avoid splitting 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications. 目前各种平台下的商用虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把long 和 double 变量专门声明为 volatile多数情况下也是不会错的。 volatile 的实现原理volatile 可见性实现 volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现: 内存屏障，又称内存栅栏，是一个 CPU 指令。 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。 写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。 12345678910public class Test &#123; private volatile int a; public void update() &#123; a = 1; &#125; public static void main(String[] args) &#123; Test test = new Test(); test.update(); &#125;&#125; 通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码: 123456789101112131415161718...... 0x0000000002951563: and $0xffffffffffffff87,%rdi 0x0000000002951567: je 0x00000000029515f8 0x000000000295156d: test $0x7,%rdi 0x0000000002951574: jne 0x00000000029515bd 0x0000000002951576: test $0x300,%rdi 0x000000000295157d: jne 0x000000000295159c 0x000000000295157f: and $0x37f,%rax 0x0000000002951586: mov %rax,%rdi 0x0000000002951589: or %r15,%rdi 0x000000000295158c: lock cmpxchg %rdi,(%rdx) //在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令 0x0000000002951591: jne 0x0000000002951a15 0x0000000002951597: jmpq 0x00000000029515f8 0x000000000295159c: mov 0x8(%rdx),%edi 0x000000000295159f: shl $0x3,%rdi 0x00000000029515a3: mov 0xa8(%rdi),%rdi 0x00000000029515aa: or %r15,%rdi...... lock 前缀的指令在多核处理器下会引发两件事情: 将当前处理器缓存行的数据写回到系统内存。 写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。 为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存(L1，L2 或其他)后再进行操作，但操作完不知道何时会写到内存。 如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条 lock 前缀的指令，将这个变量所在缓存行的数据写回到系统内存。 为了保证各个处理器的缓存是一致的，实现了缓存一致性协议(MESI)，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。 volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。 lock 指令在 Pentium 和早期的 IA-32 处理器中，lock 前缀会使处理器执行当前指令时产生一个 LOCK# 信号，会对总线进行锁定，其它 CPU 对内存的读写请求都会被阻塞，直到锁释放。 后来的处理器，加锁操作是由高速缓存锁代替总线锁来处理。 因为锁总线的开销比较大，锁总线期间其他 CPU 没法访问内存。 这种场景多缓存的数据一致通过缓存一致性协议(MESI)来保证。 缓存一致性缓存是分段(line)的，一个段对应一块存储空间，称之为缓存行，它是 CPU 缓存中可分配的最小存储单元，大小 32 字节、64 字节、128 字节不等，这与 CPU 架构有关，通常来说是 64 字节。 LOCK# 因为锁总线效率太低，因此使用了多组缓存。 为了使其行为看起来如同一组缓存那样。因而设计了 缓存一致性协议。 缓存一致性协议有多种，但是日常处理的大多数计算机设备都属于 “ 嗅探(snooping)” 协议。 所有内存的传输都发生在一条共享的总线上，而所有的处理器都能看到这条总线。 缓存本身是独立的，但是内存是共享资源，所有的内存访问都要经过仲裁(同一个指令周期中，只有一个 CPU 缓存可以读写内存)。 CPU 缓存不仅仅在做内存传输的时候才与总线打交道，而是不停在嗅探总线上发生的数据交换，跟踪其他缓存在做什么。 当一个缓存代表它所属的处理器去读写内存时，其它处理器都会得到通知，它们以此来使自己的缓存保持同步。 只要某个处理器写内存，其它处理器马上知道这块内存在它们的缓存段中已经失效。 volatile 有序性实现volatile 的 happens-before 关系happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。 1234567891011121314151617//假设线程A执行writer方法，线程B执行reader方法class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; // 1 线程A修改共享变量 flag = true; // 2 线程A写volatile变量 &#125; public void reader() &#123; if (flag) &#123; // 3 线程B读同一个volatile变量 int i = a; // 4 线程B读共享变量 …… &#125; &#125;&#125; 根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。 根据程序次序规则：1 happens-before 2 且 3 happens-before 4。 根据 volatile 规则：2 happens-before 3。 根据 happens-before 的传递性规则：1 happens-before 4。 因为以上规则，当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。 volatile 禁止重排序为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了内存屏障阻止这种重排序。 Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。 JMM 会针对编译器制定 volatile 重排序规则表。 “ NO “ 表示禁止重排序。 为了实现 volatile 内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。 对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障。 内存屏障 说明 StoreStore 屏障 禁止上面的普通写和下面的 volatile 写重排序。 StoreLoad 屏障 防止上面的 volatile 写与下面可能有的 volatile 读&#x2F;写重排序。 LoadLoad 屏障 禁止下面所有的普通读操作和上面的 volatile 读重排序。 LoadStore 屏障 禁止下面所有的普通写操作和上面的 volatile 读重排序。 volatile 的应用场景使用 volatile 必须具备的条件 对变量的写操作不依赖于当前值。 该变量没有包含在具有其他变量的不变式中。 只有在状态真正独立于程序内其他内容时才能使用 volatile。 模式1：状态标志也许实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。 12345678volatile boolean shutdownRequested;......public void shutdown() &#123; shutdownRequested = true; &#125;public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 模式2：一次性安全发布(one-time safe publication)缺乏同步会导致无法实现可见性，这使得确定何时写入对象引用而不是原始值变得更加困难。在缺乏同步的情况下，可能会遇到某个对象引用的更新值(由另一个线程写入)和该对象状态的旧值同时存在。(这就是造成著名的双重检查锁定(double-checked-locking)问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象)。 12345678910111213141516171819public class BackgroundFloobleLoader &#123; public volatile Flooble theFlooble; public void initInBackground() &#123; // do lots of stuff theFlooble = new Flooble(); // this is the only write to theFlooble &#125;&#125; public class SomeOtherClass &#123; public void doWork() &#123; while (true) &#123; // do some stuff... // use the Flooble, but only if it is ready if (floobleLoader.theFlooble != null) doSomething(floobleLoader.theFlooble); &#125; &#125;&#125; 模式3：独立观察(independent observation)安全使用 volatile 的另一种简单模式是定期 发布 观察结果供程序内部使用。例如，假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。 12345678910111213public class UserManager &#123; public volatile String lastUser; public boolean authenticate(String user, String password) &#123; boolean valid = passwordIsValid(user, password); if (valid) &#123; User u = new User(); activeUsers.add(u); lastUser = user; &#125; return valid; &#125;&#125; 模式4：volatile bean 模式在 volatile bean 模式中，JavaBean 的所有数据成员都是 volatile 类型的，并且 getter 和 setter 方法必须非常普通 —— 除了获取或设置相应的属性外，不能包含任何逻辑。此外，对于对象引用的数据成员，引用的对象必须是有效不可变的。(这将禁止具有数组值的属性，因为当数组引用被声明为 volatile 时，只有引用而不是数组本身具有 volatile 语义)。对于任何 volatile 变量，不变式或约束都不能包含 JavaBean 属性。 12345678910111213141516171819202122@ThreadSafepublic class Person &#123; private volatile String firstName; private volatile String lastName; private volatile int age; public String getFirstName() &#123; return firstName; &#125; public String getLastName() &#123; return lastName; &#125; public int getAge() &#123; return age; &#125; public void setFirstName(String firstName) &#123; this.firstName = firstName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 模式5：开销较低的读－写锁策略volatile 的功能还不足以实现计数器。因为 ++x 实际上是三种操作(读、添加、存储)的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。 如果读操作远远超过写操作，可以结合使用内部锁和 volatile 变量来减少公共代码路径的开销。 安全的计数器使用 synchronized 确保增量操作是原子的，并使用 volatile 保证当前结果的可见性。如果更新不频繁的话，该方法可实现更好的性能，因为读路径的开销仅仅涉及 volatile 读操作，这通常要优于一个无竞争的锁获取的开销。 123456789101112@ThreadSafepublic class CheesyCounter &#123; // Employs the cheap read-write lock trick // All mutative operations MUST be done with the &#x27;this&#x27; lock held @GuardedBy(&quot;this&quot;) private volatile int value; public int getValue() &#123; return value; &#125; public synchronized int increment() &#123; return value++; &#125;&#125; 模式6：双重检查(double-checked)就是我们上文举的例子。 单例模式的一种实现方式，但很多人会忽略 volatile 关键字，因为没有该关键字，程序也可以很好的运行，只不过代码的稳定性总不是 100%，说不定在未来的某个时刻，隐藏的 bug 就出来了。 123456789101112131415class Singleton &#123; private volatile static Singleton instance; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if (instance == null) &#123; syschronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; &#125; 参考文章 https://blog.csdn.net/devotion987/article/details/68486942 https://www.jianshu.com/p/ccfe24b63d87","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"5.关键字: synchronized详解","path":"/2023/12/25/5-关键字-synchronized详解/","content":"在C程序代码中我们可以利用操作系统提供的互斥锁来实现同步块的互斥访问及线程的阻塞及唤醒等工作。在Java中除了提供Lock API外还在语法层面上提供了synchronized关键字来实现互斥同步原语, 本文将对synchronized关键字详细分析。 带着BAT大厂的面试问题去理解Synchronized 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解synchronized。 Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。 Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。 Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的。 Synchronized和Lock的对比，和选择? Synchronized在使用时有何注意事项? Synchronized修饰的方法在抛出异常时,会释放锁吗? 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程? Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法? 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办? 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁? 不同的JDK中对Synchronized有何优化? Synchronized的使用在应用Sychronized关键字时需要把握如下注意点： 一把锁只能同时被一个线程获取，没有获得锁的线程只能等待； 每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁 synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁 对象锁包括方法锁(默认锁对象为this,当前实例对象)和同步代码块锁(自己指定锁对象) 代码块形式：手动指定锁定对象，也可是是this,也可以是自定义的锁 示例1 123456789101112131415161718192021222324public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance = new SynchronizedObjectLock(); @Override public void run() &#123; // 同步代码块形式——锁为this,两个线程使用的锁是一样的,线程1必须要等到线程0释放了该锁后，才能执行 synchronized (this) &#123; System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); &#125;&#125; 输出结果： 1234我是线程Thread-0Thread-0结束我是线程Thread-1Thread-1结束 示例2 12345678910111213141516171819202122232425262728293031323334353637public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance = new SynchronizedObjectLock(); // 创建2把锁 Object block1 = new Object(); Object block2 = new Object(); @Override public void run() &#123; // 这个代码块使用的是第一把锁，当他释放后，后面的代码块由于使用的是第二把锁，因此可以马上执行 synchronized (block1) &#123; System.out.println(&quot;block1锁,我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;block1锁,&quot;+Thread.currentThread().getName() + &quot;结束&quot;); &#125; synchronized (block2) &#123; System.out.println(&quot;block2锁,我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;block2锁,&quot;+Thread.currentThread().getName() + &quot;结束&quot;); &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); &#125;&#125; 输出结果： 12345678block1锁,我是线程Thread-0block1锁,Thread-0结束block2锁,我是线程Thread-0 // 可以看到当第一个线程在执行完第一段同步代码块之后，第二个同步代码块可以马上得到执行，因为他们使用的锁不是同一把block1锁,我是线程Thread-1block2锁,Thread-0结束block1锁,Thread-1结束block2锁,我是线程Thread-1block2锁,Thread-1结束 方法锁形式：synchronized修饰普通方法，锁对象默认为this12345678910111213141516171819202122232425public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance = new SynchronizedObjectLock(); @Override public void run() &#123; method(); &#125; public synchronized void method() &#123; System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance); Thread t2 = new Thread(instance); t1.start(); t2.start(); &#125;&#125; 输出结果： 1234我是线程Thread-0Thread-0结束我是线程Thread-1Thread-1结束 类锁指synchronize修饰静态的方法或指定锁对象为Class对象 synchronize修饰静态方法 示例1 12345678910111213141516171819202122232425262728public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance1 = new SynchronizedObjectLock(); static SynchronizedObjectLock instance2 = new SynchronizedObjectLock(); @Override public void run() &#123; method(); &#125; // synchronized用在普通方法上，默认的锁就是this，当前实例 public synchronized void method() &#123; System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125; public static void main(String[] args) &#123; // t1和t2对应的this是两个不同的实例，所以代码不会串行 Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); &#125;&#125; 输出结果： 1234我是线程Thread-0我是线程Thread-1Thread-1结束Thread-0结束 示例2 123456789101112131415161718192021222324252627public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance1 = new SynchronizedObjectLock(); static SynchronizedObjectLock instance2 = new SynchronizedObjectLock(); @Override public void run() &#123; method(); &#125; // synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把 public static synchronized void method() &#123; System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); &#125;&#125; 输出结果： 1234我是线程Thread-0Thread-0结束我是线程Thread-1Thread-1结束 synchronized指定锁对象为Class对象12345678910111213141516171819202122232425public class SynchronizedObjectLock implements Runnable &#123; static SynchronizedObjectLock instance1 = new SynchronizedObjectLock(); static SynchronizedObjectLock instance2 = new SynchronizedObjectLock(); @Override public void run() &#123; // 所有线程需要的锁都是同一把 synchronized(SynchronizedObjectLock.class)&#123; System.out.println(&quot;我是线程&quot; + Thread.currentThread().getName()); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;结束&quot;); &#125; &#125; public static void main(String[] args) &#123; Thread t1 = new Thread(instance1); Thread t2 = new Thread(instance2); t1.start(); t2.start(); &#125;&#125; 输出结果： 1234我是线程Thread-0Thread-0结束我是线程Thread-1Thread-1结束 Synchronized原理分析加锁和释放锁的原理 现象、时机(内置锁this)、深入JVM看字节码(反编译看monitor指令) 深入JVM看字节码，创建如下的代码： 1234567891011121314public class SynchronizedDemo2 &#123; Object object = new Object(); public void method1() &#123; synchronized (object) &#123; &#125; method2(); &#125; private static void method2() &#123; &#125;&#125; 使用javac命令进行编译生成.class文件 1&gt;javac SynchronizedDemo2.java 使用javap命令反编译查看.class文件的信息 1&gt;javap -verbose SynchronizedDemo2.class 得到如下的信息： 关注红色方框里的monitorenter和monitorexit即可。 Monitorenter和Monitorexit指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一： monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 这把锁已经被别的线程获取了，等待锁释放 monitorexit指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。 下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系： 该图可以看出，任意线程对Object的访问，首先要获得Object的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当Object的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。 可重入原理：加锁次数计数器 什么是可重入？可重入锁？ 可重入：（来源于维基百科）若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。 可重入锁：又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。 看如下的例子 123456789101112131415161718192021public class SynchronizedDemo &#123; public static void main(String[] args) &#123; SynchronizedDemo demo = new SynchronizedDemo(); demo.method1(); &#125; private synchronized void method1() &#123; System.out.println(Thread.currentThread().getId() + &quot;: method1()&quot;); method2(); &#125; private synchronized void method2() &#123; System.out.println(Thread.currentThread().getId()+ &quot;: method2()&quot;); method3(); &#125; private synchronized void method3() &#123; System.out.println(Thread.currentThread().getId()+ &quot;: method3()&quot;); &#125;&#125; 结合前文中加锁和释放锁的原理，不难理解： 执行monitorenter获取锁 （monitor计数器&#x3D;0，可获取锁） 执行method1()方法，monitor计数器+1 -&gt; 1 （获取到锁） 执行method2()方法，monitor计数器+1 -&gt; 2 执行method3()方法，monitor计数器+1 -&gt; 3 执行monitorexit命令 method3()方法执行完，monitor计数器-1 -&gt; 2 method2()方法执行完，monitor计数器-1 -&gt; 1 method2()方法执行完，monitor计数器-1 -&gt; 0 （释放了锁） （monitor计数器&#x3D;0，锁被释放了） 这就是Synchronized的重入性，即在同一锁程中，每个对象拥有一个monitor计数器，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一，线程不需要再次获取同一把锁。 保证可见性的原理：内存模型和happens-before规则Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码： 1234567891011public class MonitorDemo &#123; private int a = 0; public synchronized void writer() &#123; // 1 a++; // 2 &#125; // 3 public synchronized void reader() &#123; // 4 int i = a; // 5 &#125; // 6&#125; 该代码的happens-before关系如图所示： 在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系，通过传递性规则进一步推导的happens-before关系。现在我们来重点关注2 happens-before 5，通过这个关系我们可以得出什么? 根据happens-before的定义中的一条:如果A happens-before B，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1。 JVM中锁的优化简单来说在JVM中monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的；然而在现实中的大部分情况下，同步方法是运行在单线程环境(无锁竞争环境)如果每次都调用Mutex Lock那么将严重的影响程序的性能。不过在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销。 锁粗化(Lock Coarsening)：也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。 锁消除(Lock Elimination)：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，通过逃逸分析也可以在线程本的Stack上进行对象空间的分配(同时还可以减少Heap上的垃圾收集开销)。 轻量级锁(Lightweight Locking)：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态(即单线程执行环境)，在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒(具体处理步骤下面详细讨论)。 偏向锁(Biased Locking)：是为了在无锁竞争的情况下避免在锁获取过程中执行不必要的CAS原子指令，因为CAS原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟。 适应性自旋(Adaptive Spinning)：当线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁(mutex semaphore)前会进入忙等待(Spinning)然后再次尝试，当尝试一定的次数后如果仍然没有成功则调用与该monitor关联的semaphore(即互斥锁)进入到阻塞状态。 下面来详细讲解下，先从Synchronied同步锁开始讲起： 锁的类型在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。 锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的) 自旋锁与自适应自旋锁自旋锁 引入背景：大家都知道，在没有加入锁优化时，Synchronized是一个非常“胖大”的家伙。在多线程竞争锁时，当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。在挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作对系统的并发性能带来了很大的压力。同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的线程在门外等待一会(自旋)，但不放弃CPU的执行时间。等待持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要让线程执行一个忙循环(自旋)，这便是自旋锁由来的原因。 自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销(因为在线程自旋时，始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源)。因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，用户可以使用参数-XX:PreBlockSpin来更改。 可是现在又出现了一个问题：如果线程锁在线程自旋刚结束就释放掉了锁，那么是不是有点得不偿失。所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。(这里则需要自适应自旋锁！) 自适应自旋锁 在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，JVM对程序的锁的状态预测会越来越准确，JVM也会越来越聪明。 锁消除锁消除是指虚拟机即时编译器再运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。意思就是：JVM会判断再一段程序中的同步明显不会逃逸出去从而被其他线程访问到，那JVM就把它们当作栈上数据对待，认为这些数据是线程独有的，不需要加同步。此时就会进行锁消除。 当然在实际开发中，我们很清楚的知道哪些是线程独有的，不需要加同步锁，但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。如果数据并不会逃逸，则会进行锁消除。比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化。在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuidler对象的连续append()操作。 1234public static String test03(String s1, String s2, String s3) &#123; String s = s1 + s2 + s3; return s;&#125; 上述代码使用javap 编译结果 众所周知，StringBuilder不是安全同步的，但是在上述代码中，JVM判断该段代码并不会逃逸，则将该代码带默认为线程独有的资源，并不需要同步，所以执行了锁消除操作。(还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内) 锁粗化原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围(只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁)。 大部分上述情况是完美正确的，但是如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作。 这里贴上根据上述Javap 编译的情况编写的实例java类 1234567public static String test04(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 在上述的连续append()操作中就属于这类情况。JVM会检测到这样一连串的操作都是对同一个对象加锁，那么JVM会将加锁同步的范围扩展(粗化)到整个一系列操作的 外部，使整个一连串的append()操作只需要加锁一次就可以了。 轻量级锁在JDK 1.6之后引入的轻量级锁，需要注意的是轻量级锁并不是替代重量级锁的，而是对在大多数情况下同步块并不会有竞争出现提出的一种优化。它可以减少重量级锁对线程的阻塞带来的线程开销。从而提高并发性能。 如果要理解轻量级锁，那么必须先要了解HotSpot虚拟机中对象头的内存布局。上面介绍Java对象头也详细介绍过。在对象头中(Object Header)存在两部分。第一部分用于存储对象自身的运行时数据，HashCode、GC Age、锁标记位、是否为偏向锁。等。一般为32位或者64位(视操作系统位数定)。官方称之为Mark Word，它是实现轻量级锁和偏向锁的关键。 另外一部分存储的是指向方法区对象类型数据的指针(Klass Point)，如果对象是数组的话，还会有一个额外的部分用于存储数据的长度。 轻量级锁加锁在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图： 如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图： 如果这个更新操作失败，JVM会检查当前的Mark Word中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。此时，锁的标志位为10.Mark Word中存储的指向重量级锁的指针。 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下： 偏向锁 引入背景：在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。 为了解决这一问题，HotSpot的作者在Java SE 1.6 中对Synchronized进行了优化，引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。 偏向锁的撤销 偏向锁使用了一种等待竞争出现才会释放锁的机制。所以当其他线程尝试获取偏向锁时，持有偏向锁的线程才会释放锁。但是偏向锁的撤销需要等到全局安全点(就是当前线程没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，让你后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，直接将对象头设置为无锁状态。如果线程活着，JVM会遍历栈帧中的锁记录，栈帧中的锁记录和对象头要么偏向于其他线程，要么恢复到无锁状态或者标记对象不适合作为偏向锁。 锁的优缺点对比 锁 优点 缺点 使用场景 偏向锁 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 适用于只有一个线程访问同步块的场景 轻量级锁 竞争的线程不会阻塞，提高了响应速度 如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能 追求响应时间，同步块执行速度非常快 重量级锁 线程竞争不适用自旋，不会消耗CPU 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 追求吞吐量，同步块执行速度较长 Synchronized与Locksynchronized的缺陷 效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时 不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活 无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，….，如果获取失败，….. Lock解决相应问题Lock类这里不做过多解释，主要看里面的4个方法: lock(): 加锁 unlock(): 解锁 tryLock(): 尝试获取锁，返回一个boolean值 tryLock(long,TimeUtil): 尝试获取锁，可以设置超时 Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来Condition与Lock的结合解决了这个问题。 多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。 ReentrantLock为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。详细分析请看: JUC锁: ReentrantLock详解 再深入理解synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。 使用Synchronized有哪些要注意的？ 锁对象不能为空，因为锁的信息都保存在对象头里 作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错 避免死锁 在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错 synchronized是公平锁吗？ synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。 参考文章+《深入理解Java虚拟机》 +《Java并发编程的艺术》 https://juejin.im/post/5ae6dc04f265da0ba351d3ff https://www.cnblogs.com/javaminer/p/3889023.html https://www.jianshu.com/p/dab7745c0954 https://www.cnblogs.com/wuchaodzxx/p/6867546.html https://www.cnblogs.com/xyabk/p/10901291.html https://www.jianshu.com/p/64240319ed60","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"4.Java并发 - Java中所有的锁","path":"/2023/12/25/4-Java并发-Java中所有的锁/","content":"Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 前言Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8和Netty 3.10.6）、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 Java中往往是按照是否含有某一特性来定义锁，我们通过特性将锁进行分组归类，再使用对比的方式进行介绍，帮助大家更快捷的理解相关知识。下面给出本文内容的总体分类目录： 1. 乐观锁 VS 悲观锁 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。 根据从上面的概念描述我们可以发现： 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。 光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例： 12345678910111213141516// ------------------------- 悲观锁的调用方式 -------------------------// synchronizedpublic synchronized void testMethod() &#123;\t// 操作同步资源&#125;// ReentrantLockprivate ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁public void modifyPublicResources() &#123;\tlock.lock();\t// 操作同步资源\tlock.unlock();&#125;// ------------------------- 乐观锁的调用方式 -------------------------private AtomicInteger atomicInteger = new AtomicInteger(); // 需要保证多个线程使用的是同一个AtomicIntegeratomicInteger.incrementAndGet(); //执行自增1 通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？具体可以参看JUC原子类: CAS, Unsafe和原子类详解。 2. 自旋锁 VS 适应性自旋锁 在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。 而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。 自旋锁相关可以看关键字 - synchronized详解 - 自旋锁与自适应自旋锁 3. 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁 这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。 总结而言： 偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。 相关可以看关键字 - synchronized详解 - 锁的类型 4. 公平锁 VS 非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。 直接用语言描述可能有点抽象，这里作者用从别处看到的一个例子来讲述一下公平锁和非公平锁。 如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。 但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示： 更多请参看JUC - ReentrantLock详解。 5. 可重入锁 VS 非可重入锁可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析： 12345678910public class Widget &#123; public synchronized void doSomething() &#123; System.out.println(&quot;方法1执行...&quot;); doOthers(); &#125; public synchronized void doOthers() &#123; System.out.println(&quot;方法2执行...&quot;); &#125;&#125; 在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。 而为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？我们通过图示和源码来分别解析一下。 还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。 但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。 之前我们说过ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。 首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status &#x3D;&#x3D; 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status !&#x3D; 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status !&#x3D; 0的话会导致其获取锁失败，当前线程阻塞。 释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 &#x3D;&#x3D; 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。 更多请参看： JUC锁: LockSupport详解 JUC锁: AbstractQueuedSynchronizer详解 JUC锁 - ReentrantLock详解。 关键字 - synchronized详解 6. 独享锁(排他锁) VS 共享锁 独享锁和共享锁同样是一种概念。我们先介绍一下具体的概念，然后通过ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁。 独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 下图为ReentrantReadWriteLock的部分源码： 我们看到ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。 在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。 更多请参看 JUC锁: ReentrantReadWriteLock详解 结语本文Java中常用的锁以及常见的锁的概念进行了基本介绍，并从源码以及实际应用的角度进行了对比分析。限于篇幅以及个人水平，没有在本篇文章中对所有内容进行深层次的讲解。 其实Java本身已经对锁本身进行了良好的封装，降低了研发同学在平时工作中的使用难度。但是研发同学也需要熟悉锁的底层原理，不同场景下选择最适合的锁。而且源码中的思路都是非常好的思路，也是值得大家去学习和借鉴的。 参考资料 《Java并发编程艺术》 Java中的锁 Java CAS 原理剖析 Java并发——关键字synchronized解析 Java synchronized原理总结 聊聊并发（二）——Java SE1.6中的Synchronized 深入理解读写锁—ReadWriteLock源码分析 【JUC】JDK1.8源码分析之ReentrantReadWriteLock Java多线程（十）之ReentrantReadWriteLock深入分析 Java–读写锁的实现原理 作者简介家琪，美团点评后端工程师。2017 年加入美团点评，负责美团点评境内度假的业务开发。 文章来源本文主要在美团技术团队家琪的文章基础上进行调整，以满足整体的知识体系。 著作权归@pdai所有 原文链接：https://pdai.tech/md/java/thread/java-thread-x-lock-all.html","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"3.Java 并发 - 线程基础","path":"/2023/12/25/3-Java-并发-线程基础/","content":"本文主要概要性的介绍线程的基础，为后面的章节深入介绍Java并发的知识提供基础。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解线程基础。 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式? 通常线程有哪几种使用方式? 基础线程机制有哪些? 线程的中断方式有哪些? 线程的互斥同步方式有哪些? 如何比较和选择? 线程之间有哪些协作方式? 线程状态转换 新建(New)创建后尚未启动。 可运行(Runnable)可能正在运行，也可能正在等待 CPU 时间片。 包含了操作系统线程状态中的 Running 和 Ready。 阻塞(Blocking)等待获取一个排它锁，如果其线程释放了锁就会结束此状态。 无限期等待(Waiting)等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。 进入方法 退出方法 没有设置 Timeout 参数的 Object.wait() 方法 Object.notify() &#x2F; Object.notifyAll() 没有设置 Timeout 参数的 Thread.join() 方法 被调用的线程执行完毕 LockSupport.park() 方法 - 限期等待(Timed Waiting)无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。 调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。 睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 进入方法 退出方法 Thread.sleep() 方法 时间结束 设置了 Timeout 参数的 Object.wait() 方法 时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll() 设置了 Timeout 参数的 Thread.join() 方法 时间结束 &#x2F; 被调用的线程执行完毕 LockSupport.parkNanos() 方法 - LockSupport.parkUntil() 方法 - 死亡(Terminated)可以是线程结束任务之后自己结束，或者产生了异常而结束。 线程使用方式有三种使用线程的方法: 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 实现 Runnable 接口需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。 12345public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125; 12345public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; 1234567public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125; 1234public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 实现接口 VS 继承 Thread实现接口会更好一些，因为: Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 类可能只要求可执行就行，继承整个 Thread 类开销过大。 基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor: CachedThreadPool: 一个任务创建一个线程； FixedThreadPool: 所有任务只能使用固定大小的线程； SingleThreadExecutor: 相当于大小为 1 的 FixedThreadPool。 1234567public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 使用 setDaemon() 方法将一个线程设置为守护线程。 1234public static void main(String[] args) &#123; Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true);&#125; sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 1234567public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 123public void run() &#123; Thread.yield();&#125; 线程中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 InterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。 1234567891011121314public class InterruptExample &#123; private static class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(&quot;Thread run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new MyThread1(); thread1.start(); thread1.interrupt(); System.out.println(&quot;Main run&quot;);&#125; 123456Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) interrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // .. &#125; System.out.println(&quot;Thread end&quot;); &#125; &#125;&#125; 12345public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125; 1Thread end Executor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 12345678910111213public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; try &#123; Thread.sleep(2000); System.out.println(&quot;Thread run&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdownNow(); System.out.println(&quot;Main run&quot;);&#125; 12345678Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9) at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)\\ 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 1234Future&lt;?&gt; future = executorService.submit(() -&gt; &#123; // ..&#125;);future.cancel(true); 线程互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized1. 同步一个代码块 12345public void func() &#123; synchronized (this) &#123; // ... &#125;&#125; 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 12345678910public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());&#125; 10 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 2. 同步一个方法 123public synchronized void func () &#123; // ...&#125; 它和同步代码块一样，作用于同一个对象。 3. 同步一个类 12345public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 12345678910public class SynchronizedExample &#123; public void func2() &#123; synchronized (SynchronizedExample.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;&#125; 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 4. 同步一个静态方法 123public synchronized static void fun() &#123; // ...&#125; 作用于整个类。 ReentrantLockReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。 123456789101112131415public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; finally &#123; lock.unlock(); // 确保释放锁，从而避免发生死锁。 &#125; &#125;&#125; 123456public static void main(String[] args) &#123; LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.func()); executorService.execute(() -&gt; lockExample.func());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 比较1. 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 2. 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 3. 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 4. 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 5. 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 1234567891011121314151617181920212223242526272829303132333435public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println(&quot;A&quot;); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;B&quot;); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 1234public static void main(String[] args) &#123; JoinExample example = new JoinExample(); example.test();&#125; 12AB wait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateExeception。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 123456789101112131415public class WaitNotifyExample &#123; public synchronized void before() &#123; System.out.println(&quot;before&quot;); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;after&quot;); &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 1234567891011121314151617181920212223242526public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println(&quot;before&quot;); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println(&quot;after&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"2.Java 并发 - 理论基础","path":"/2023/12/25/2-Java-并发-理论基础/","content":"本文从理论的角度引入并发安全问题以及JMM应对并发问题的原理。 带着BAT大厂的面试问题去理解 提示 请带着这些问题继续后文，会很大程度上帮助你更好的理解并发理论基础。 多线程的出现是要解决什么问题的? 线程不安全是指什么? 举例说明 并发出现线程不安全的本质什么? 可见性，原子性和有序性。 Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before 线程安全是不是非真即假? 不是 线程安全有哪些实现思路? 如何理解并发和并行的区别? 为什么需要多线程众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为: CPU 增加了缓存，以均衡与内存的速度差异；&#x2F;&#x2F; 导致 可见性问题 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；&#x2F;&#x2F; 导致 原子性问题 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。&#x2F;&#x2F; 导致 有序性问题 线程不安全示例如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。 以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。 12345678910111213141516171819202122232425262728public class ThreadUnsafeExample &#123; private int cnt = 0; public void add() &#123; cnt++; &#125; public int get() &#123; return cnt; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; ThreadUnsafeExample example = new ThreadUnsafeExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125;997 // 结果总是小于1000 并发出现问题的根源: 并发三要素上述代码输出为什么不是1000? 并发出现问题的根源是什么? 可见性: CPU缓存引起可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 原子性: 分时复用引起原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 举个简单的例子，看下面这段代码： 1234567int i = 1;// 线程1执行i += 1;// 线程2执行i += 1; 这里需要注意的是：i += 1需要三条 CPU 指令 将变量 i 从内存读取到 CPU寄存器； 在CPU寄存器中执行 i + 1 操作； 将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。 由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。 有序性: 重排序引起有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。 在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序： 上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。 具体可以参看：Java 内存模型详解的重排序章节。 JAVA是怎么解决并发问题的: JMM(Java内存模型)Java 内存模型是个很复杂的规范，强烈推荐你看后续（应该是网上能找到最好的材料之一了）：Java 内存模型详解。 理解的第一个维度：核心知识点 JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括： volatile、synchronized 和 final 三个关键字 Happens-Before 规则 理解的第二个维度：可见性，有序性，原子性 原子性 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中y = x; //语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。x++; //语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。x = x + 1; //语句4： 同语句3 上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 可见性 Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 有序性 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。当然JMM是通过Happens-Before 规则来保证有序性的。 关键字: volatile、synchronized 和 final以下三篇文章详细分析了这三个关键字： 关键字: synchronized详解 关键字: volatile详解 关键字: final详解 Happens-Before 规则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 1. 单一线程原则 Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 2. 管程锁定规则 Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 3. volatile 变量规则 Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 4. 线程启动规则 Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 5. 线程加入规则 Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 6. 线程中断规则 Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 7. 对象终结规则 Finalizer Rule 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始。 8. 传递性 Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 线程安全: 不是一个非真即假的命题一个类在可以被多个线程安全调用时就是线程安全的。 线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 1. 不可变不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。 多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型: final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 12345678910public class ImmutableExample &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(&quot;a&quot;, 1); &#125;&#125;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 2. 绝对线程安全不管运行时环境如何，调用者都不需要任何额外的同步措施。 3. 相对线程安全相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。 对于下面的代码，如果删除元素的线程删除了 Vector 的一个元素，而获取元素的线程试图访问一个已经被删除的元素，那么就会抛出 ArrayIndexOutOfBoundsException。 12345678910111213141516171819202122232425262728public class VectorUnsafeExample &#123; private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;(); public static void main(String[] args) &#123; while (true) &#123; for (int i = 0; i &lt; 100; i++) &#123; vector.add(i); &#125; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125;); executorService.execute(() -&gt; &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125;); executorService.shutdown(); &#125; &#125;&#125;Exception in thread &quot;Thread-159738&quot; java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 3 at java.util.Vector.remove(Vector.java:831) at VectorUnsafeExample.lambda$main$0(VectorUnsafeExample.java:14) at VectorUnsafeExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) 如果要保证上面的代码能正确执行下去，就需要对删除元素和获取元素的代码进行同步。 1234567891011121314executorService.execute(() -&gt; &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; &#125;&#125;);executorService.execute(() -&gt; &#123; synchronized (vector) &#123; for (int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i); &#125; &#125;&#125;); 4. 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。 5. 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。 线程安全的实现方法1. 互斥同步synchronized 和 ReentrantLock。 初步了解你可以看： Java 并发 - 线程基础：线程互斥同步 详细分析请看： 关键字: Synchronized详解 JUC锁: ReentrantLock详解 2. 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 (一)CAS 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略: 先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施(不断地重试，直到成功为止)。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是: 比较并交换(Compare-and-Swap，CAS)。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 (二)AtomicInteger J.U.C 包里面的整数原子类 AtomicInteger，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; (三)ABA 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 CAS, Unsafe和原子类详细分析请看： JUC原子类: CAS, Unsafe和原子类详解 3. 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 (一)栈封闭 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 123456789101112131415161718192021import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125;public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125;100100 更详细的分析请看J.U.C中线程池相关内容详解： JUC线程池: FutureTask详解 JUC线程池: ThreadPoolExecutor详解 JUC线程池: ScheduledThreadPool详解 JUC线程池: Fork&#x2F;Join框架详解 (二)线程本地存储(Thread Local Storage) 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 123456789101112131415161718192021public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125; 输出结果 11 为了理解 ThreadLocal，先看以下代码: 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 它所对应的底层结构图为: 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象，Thread 类中就定义了 ThreadLocal.ThreadLocalMap 成员。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 更详细的分析看：Java 并发 - ThreadLocal详解 (三)可重入代码(Reentrant Code) 这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"1.Java并发知识体系详解","path":"/2023/12/25/1-Java并发知识体系详解/","content":"Java 并发相关知识体系详解，包含理论基础，线程基础，synchronized，volatile，final关键字, JUC框架等内容。 知识体系 相关文章 A. Java进阶 - Java 并发之基础：首先全局的了解并发的知识体系，同时了解并发理论基础和线程基础，并发关键字等，这些是你理解Java并发框架的基础。 Java 并发 - 知识体系 Java 并发 - 理论基础 多线程的出现是要解决什么问题的? 线程不安全是指什么? 举例说明 并发出现线程不安全的本质什么? 可见性，原子性和有序性。 Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before 线程安全是不是非真即假? 不是 线程安全有哪些实现思路? 如何理解并发和并行的区别? Java 并发 - 线程基础 线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式? 通常线程有哪几种使用方式? 基础线程机制有哪些? 线程的中断方式有哪些? 线程的互斥同步方式有哪些? 如何比较和选择? 线程之间有哪些协作方式? Java并发 - Java中所有的锁 Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码、使用场景进行举例，为读者介绍主流锁的知识点，以及不同的锁的适用场景。 关键字: synchronized详解 Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。 Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。 Synchronized由什么样的缺陷? Java Lock是怎么弥补这些缺陷的。 Synchronized和Lock的对比，和选择? Synchronized在使用时有何注意事项? Synchronized修饰的方法在抛出异常时,会释放锁吗? 多个线程等待同一个Synchronized锁的时候，JVM如何选择下一个获取锁的线程? Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法? 我想更加灵活地控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办? 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁? 不同的JDK中对Synchronized有何优化? 关键字: volatile详解 volatile关键字的作用是什么? volatile能保证原子性吗? 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢? i++为什么不能保证原子性? volatile是如何实现可见性的? 内存屏障。 volatile是如何实现有序性的? happens-before等 说下volatile的应用场景? 关键字: final详解 所有的final修饰的字段都是编译期常量吗? 如何理解private所修饰的方法是隐式的final? 说说final类型的类如何拓展? 比如String是final类型，我们想写个MyString复用所有String中方法，同时增加一个新的toMyString()的方法，应该如何做? final方法可以被重载吗? 可以 父类的final方法能不能够被子类重写? 不可以 说说final域重排序规则? 说说final的原理? 使用 final 的限制条件和局限性? 看本文最后的一个思考题 B. Java进阶 - Java 并发之J.U.C框架：然后需要对J.U.C框架五大类详细解读，包括：Lock框架，并发集合, 原子类, 线程池和工具类。@pdai JUC - 类汇总和学习指南 JUC框架包含几个部分? 每个部分有哪些核心的类? 最最核心的类有哪些? B.1 Java进阶 - Java 并发之J.U.C框架【1&#x2F;5】：CAS及原子类：从最核心的CAS, Unsafe和原子类开始分析。 JUC原子类: CAS, Unsafe和原子类详解 线程安全的实现方法有哪些? 什么是CAS? CAS使用示例，结合AtomicInteger给出示例? CAS会有哪些问题? 针对这这些问题，Java提供了哪几个解决的? AtomicInteger底层实现? CAS+volatile 请阐述你对Unsafe类的理解? 说说你对Java原子类的理解? 包含13个，4组分类，说说作用和使用场景。 AtomicStampedReference是什么? AtomicStampedReference是怎么解决ABA的? 内部使用Pair来存储元素值及其版本号 java中还有哪些类可以解决ABA的问题? AtomicMarkableReference B.2 Java进阶 - Java 并发之J.U.C框架【2&#x2F;5】：锁：然后分析JUC中锁。 JUC锁: LockSupport详解 为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park&#x2F;unpark操作) 写出分别通过wait&#x2F;notify和LockSupport的park&#x2F;unpark实现同步? LockSupport.park()会释放锁资源吗? 那么Condition.await()呢? Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? 重点 如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样? JUC锁: 锁核心类AQS详解 什么是AQS? 为什么它是核心? AQS的核心思想是什么? 它是怎么实现的? 底层数据结构等 AQS有哪些核心的方法? AQS定义什么样的资源获取方式? AQS定义了两种资源获取方式：独占(只有一个线程能访问执行，又根据是否按队列的顺序分为公平锁和非公平锁，如ReentrantLock) 和共享(多个线程可同时访问执行，如Semaphore、CountDownLatch、 CyclicBarrier )。ReentrantReadWriteLock可以看成是组合式，允许多个线程同时对某一资源进行读。 AQS底层使用了什么样的设计模式? 模板 AQS的应用示例? JUC锁: ReentrantLock详解 什么是可重入，什么是可重入锁? 它用来解决什么问题? ReentrantLock的核心是AQS，那么它怎么来实现的，继承吗? 说说其类内部结构关系。 ReentrantLock是如何实现公平锁的? ReentrantLock是如何实现非公平锁的? ReentrantLock默认实现的是公平还是非公平锁? 使用ReentrantLock实现公平和非公平锁的示例? ReentrantLock和Synchronized的对比? JUC锁: ReentrantReadWriteLock详解 为了有了ReentrantLock还需要ReentrantReadWriteLock? ReentrantReadWriteLock底层实现原理? ReentrantReadWriteLock底层读写状态如何设计的? 高16位为读锁，低16位为写锁 读锁和写锁的最大数量是多少? 本地线程计数器ThreadLocalHoldCounter是用来做什么的? 缓存计数器HoldCounter是用来做什么的? 写锁的获取与释放是怎么实现的? 读锁的获取与释放是怎么实现的? RentrantReadWriteLock为什么不支持锁升级? 什么是锁的升降级? RentrantReadWriteLock为什么不支持锁升级? B.3 Java进阶 - Java 并发之J.U.C框架【3&#x2F;5】：集合：再理解JUC中重要的支持并发的集合。 JUC集合: ConcurrentHashMap详解 为什么HashTable慢? 它的并发度是什么? 那么ConcurrentHashMap并发度是什么? ConcurrentHashMap在JDK1.7和JDK1.8中实现有什么差别? JDK1.8解決了JDK1.7中什么问题 ConcurrentHashMap JDK1.7实现的原理是什么? 分段锁机制 ConcurrentHashMap JDK1.8实现的原理是什么? 数组+链表+红黑树，CAS ConcurrentHashMap JDK1.7中Segment数(concurrencyLevel)默认值是多少? 为何一旦初始化就不可再扩容? ConcurrentHashMap JDK1.7说说其put的机制? ConcurrentHashMap JDK1.7是如何扩容的? rehash(注：segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容) ConcurrentHashMap JDK1.8是如何扩容的? tryPresize ConcurrentHashMap JDK1.8链表转红黑树的时机是什么? 临界值为什么是8? ConcurrentHashMap JDK1.8是如何进行数据迁移的? transfer JUC集合: CopyOnWriteArrayList详解 请先说说非并发集合中Fail-fast机制? 再为什么说ArrayList查询快而增删慢? 对比ArrayList说说CopyOnWriteArrayList的增删改查实现原理? COW基于拷贝 再说下弱一致性的迭代器原理是怎么样的? COWIterator&lt;E&gt; CopyOnWriteArrayList为什么并发安全且性能比Vector好? CopyOnWriteArrayList有何缺陷，说说其应用场景? JUC集合: ConcurrentLinkedQueue详解 要想用线程安全的队列有哪些选择? Vector，Collections.synchronizedList( List&lt;T&gt; list), ConcurrentLinkedQueue等 ConcurrentLinkedQueue实现的数据结构? ConcurrentLinkedQueue底层原理? 全程无锁(CAS) ConcurrentLinkedQueue的核心方法有哪些? offer()，poll()，peek()，isEmpty()等队列常用方法 说说ConcurrentLinkedQueue的HOPS(延迟更新的策略)的设计? ConcurrentLinkedQueue适合什么样的使用场景? JUC集合: BlockingQueue详解 什么是BlockingDeque? BlockingQueue大家族有哪些? ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, SynchronousQueue… BlockingQueue适合用在什么样的场景? BlockingQueue常用的方法? BlockingQueue插入方法有哪些? 这些方法(add(o),offer(o),put(o),offer(o, timeout, timeunit))的区别是什么? BlockingDeque 与BlockingQueue有何关系，请对比下它们的方法? BlockingDeque适合用在什么样的场景? BlockingDeque大家族有哪些? BlockingDeque 与BlockingQueue实现例子? B.4 Java进阶 - Java 并发之J.U.C框架【4&#x2F;5】：线程池：再者分析JUC中非常常用的线程池等。 JUC线程池: FutureTask详解 FutureTask用来解决什么问题的? 为什么会出现? FutureTask类结构关系怎么样的? FutureTask的线程安全是由什么保证的? FutureTask结果返回机制? FutureTask内部运行状态的转变? FutureTask通常会怎么用? 举例说明。 JUC线程池: ThreadPoolExecutor详解 为什么要有线程池? Java是实现和管理线程池有哪些方式? 请简单举例如何使用。 为什么很多公司不允许使用Executors去创建线程池? 那么推荐怎么使用呢? ThreadPoolExecutor有哪些核心的配置参数? 请简要说明 ThreadPoolExecutor可以创建哪是哪三种线程池呢? 当队列满了并且worker的数量达到maxSize的时候，会怎么样? 说说ThreadPoolExecutor有哪些RejectedExecutionHandler策略? 默认是什么策略? 简要说下线程池的任务执行机制? execute –&gt; addWorker –&gt;runworker (getTask) 线程池中任务是如何提交的? 线程池中任务是如何关闭的? 在配置线程池的时候需要考虑哪些配置因素? 如何监控线程池的状态? JUC线程池: ScheduledThreadPool详解 ScheduledThreadPoolExecutor要解决什么样的问题? ScheduledThreadPoolExecutor相比ThreadPoolExecutor有哪些特性? ScheduledThreadPoolExecutor有什么样的数据结构，核心内部类和抽象类? ScheduledThreadPoolExecutor有哪两个关闭策略? 区别是什么? ScheduledThreadPoolExecutor中scheduleAtFixedRate 和 scheduleWithFixedDelay区别是什么? 为什么ThreadPoolExecutor 的调整策略却不适用于 ScheduledThreadPoolExecutor? Executors 提供了几种方法来构造 ScheduledThreadPoolExecutor? JUC线程池: Fork&#x2F;Join框架详解 Fork&#x2F;Join主要用来解决什么样的问题? Fork&#x2F;Join框架是在哪个JDK版本中引入的? Fork&#x2F;Join框架主要包含哪三个模块? 模块之间的关系是怎么样的? ForkJoinPool类继承关系? ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。 整个Fork&#x2F;Join 框架的执行流程&#x2F;运行机制是怎么样的? 具体阐述Fork&#x2F;Join的分治思想和work-stealing 实现方式? 有哪些JDK源码中使用了Fork&#x2F;Join思想? 如何使用Executors工具类创建ForkJoinPool? 写一个例子: 用ForkJoin方式实现1+2+3+…+100000? Fork&#x2F;Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。 B.5 Java进阶 - Java 并发之J.U.C框架【5&#x2F;5】：工具类：最后来看下JUC中有哪些工具类，以及线程隔离术ThreadLocal。 JUC工具类: CountDownLatch详解 什么是CountDownLatch? CountDownLatch底层实现原理? CountDownLatch一次可以唤醒几个任务? 多个 CountDownLatch有哪些主要方法? await(),countDown() CountDownLatch适用于什么场景? 写道题：实现一个容器，提供两个方法，add，size 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到5个时，线程2给出提示并结束? 使用CountDownLatch 代替wait notify 好处。 JUC工具类: CyclicBarrier详解 什么是CyclicBarrier? CyclicBarrier底层实现原理? CountDownLatch和CyclicBarrier对比? CyclicBarrier的核心函数有哪些? CyclicBarrier适用于什么场景? JUC工具类: Semaphore详解 什么是Semaphore? Semaphore内部原理? Semaphore常用方法有哪些? 如何实现线程同步和互斥的? Semaphore适合用在什么场景? 单独使用Semaphore是不会使用到AQS的条件队列? Semaphore中申请令牌(acquire)、释放令牌(release)的实现? Semaphore初始化有10个令牌，11个线程同时各调用1次acquire方法，会发生什么? Semaphore初始化有10个令牌，一个线程重复调用11次acquire方法，会发生什么? Semaphore初始化有1个令牌，1个线程调用一次acquire方法，然后调用两次release方法，之后另外一个线程调用acquire(2)方法，此线程能够获取到足够的令牌并继续运行吗? Semaphore初始化有2个令牌，一个线程调用1次release方法，然后一次性获取3个令牌，会获取到吗? JUC工具类: Phaser详解 Phaser主要用来解决什么问题? Phaser与CyclicBarrier和CountDownLatch的区别是什么? 如果用CountDownLatch来实现Phaser的功能应该怎么实现? Phaser运行机制是什么样的? 给一个Phaser使用的示例? JUC工具类: Exchanger详解 Exchanger主要解决什么问题? 对比SynchronousQueue，为什么说Exchanger可被视为 SynchronousQueue 的双向形式? Exchanger在不同的JDK版本中实现有什么差别? Exchanger实现机制? Exchanger已经有了slot单节点，为什么会加入arena node数组? 什么时候会用到数组? arena可以确保不同的slot在arena中是不会相冲突的，那么是怎么保证的呢? 什么是伪共享，Exchanger中如何体现的? Exchanger实现举例 Java 并发 - ThreadLocal详解 什么是ThreadLocal? 用来解决什么问题的? 说说你对ThreadLocal的理解 ThreadLocal是如何实现线程隔离的? 为什么ThreadLocal会造成内存泄露? 如何解决 还有哪些使用ThreadLocal的应用场景? C. Java进阶 - Java 并发之 本质与模式：最后站在更高的角度看其本质(协作，分工和互斥)，同时总结上述知识点所使用的模式。@pdai TODO：Java 并发 - 并发的本质：协作,分工和互斥 TODO：Java 并发 - 并发的模式梳理 参考文档官方文档 https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html 并发官方教程 https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html Doug Lea并发编程文章全部译文 http://ifeve.com/doug-lea/ Java并发知识点总结 https://github.com/CL0610/Java-concurrency 线程与多线程必知必会(基础篇) https://zhuanlan.zhihu.com/p/33616143","tags":["Java","多线程与并发"],"categories":["Java","多线程与并发"]},{"title":"9.Map - WeakHashMap源码解析","path":"/2023/12/25/9-Map-WeakHashMap源码解析/","content":"本文主要对Map - WeakHashMap源码解析 源码解析。 Java 7- WeakHashMap总体介绍在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员: WeakHashMap，从名字可以看出它是某种 Map。它的特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使程序员没有调用remove()或者clear()方法。 更直观的说，当使用 WeakHashMap 时，即使没有显示的添加或删除任何元素，也可能发生如下情况: 调用两次size()方法返回不同的值； 两次调用isEmpty()方法，第一次返回false，第二次返回true； 两次调用containsKey()方法，第一次返回true，第二次返回false，尽管两次使用的是同一个key； 两次调用get()方法，第一次返回一个value，第二次返回null，尽管两次使用的是同一个对象。 遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉? 其实不然，*WeakHashMap* 的这个特点特别适用于需要缓存的场景。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。 要明白 WeakHashMap 的工作原理，还需要引入一个概念 : 弱引用(WeakReference)。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，是否有有效的引用指向该对象。如果没有有效引用指向该对象(基本意味着不存在访问该对象的方式)，那么该对象就是可回收的。这里的有效引用 并不包括弱引用。也就是说，虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收。 WeakHashMap 内部是通过弱引用来管理entry的，弱引用的特性对应到 WeakHashMap 上意味着什么呢？将一对key, value放入到 *WeakHashMap* 里并不能避免该key值被GC回收，除非在 *WeakHashMap* 之外还有对该key的强引用。 关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。 具体实现WeakHashMap的存储结构类似于Map - HashSet &amp; HashMap 源码解析，这里不再赘述。 关于强弱引用的管理方式，博主将会另开专题单独讲解。 Weak HashSet?如果你看过前几篇关于 Map 和 Set 的讲解，一定会问: 既然有 WeakHashMap，是否有 WeekHashSet 呢? 答案是没有:( 。不过Java Collections工具类给出了解决方案，Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)方法可以将任何 Map包装成一个Set。通过如下方式可以快速得到一个 Weak HashSet: 123// 将WeakHashMap包装成一个SetSet&lt;Object&gt; weakHashSet = Collections.newSetFromMap( new WeakHashMap&lt;Object, Boolean&gt;()); 不出你所料，newSetFromMap()方法只是对传入的 Map做了简单包装: 12345678910111213141516171819202122232425262728293031323334// Collections.newSetFromMap()用于将任何Map包装成一个Setpublic static &lt;E&gt; Set&lt;E&gt; newSetFromMap(Map&lt;E, Boolean&gt; map) &#123; return new SetFromMap&lt;&gt;(map);&#125;private static class SetFromMap&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Serializable&#123; private final Map&lt;E, Boolean&gt; m; // The backing map private transient Set&lt;E&gt; s; // Its keySet SetFromMap(Map&lt;E, Boolean&gt; map) &#123; if (!map.isEmpty()) throw new IllegalArgumentException(&quot;Map is non-empty&quot;); m = map; s = map.keySet(); &#125; public void clear() &#123; m.clear(); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public boolean remove(Object o) &#123; return m.remove(o) != null; &#125; public boolean add(E e) &#123; return m.put(e, Boolean.TRUE) == null; &#125; public Iterator&lt;E&gt; iterator() &#123; return s.iterator(); &#125; public Object[] toArray() &#123; return s.toArray(); &#125; public &lt;T&gt; T[] toArray(T[] a) &#123; return s.toArray(a); &#125; public String toString() &#123; return s.toString(); &#125; public int hashCode() &#123; return s.hashCode(); &#125; public boolean equals(Object o) &#123; return o == this || s.equals(o); &#125; public boolean containsAll(Collection&lt;?&gt; c) &#123;return s.containsAll(c);&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;return s.removeAll(c);&#125; public boolean retainAll(Collection&lt;?&gt; c) &#123;return s.retainAll(c);&#125; // addAll is the only inherited implementation ......&#125; 参考文章 浅谈WeakHashMap https://www.cnblogs.com/CarpenterLee/p/5544598.html","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"8.Map - TreeSet & TreeMap 源码解析","path":"/2023/12/25/8-Map-TreeSet-TreeMap-源码解析/","content":"本文主要对Map - TreeSet &amp; TreeMap 源码解析。 Java 7 - TreeSet &amp; TreeMap总体介绍之所以把TreeSet和TreeMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说**TreeSet*里面有一个*TreeMap(适配器模式)*。因此本文将重点分析TreeMap*。 Java TreeMap实现了SortedMap接口，也就是说会按照key的大小顺序对Map中的元素进行排序，key大小的评判可以通过其本身的自然顺序(natural ordering)，也可以通过构造时传入的比较器(Comparator)。 *TreeMap*底层通过红黑树(Red-Black tree)实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。其具体算法实现参照了《算法导论》。 出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的: 1SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); 红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍。具体来说，红黑树是满足如下条件的二叉查找树(binary search tree): 每个节点要么是红色，要么是黑色。 根节点必须是黑色 红色节点不能连续(也即是，红色节点的孩子和父亲都不能是红色)。 对于每个节点，从该点至null(树尾端)的任何路径，都含有相同个数的黑色节点。 在树的结构发生改变时(插入或者删除操作)，往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。 预备知识前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类: 一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，即改变检索树的结构关系。结构调整过程包含两个基本操作** : 左旋(Rotate Left)，右旋(RotateRight)**。 左旋左旋的过程是将x的右子树绕x逆时针旋转，使得x的右子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中左旋代码如下: 123456789101112131415161718//Rotate Leftprivate void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋右旋的过程是将x的左子树绕x顺时针旋转，使得x的左子树成为x的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。 TreeMap中右旋代码如下: 12345678910111213141516//Rotate Rightprivate void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 寻找节点后继对于一棵二叉查找树，给定节点t，其后继(树中比大于t的最小的那个元素)可以通过如下方式找到: t的右子树不空，则t的后继是其右子树中最小的那个元素。 t的右孩子为空，则t的后继是其第一个向左走的祖先。 后继节点在红黑树的删除操作中将会用到。 TreeMap中寻找节点后继的代码如下: 12345678910111213141516171819// 寻找节点后继函数successor()static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123;// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123;// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 方法剖析get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.value。因此getEntry()是算法的核心。算法思想是根据key的自然顺序(或者比较器顺序)对二叉查找树进行查找，直到找到满足k.compareTo(p.key) == 0的entry。 具体代码如下: 123456789101112131415161718//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123; ...... if (key == null)//不允许key值为null throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0)//向左找 p = p.left; else if (cmp &gt; 0)//向右找 p = p.right; else return p; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到则会在红黑树中插入新的entry，如果插入之后破坏了红黑树的约束条件，还需要进行调整(旋转，改变某些节点的颜色)。 123456789101112131415161718192021public V put(K key, V value) &#123;\t...... int cmp; Entry&lt;K,V&gt; parent; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;//使用元素的自然顺序 do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left;//向左找 else if (cmp &gt; 0) t = t.right;//向右找 else return t.setValue(value); &#125; while (t != null); Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);//创建并插入新的entry if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e);//调整 size++; return null;&#125; 上述代码的插入部分并不难理解: 首先在红黑树上找到合适的位置，然后创建新的entry并插入(当然，新插入的节点一定是树的叶子)。难点是调整函数fixAfterInsertion()，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。 调整函数fixAfterInsertion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。 12345678910111213141516171819202122232425262728293031323334353637383940//红黑树调整函数fixAfterInsertion()private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况1 setColor(y, BLACK); // 情况1 setColor(parentOf(parentOf(x)), RED); // 情况1 x = parentOf(parentOf(x)); // 情况1 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); // 情况2 rotateLeft(x); // 情况2 &#125; setColor(parentOf(x), BLACK); // 情况3 setColor(parentOf(parentOf(x)), RED); // 情况3 rotateRight(parentOf(parentOf(x))); // 情况3 &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); // 情况4 setColor(y, BLACK); // 情况4 setColor(parentOf(parentOf(x)), RED); // 情况4 x = parentOf(parentOf(x)); // 情况4 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); // 情况5 rotateRight(x); // 情况5 &#125; setColor(parentOf(x), BLACK); // 情况6 setColor(parentOf(parentOf(x)), RED); // 情况6 rotateLeft(parentOf(parentOf(x))); // 情况6 &#125; &#125; &#125; root.color = BLACK;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法首先通过上文中提到的getEntry(Object key)方法找到key值对应的entry，然后调用deleteEntry(Entry&lt;K,V&gt; entry)删除对应的entry。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。 getEntry()函数前面已经讲解过，这里重点放deleteEntry()上，该函数删除指定的entry并在红黑树的约束被破坏时进行调用fixAfterDeletion(Entry&lt;K,V&gt; x)进行调整。 由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况: 删除点p的左右子树都为空，或者只有一棵子树非空。 删除点p的左右子树都非空。 对于上述情况1，处理起来比较简单，直接将p删除(左右子树都为空时)，或者用非空子树替代p(只有一棵子树非空时)；对于情况2，可以用p的后继s(树中大于x的最小的那个元素)代替p，然后使用情况1删除s(此时s一定满足情况1.可以画画看)。 基于以上逻辑，红黑树的节点删除函数deleteEntry()代码如下: 123456789101112131415161718192021222324252627282930313233343536// 红黑树entry删除函数deleteEntry()private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; if (p.left != null &amp;&amp; p.right != null) &#123;// 2. 删除点p的左右子树都非空。 Entry&lt;K,V&gt; s = successor(p);// 后继 p.key = s.key; p.value = s.value; p = s; &#125; Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123;// 1. 删除点p只有一棵子树非空。 replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; p.left = p.right = p.parent = null; if (p.color == BLACK) fixAfterDeletion(replacement);// 调整 &#125; else if (p.parent == null) &#123; root = null; &#125; else &#123; // 1. 删除点p的左右子树都为空 if (p.color == BLACK) fixAfterDeletion(p);// 调整 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数fixAfterDeletion()。首先请思考一下，删除了哪些点才会导致调整？只有删除点是BLACK的时候，才会触发调整函数，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。 跟上文中讲过的fixAfterInsertion()函数一样，这里也要分成若干种情况。记住，无论有多少情况，具体的调整操作只有两种: 1.改变某些节点的颜色，2.对某些节点进行旋转。 上述图解的总体思想是: 将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则: a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环(因为x为红色)；b).一旦进入情况3和情况4，一定会退出循环(因为x为root)。 删除后调整函数fixAfterDeletion()的具体代码如下，其中用到了上文中提到的rotateLeft()和rotateRight()函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况1 setColor(parentOf(x), RED); // 情况1 rotateLeft(parentOf(x)); // 情况1 sib = rightOf(parentOf(x)); // 情况1 &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况2 x = parentOf(x); // 情况2 &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); // 情况3 setColor(sib, RED); // 情况3 rotateRight(sib); // 情况3 sib = rightOf(parentOf(x)); // 情况3 &#125; setColor(sib, colorOf(parentOf(x))); // 情况4 setColor(parentOf(x), BLACK); // 情况4 setColor(rightOf(sib), BLACK); // 情况4 rotateLeft(parentOf(x)); // 情况4 x = root; // 情况4 &#125; &#125; else &#123; // 跟前四种情况对称 Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); // 情况5 setColor(parentOf(x), RED); // 情况5 rotateRight(parentOf(x)); // 情况5 sib = leftOf(parentOf(x)); // 情况5 &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); // 情况6 x = parentOf(x); // 情况6 &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); // 情况7 setColor(sib, RED); // 情况7 rotateLeft(sib); // 情况7 sib = leftOf(parentOf(x)); // 情况7 &#125; setColor(sib, colorOf(parentOf(x))); // 情况8 setColor(parentOf(x), BLACK); // 情况8 setColor(leftOf(sib), BLACK); // 情况8 rotateRight(parentOf(x)); // 情况8 x = root; // 情况8 &#125; &#125; &#125; setColor(x, BLACK);&#125; TreeSet前面已经说过TreeSet是对TreeMap的简单包装，对TreeSet的函数调用都会转换成合适的TreeMap方法，因此TreeSet的实现非常简单。这里不再赘述。 1234567891011121314151617// TreeSet是对TreeMap的简单包装public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;\t...... private transient NavigableMap&lt;E,Object&gt; m; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public TreeSet() &#123; this.m = new TreeMap&lt;E,Object&gt;();// TreeSet里面有一个TreeMap &#125; ...... public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; ......&#125;","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"7.Map - LinkedHashSet&Map源码解析","path":"/2023/12/25/7-Map-LinkedHashSet-Map源码解析/","content":"本文主要对Map - LinkedHashSet&amp;Map 源码解析。 Java 7 - LinkedHashSet&amp;Map总体介绍如果你已看过前面关于HashSet和HashMap，以及TreeSet和TreeMap的讲解，一定能够想到本文将要讲解的LinkedHashSet和LinkedHashMap其实也是一回事。LinkedHashSet和LinkedHashMap在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说**LinkedHashSet里面有一个LinkedHashMap(适配器模式)*。因此本文将重点分析LinkedHashMap*。 LinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。可将*LinkedHashMap*看作采用*linked list*增强的*HashMap*。 事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是*LinkedHashMap*在*HashMap*的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。 除了可以保迭代历顺序，这种结构还有一个好处 : 迭代*LinkedHashMap*时不需要像*HashMap*那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。 有两个参数可以影响LinkedHashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到LinkedHashMap或LinkedHashSet中时，有两个方法需要特别关心: hashCode()和equals()。**hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到LinkedHashMap或LinkedHashSet中，需要@Override hashCode()和equals()方法。 通过如下方式可以得到一个跟源Map 迭代顺序一样的LinkedHashMap: 1234void foo(Map m) &#123; Map copy = new LinkedHashMap(m); ...&#125; 出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的: 1Map m = Collections.synchronizedMap(new LinkedHashMap(...)); 方法剖析get()get(Object key)方法根据指定的key值返回对应的value。该方法跟HashMap.get()方法的流程几乎完全一样，读者可自行[参考前文在新窗口打开](https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet and HashMap.md#get)，这里不再赘述。 put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。 注意，这里的插入有两重含义: 从table的角度看，新的entry需要插入到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入到冲突链表的头部。 从header的角度看，新的entry需要插入到双向链表的尾部。 addEntry()代码如下: 123456789101112131415// LinkedHashMap.addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);// 自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);// hash%table.length &#125; // 1.在冲突链表头部插入新的entry HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(hash, key, value, old); table[bucketIndex] = e; // 2.在双向链表的尾部插入新的entry e.addBefore(header); size++;&#125; 上述代码中用到了addBefore()方法将新entry e插入到双向链表头引用header的前面，这样e就成为双向链表中的最后一个元素。addBefore()的代码如下: 1234567// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; 上述代码只是简单修改相关entry的引用而已。 remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟get()方法类似。 注意，这里的删除也有两重含义: 从table的角度看，需要将该entry从对应的bucket里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。 从header的角度来看，需要将该entry从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。 removeEntryForKey()对应的代码如下: 12345678910111213141516171819202122232425// LinkedHashMap.removeEntryForKey()，删除key值对应的entryfinal Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;\t......\tint hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);// hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];// 得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;// 遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;// 找到要删除的entry modCount++; size--; // 1. 将e从对应bucket的冲突链表中删除 if (prev == e) table[i] = next; else prev.next = next; // 2. 将e从双向链表中删除 e.before.after = e.after; e.after.before = e.before; return e; &#125; prev = e; e = next; &#125; return e;&#125; LinkedHashSet前面已经说过LinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。 1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ...... // LinkedHashSet里面有一个LinkedHashMap public LinkedHashSet(int initialCapacity, float loadFactor) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125;\t...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125; LinkedHashMap经典用法LinkedHashMap除了可以保证迭代顺序外，还有一个非常有用的用法: 可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回true，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下: 12345678910111213/** 一个固定大小的FIFO替换策略的缓存 */class FIFOCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt;&#123; private final int cacheSize; public FIFOCache(int cacheSize)&#123; this.cacheSize = cacheSize; &#125; // 当Entry个数超过cacheSize时，删除最老的Entry @Override protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return size() &gt; cacheSize; &#125;&#125;","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"6.Map - HashSet & HashMap 源码解析","path":"/2023/12/25/6-Map-HashSet-HashMap-源码解析/","content":"本文主要对Map - HashSet &amp; HashMap进行源码解析。 Java7 HashMap概述之所以把HashSet和HashMap放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说HashSet里面有一个HashMap(适配器模式)。因此本文将重点分析HashMap。 HashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素；除该类未实现同步外，其余跟Hashtable大致相同；跟TreeMap不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个HashMap的顺序可能会不同。 根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。Java7 *HashMap*采用的是冲突链表方式。 从上图容易看出，如果选择合适的哈希函数，put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。 有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity*load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。 将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: hashCode()和equals()。**hashCode()方法决定了对象会被放到哪个bucket里，当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override** hashCode()和equals()方法。 get()get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。 上图中hash(k)&amp;(table.length-1)等价于hash(k)%table.length，原因是HashMap要求table.length必须是2的指数，因此table.length-1就是二进制低位全是1，跟hash(k)相与会将哈希值的高位全抹掉，剩下的就是余数了。 1234567891011121314//getEntry()方法final Entry&lt;K,V&gt; getEntry(Object key) &#123;\t......\tint hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-1)];//得到冲突链表 e != null; e = e.next) &#123;//依次遍历冲突链表中的每个entry Object k; //依据equals()方法判断是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put()put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。 123456789101112//addEntry()void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//自动扩容，并重新哈希 hash = (null != key) ? hash(key) : 0; bucketIndex = hash &amp; (table.length-1);//hash%table.length &#125; //在冲突链表头部插入新的entry Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; remove()remove(Object key)的作用是删除key值对应的entry，该方法的具体逻辑是在removeEntryForKey(Object key)里实现的。removeEntryForKey()方法会首先找到key值对应的entry，然后删除该entry(修改链表的相应引用)。查找过程跟getEntry()过程类似。 123456789101112131415161718192021//removeEntryForKey()final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;\t......\tint hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length);//hash&amp;(table.length-1) Entry&lt;K,V&gt; prev = table[i];//得到冲突链表 Entry&lt;K,V&gt; e = prev; while (e != null) &#123;//遍历冲突链表 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;//找到要删除的entry modCount++; size--; if (prev == e) table[i] = next;//删除的是冲突链表的第一个entry else prev.next = next; return e; &#125; prev = e; e = next; &#125; return e;&#125; Java8 HashMapJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 来一张图简单示意一下吧： 注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。 下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。 Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。 我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。 put 过程分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作// 第五个参数 evict 我们这里不关心final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度 // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123;// 数组该位置有数据 Node&lt;K,V&gt; e; K k; // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; // 到这里，说明数组该位置上是一个链表 for (int binCount = 0; ; ++binCount) &#123; // 插入到链表的最后面(Java7 是插入到链表的最前面) if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个 // 会触发下面的 treeifyBin，也就是将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals) if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node break; p = e; &#125; &#125; // e!=null 说明存在旧值的key与要插入的key&quot;相等&quot; // 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。 数组扩容resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 对应数组扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 将数组大小扩大一倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 将阈值扩大一倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候 newCap = oldThr; else &#123;// 对应使用 new HashMap() 初始化后，第一次 put 的时候 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 用新的数组大小初始化新的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可 if (oldTab != null) &#123; // 开始遍历原数组，进行数据迁移。 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果是红黑树，具体我们就不展开了 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 这块是处理链表的情况， // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序 // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; // 第一条链表 newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; // 第二条链表的新的位置是 j + oldCap，这个很好理解 newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; get 过程分析相对于 put 来说，get 真的太简单了。 计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1) 判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步 判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步 遍历链表，直到找到相等(&#x3D;&#x3D;或equals)的 key 123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 判断第一个节点是不是就是需要的 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 判断是否是红黑树 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 链表遍历 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; HashSet前面已经说过HashSet是对HashMap的简单包装，对HashSet的函数调用都会转换成合适的HashMap方法，因此HashSet的实现非常简单，只有不到300行代码。这里不再赘述。 12345678910111213141516//HashSet是对HashMap的简单包装public class HashSet&lt;E&gt;&#123;\t......\tprivate transient HashMap&lt;E,Object&gt; map;//HashSet里面有一个HashMap // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; ...... public boolean add(E e) &#123;//简单的方法转换 return map.put(e, PRESENT)==null; &#125; ......&#125;","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"5.Collection - PriorityQueue源码解析","path":"/2023/12/25/5-Collection-PriorityQueue源码解析/","content":"本文主要对Collection - PriorityQueue进行源码解析。 概述前面以Java ArrayDeque为例讲解了Stack和Queue，其实还有一种特殊的队列叫做PriorityQueue，即优先队列。优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。 Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。 上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系: 123leftNo = parentNo*2+1rightNo = parentNo*2+2parentNo = (nodeNo-1)/2 通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。 PriorityQueue的peek()和element操作是常数时间，add(), offer(), 无参数的remove()以及poll()方法的时间复杂度都是*log(N)*。 方法剖析add()和offer()add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回false。对于PriorityQueue这两个方法其实没什么差别。 新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。 123456789101112131415//offer(E e)public boolean offer(E e) &#123; if (e == null)//不允许放入null元素 throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1);//自动扩容 size = i + 1; if (i == 0)//队列原来为空，这是插入的第一个元素 queue[0] = e; else siftUp(i, e);//调整 return true;&#125; 上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。 123456789101112//siftUp()private void siftUp(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1;//parentNo = (nodeNo-1)/2 Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0)//调用比较器的比较方法 break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 新加入的元素x可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为** : 从k指定的位置开始，将x逐层与当前点的parent进行比较并交换，直到满足x &gt;= queue[parent]为止**。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。 element()和peek()element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回null。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，0下标处的那个元素既是堆顶元素。所以直接返回数组0下标处的那个元素即可。 代码也就非常简洁: 123456//peek()public E peek() &#123; if (size == 0) return null; return (E) queue[0];//0下标处的那个元素就是最小的那个&#125; remove()和poll()remove()和poll()方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回null。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。 123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0];//0下标处的那个元素就是最小的那个 E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x);//调整 return result;&#125; 上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素(也就是最小的那个元素)。重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。 123456789101112131415161718//siftDown()private void siftDown(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标 int child = (k &lt;&lt; 1) + 1;//leftNo = parentNo*2+1 Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c;//然后用c取代原来的值 k = child; &#125; queue[k] = x;&#125; remove(Object o)remove(Object o)方法用于删除队列中跟o相等的某一个元素(如果有多个相等，只删除一个)，该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，remove(Object o)可以分为2种情况: 1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。 具体代码如下: 1234567891011121314151617//remove(Object o)public boolean remove(Object o) &#123;\t//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标 int i = indexOf(o); if (i == -1) return false; int s = --size; if (s == i) //情况1 queue[i] = null; else &#123; E moved = (E) queue[s]; queue[s] = null; siftDown(i, moved);//情况2 ...... &#125; return true;&#125; 参考 深入理解Java PriorityQueue 结合源码对PriorityQueue进行讲解 http://www.cnblogs.com/CarpenterLee/p/5488070.html","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"4.Collection - Stack & Queue 源码解析","path":"/2023/12/25/4-Collection-Stack-Queue-源码解析/","content":"本文主要对Collection - Stack &amp; Queue进行源码解析。 Stack &amp; Queue概述Java里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了(次选是LinkedList)。 QueueQueue接口继承自Collection接口，除了最基本的Collection的方法之外，它还支持额外的insertion, extraction和inspection操作。这里有两组格式，共6个方法，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。 Throws exception Returns special value Insert add(e) offer(e) Remove remove() poll() Examine element() peek() DequeDeque是”double ended queue”, 表示双向的队列，英文读作”deck”. Deque 继承自 Queue接口，除了支持Queue的方法之外，还支持insert, remove和examine操作，由于Deque是双向的，所以可以对队列的头和尾都进行操作，它同时也支持两组格式，一组是抛出异常的实现；另外一组是返回值的实现(没有则返回null)。共12个方法如下: First Element - Head Last Element - Tail Throws exception Special value Throws exception Special value Insert addFirst(e) offerFirst(e) addLast(e) offerLast(e) Remove removeFirst() pollFirst() removeLast() pollLast() Examine getFirst() peekFirst() getLast() peekLast() 当把Deque当做FIFO的queue来使用时，元素是从deque的尾部添加，从头部进行删除的； 所以deque的部分方法是和queue是等同的。具体如下: Queue Method Equivalent Deque Method add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() Deque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了Deque与Queue相对应的接口: Queue Method Equivalent Deque Method 说明 add(e) addLast(e) 向队尾插入元素，失败则抛出异常 offer(e) offerLast(e) 向队尾插入元素，失败则返回false remove() removeFirst() 获取并删除队首元素，失败则抛出异常 poll() pollFirst() 获取并删除队首元素，失败则返回null element() getFirst() 获取但不删除队首元素，失败则抛出异常 peek() peekFirst() 获取但不删除队首元素，失败则返回null 下表列出了Deque与Stack对应的接口: Stack Method Equivalent Deque Method 说明 push(e) addFirst(e) 向栈顶插入元素，失败则抛出异常 无 offerFirst(e) 向栈顶插入元素，失败则返回false pop() removeFirst() 获取并删除栈顶元素，失败则抛出异常 无 pollFirst() 获取并删除栈顶元素，失败则返回null peek() getFirst() 获取但不删除栈顶元素，失败则抛出异常 无 peekFirst() 获取但不删除栈顶元素，失败则返回null 上面两个表共定义了Deque的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值(false或null)。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。虽然*Deque*的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看。明白了这一点讲解起来就会非常简单。 ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，加之上一篇已经讲解过LinkedList，本文将着重讲解ArrayDeque的具体实现。 从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即**循环数组(circular array)*，也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque*是非线程安全的(not thread-safe)，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。 上图中我们看到，**head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位**。因为是循环数组，所以head不一定总等于0，tail也不一定总是比head大。 方法剖析addFirst()addFirst(E e)的作用是在Deque的首端插入元素，也就是在head的前面插入元素，在空间足够且下标没有越界的情况下，只需要将elements[--head] = e即可。 实际需要考虑: 1.空间是否够用，以及2.下标是否越界的问题。上图中，如果head为0之后接着调用addFirst()，虽然空余空间还够用，但head为-1，下标越界了。下列代码很好的解决了这两个问题。 12345678//addFirst(E e)public void addFirst(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e;//2.下标是否越界 if (head == tail)//1.空间是否够用 doubleCapacity();//扩容&#125; 上述代码我们看到，空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。 下标越界的处理解决起来非常简单，head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。 下面再说说扩容函数doubleCapacity()，其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示: 图中我们看到，复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。 12345678910111213141516//doubleCapacity()private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素的个数 int newCapacity = n &lt;&lt; 1;//原空间的2倍 if (newCapacity &lt; 0) throw new IllegalStateException(&quot;Sorry, deque too big&quot;); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制右半部分，对应上图中绿色部分 System.arraycopy(elements, 0, a, r, p);//复制左半部分，对应上图中灰色部分 elements = (E[])a; head = 0; tail = n;&#125; addLast()addLast(E e)的作用是在Deque的尾端插入元素，也就是在tail的位置插入元素，由于tail总是指向下一个可以插入的空位，因此只需要elements[tail] = e;即可。插入完成后再检查空间，如果空间已经用光，则调用doubleCapacity()进行扩容。 1234567public void addLast(E e) &#123; if (e == null)//不允许放入null throw new NullPointerException(); elements[tail] = e;//赋值 if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)//下标越界处理 doubleCapacity();//扩容&#125; 下标越界处理方式addFirt()中已经讲过，不再赘述。 pollFirst()pollFirst()的作用是删除并返回Deque首端元素，也即是head位置处的元素。如果容器不空，只需要直接返回elements[head]即可，当然还需要处理下标的问题。由于ArrayDeque中不允许放入null，当elements[head] == null时，意味着容器为空。 123456789public E pollFirst() &#123; int h = head; E result = elements[head]; if (result == null)//null值意味着deque为空 return null; elements[h] = null;//let GC work head = (head + 1) &amp; (elements.length - 1);//下标越界处理 return result;&#125; pollLast()pollLast()的作用是删除并返回Deque尾端元素，也即是tail位置前面的那个元素。 123456789public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1);//tail的上一个位置是最后一个元素 E result = elements[t]; if (result == null)//null值意味着deque为空 return null; elements[t] = null;//let GC work tail = t; return result;&#125; peekFirst()peekFirst()的作用是返回但不删除Deque首端元素，也即是head位置处的元素，直接返回elements[head]即可。 123public E peekFirst() &#123; return elements[head]; // elements[head] is null if deque empty&#125; peekLast()peekLast()的作用是返回但不删除Deque尾端元素，也即是tail位置前面的那个元素。 123public E peekLast() &#123; return elements[(tail - 1) &amp; (elements.length - 1)];&#125;","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"3.Collection - LinkedList源码解析","path":"/2023/12/25/3-Collection-LinkedList源码解析/","content":"本文主要对Collection - LinkedList进行源码解析。 概述LinkedList同时实现了List接口和Deque接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列(Queue)，同时又可以看作一个栈(Stack)。这样看来，LinkedList简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用LinkedList，一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类(它是个接口名字)。关于栈或队列，现在的首选是ArrayDeque，它有着比LinkedList(当作栈或队列使用时)有着更好的性能。 LinkedList的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率LinkedList没有实现同步(synchronized)，如果需要多个线程并发访问，可以先采用Collections.synchronizedList()方法对其进行包装。 LinkedList实现底层数据结构LinkedList底层通过双向链表实现，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是之间解跟List接口相关的函数，而将Queue和Stack以及Deque相关的知识放在下一节讲。双向链表的每个节点用内部类Node表示。LinkedList通过first和last引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候first和last都指向null。 123456789101112131415transient int size = 0;/** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */transient Node&lt;E&gt; first;/** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */transient Node&lt;E&gt; last; 其中Node是私有的内部类: 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造函数123456789101112131415161718/** * Constructs an empty list. */public LinkedList() &#123;&#125;/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#x27;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; getFirst(), getLast()获取第一个元素， 和获取最后一个元素: 12345678910111213141516171819202122232425/** * Returns the first element in this list. * * @return the first element in this list * @throws NoSuchElementException if this list is empty */public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;/** * Returns the last element in this list. * * @return the last element in this list * @throws NoSuchElementException if this list is empty */public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; removeFirst(), removeLast(), remove(e), remove(index)remove()方法也有两个版本，一个是删除跟指定元素相等的第一个元素remove(Object o)，另一个是删除指定下标处的元素remove(int index)。 删除元素 - 指的是删除第一次出现的这个元素, 如果没有这个元素，则返回false；判断的依据是equals方法， 如果equals，则直接unlink这个node；由于LinkedList可存放null元素，故也可以删除第一次出现null的元素； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;/** * Unlinks non-null node x. */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123;// 第一个元素 first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123;// 最后一个元素 last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; // GC size--; modCount++; return element;&#125; remove(int index)使用的是下标计数， 只需要判断该index是否有元素即可，如果有则直接unlink这个node。 12345678910111213/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125; 删除head元素: 1234567891011121314151617181920212223242526272829303132/** * Removes and returns the first element from this list. * * @return the first element from this list * @throws NoSuchElementException if this list is empty */public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;/** * Unlinks non-null first node f. */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125; 删除last元素: 12345678910111213141516171819202122232425262728293031/** * Removes and returns the last element from this list. * * @return the last element from this list * @throws NoSuchElementException if this list is empty */ public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125; /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; add()add()*方法有两个版本，一个是add(E e)，该方法在*LinkedList的末尾插入元素，因为有last指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是add(int index, E element)，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。 123456789101112131415161718192021222324252627/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; linkLast(e); return true;&#125;/** * Links e as last element. */void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; add(int index, E element), 当index&#x3D;&#x3D;size时，等同于add(E e); 如果不是，则分两步: 1.先根据index找到要插入的位置,即node(index)方法；2.修改引用，完成插入操作。 1234567891011121314151617/** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 上面代码中的node(int index)函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件index &lt; (size &gt;&gt; 1)，也即是index是靠近前端还是后端。从这里也可以看出，linkedList通过index检索元素的效率没有arrayList高。 123456789101112131415161718/** * Returns the (non-null) Node at the specified element index. */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; addAll()addAll(index, c) 实现方式并不是直接调用add(index,e)来实现，主要是因为效率的问题，另一个是fail-fast中modCount只会增加1次； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the specified * collection&#x27;s iterator. The behavior of this operation is undefined if * the specified collection is modified while the operation is in * progress. (Note that this will occur if the specified collection is * this list, and it&#x27;s nonempty.) * * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&#x27;s iterator. * * @param index index at which to insert the first element * from the specified collection * @param c collection containing elements to be added to this list * @return &#123;@code true&#125; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(&quot;unchecked&quot;) E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; clear()为了让GC更快可以回收放置的元素，需要将node之间的引用关系赋空。 1234567891011121314151617181920/** * Removes all of the elements from this list. * The list will be empty after this call returns. */public void clear() &#123; // Clearing all of the links between nodes is &quot;unnecessary&quot;, but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++;&#125; Positional Access 方法通过index获取元素 1234567891011/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 将某个位置的元素重新赋值: 12345678910111213141516/** * Replaces the element at the specified position in this list with the * specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 将元素插入到指定index位置: 1234567891011121314151617/** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; 删除指定位置的元素: 12345678910111213/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125; 其它位置的方法: 123456789101112131415161718192021222324252627282930313233/** * Tells if the argument is the index of an existing element. */private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;/** * Tells if the argument is the index of a valid position for an * iterator or an add operation. */private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;/** * Constructs an IndexOutOfBoundsException detail message. * Of the many possible refactorings of the error handling code, * this &quot;outlining&quot; performs best with both server and client VMs. */private String outOfBoundsMsg(int index) &#123; return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;&#125;private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 查找操作查找操作的本质是查找元素的下标: 查找第一次出现的index, 如果找不到返回-1； 12345678910111213141516171819202122232425262728/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the first occurrence of the specified element in * this list, or -1 if this list does not contain the element */public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; 查找最后一次出现的index, 如果找不到返回-1； 12345678910111213141516171819202122232425262728/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &#123;@code i&#125; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the last occurrence of the specified element in * this list, or -1 if this list does not contain the element */public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125; Queue 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list, or &#123;@code null&#125; if this list is empty * @since 1.5 */public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;/** * Retrieves, but does not remove, the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E element() &#123; return getFirst();&#125;/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list, or &#123;@code null&#125; if this list is empty * @since 1.5 */public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;/** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */public E remove() &#123; return removeFirst();&#125;/** * Adds the specified element as the tail (last element) of this list. * * @param e the element to add * @return &#123;@code true&#125; (as specified by &#123;@link Queue#offer&#125;) * @since 1.5 */public boolean offer(E e) &#123; return add(e);&#125; Deque 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144/** * Inserts the specified element at the front of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerFirst&#125;) * @since 1.6 */public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;/** * Inserts the specified element at the end of this list. * * @param e the element to insert * @return &#123;@code true&#125; (as specified by &#123;@link Deque#offerLast&#125;) * @since 1.6 */public boolean offerLast(E e) &#123; addLast(e); return true;&#125;/** * Retrieves, but does not remove, the first element of this list, * or returns &#123;@code null&#125; if this list is empty. * * @return the first element of this list, or &#123;@code null&#125; * if this list is empty * @since 1.6 */public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item; &#125;/** * Retrieves, but does not remove, the last element of this list, * or returns &#123;@code null&#125; if this list is empty. * * @return the last element of this list, or &#123;@code null&#125; * if this list is empty * @since 1.6 */public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125;/** * Retrieves and removes the first element of this list, * or returns &#123;@code null&#125; if this list is empty. * * @return the first element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;/** * Retrieves and removes the last element of this list, * or returns &#123;@code null&#125; if this list is empty. * * @return the last element of this list, or &#123;@code null&#125; if * this list is empty * @since 1.6 */public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125;/** * Pushes an element onto the stack represented by this list. In other * words, inserts the element at the front of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addFirst&#125;. * * @param e the element to push * @since 1.6 */public void push(E e) &#123; addFirst(e);&#125;/** * Pops an element from the stack represented by this list. In other * words, removes and returns the first element of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #removeFirst()&#125;. * * @return the element at the front of this list (which is the top * of the stack represented by this list) * @throws NoSuchElementException if this list is empty * @since 1.6 */public E pop() &#123; return removeFirst();&#125;/** * Removes the first occurrence of the specified element in this * list (when traversing the list from head to tail). If the list * does not contain the element, it is unchanged. * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if the list contained the specified element * @since 1.6 */public boolean removeFirstOccurrence(Object o) &#123; return remove(o);&#125;/** * Removes the last occurrence of the specified element in this * list (when traversing the list from head to tail). If the list * does not contain the element, it is unchanged. * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if the list contained the specified element * @since 1.6 */public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 参考 Java LinkedList源码剖析 结合源码对LinkedList进行讲解 http://www.cnblogs.com/CarpenterLee/p/5457150.html","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"2.Collection - ArrayList 源码解析","path":"/2023/12/25/2-Collection-ArrayList-源码解析/","content":"本文主要对Collection - ArrayList进行源码解析。 概述ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。除该类未实现同步外，其余跟Vector大致相同。每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。 size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。 ArrayList的实现底层数据结构1234567891011121314/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection&#x27;s * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 自动扩容每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。 数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It&#x27;s already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; add(), addAll()跟C++ 的vector不同，ArrayList没有push_back()方法，对应的方法是add(E e)，ArrayList也没有insert()方法，对应的方法是add(int index, E e)。这两个方法都是向容器中添加新元素，这可能会导致capacity不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过grow()方法完成的。 123456789101112131415161718192021222324252627282930/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;/** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; add(int index, E e)需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。 addAll()方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的addAll(Collection&lt;? extends E&gt; c)方法，一个是从指定位置开始插入的addAll(int index, Collection&lt;? extends E&gt; c)方法。跟add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection&#x27;s Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125;/** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection&#x27;s iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; set()既然底层是一个数组ArrayList的set()方法也就变得非常简单，直接对数组的指定位置赋值即可。 123456public E set(int index, E element) &#123; rangeCheck(index);//下标越界检查 E oldValue = elementData(index); elementData[index] = element;//赋值到指定位置，复制的仅仅是引用 return oldValue;&#125; get()get()方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。 1234public E get(int index) &#123; rangeCheck(index); return (E) elementData[index];//注意类型转换&#125; remove()remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋null值。 12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; //清除该位置的引用，让GC起作用 return oldValue;&#125; 关于Java GC这里需要特别说明一下，有了垃圾收集器并不意味着一定不会有内存泄漏。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋null值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。 trimToSize()ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现。代码如下: 12345678910111213/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list&#x27;s current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; indexOf(), lastIndexOf()获取元素的第一次出现的index: 12345678910111213141516171819/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 获取元素的最后一次出现的index: 12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; Fail-Fast机制:ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 参考 深入Java集合学习系列: ArrayList的实现原理 http://zhangshixi.iteye.com/blog/674856 Java ArrayList源码剖析 结合源码对ArrayList进行讲解 http://www.cnblogs.com/CarpenterLee/p/5419880.html","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"1.Collection 类关系图","path":"/2023/12/25/1-Collection-类关系图/","content":"本文主要介绍JDK中Collection和Map相关知识体系，后续章节将对主要对类进行源码解读。@pdai 知识体系结构 介绍容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是: 降低编程难度 提高程序性能 提高API间的互操作性 降低学习难度 降低设计和实现相关API的难度 增加程序的重用性 Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 Collection 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。 SetTreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 ListArrayList基于动态数组实现，支持随机访问。 Vector和 ArrayList 类似，但它是线程安全的。 LinkedList基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 QueueLinkedList可以用它来实现双向队列。 PriorityQueue基于堆结构实现，可以用它来实现优先队列。 MapTreeMap基于红黑树实现。 HashMap基于哈希表实现。 HashTable和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。 参考内容 CarpenterLee&#x2F;JCFInternals https://github.com/CarpenterLee/JCFInternals","tags":["Java","Collection集合框架"],"categories":["Java","Collection集合框架"]},{"title":"8.Java常用机制 - SPI机制详解","path":"/2023/12/25/8-Java常用机制-SPI机制详解/","content":"SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用。 什么是SPI机制SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。 SPI整体机制图如下： 当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader。 SPI机制的简单示例 网上找了个例子：这里 我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。 先定义好接口 123public interface Search &#123; public List&lt;String&gt; searchDoc(String keyword); &#125; 文件搜索实现 1234567public class FileSearch implements Search&#123; @Override public List&lt;String&gt; searchDoc(String keyword) &#123; System.out.println(&quot;文件搜索 &quot;+keyword); return null; &#125;&#125; 数据库搜索实现 1234567public class DatabaseSearch implements Search&#123; @Override public List&lt;String&gt; searchDoc(String keyword) &#123; System.out.println(&quot;数据搜索 &quot;+keyword); return null; &#125;&#125; resources 接下来可以在resources下新建META-INF&#x2F;services&#x2F;目录，然后新建接口全限定名的文件：com.cainiao.ys.spi.learn.Search，里面加上我们需要用到的实现类 1com.cainiao.ys.spi.learn.FileSearch 测试方法 12345678910public class TestCase &#123; public static void main(String[] args) &#123; ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class); Iterator&lt;Search&gt; iterator = s.iterator(); while (iterator.hasNext()) &#123; Search search = iterator.next(); search.searchDoc(&quot;hello world&quot;); &#125; &#125;&#125; 可以看到输出结果：文件搜索 hello world 如果在com.cainiao.ys.spi.learn.Search文件里写上两个实现类，那最后的输出结果就是两行了。 这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去META-INF/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。 这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。 SPI机制的广泛应用SPI机制 - JDBC DriverManager 在JDBC4.0之前，我们开发有连接数据库的时候，通常会用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)这句先加载数据库相关的驱动，然后再进行获取连接等的操作。而JDBC4.0之后不需要用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)来加载驱动，直接获取连接就可以了，现在这种方式就是使用了Java的SPI扩展机制来实现。 JDBC接口定义首先在java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商来提供的。 mysql实现在mysql的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF/services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。 postgresql实现同样在postgresql的jar包postgresql-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是postgresql对Java的java.sql.Driver的实现。 使用方法上面说了，现在使用SPI扩展来加载具体的驱动，我们在Java中写连接数据库的代码的时候，不需要再使用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)来加载驱动了，而是直接使用如下代码： 123String url = &quot;jdbc:xxxx://xxxx:xxxx/xxxx&quot;;Connection conn = DriverManager.getConnection(url,username,password);..... 这里并没有涉及到spi的使用，接着看下面的解析。 源码实现上面的使用方法，就是我们普通的连接数据库的代码，并没有涉及到SPI的东西，但是有一点我们可以确定的是，我们没有写有关具体驱动的硬编码Class.forName(&quot;com.mysql.jdbc.Driver&quot;)！ 上面的代码可以直接获取数据库连接进行操作，但是跟SPI有啥关系呢？上面代码没有了加载驱动的代码，我们怎么去确定使用哪个数据库连接的驱动呢？这里就涉及到使用Java的SPI扩展机制来查找相关驱动的东西了，关于驱动的查找其实都在DriverManager中，DriverManager是Java中的实现，用来获取数据库连接，在DriverManager中有一个静态代码块如下： 1234static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;);&#125; 可以看到是加载实例化驱动的，接着看loadInitialDrivers方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(&quot;jdbc.drivers&quot;); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; //使用SPI的ServiceLoader来加载接口的实现 ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); if (drivers == null || drivers.equals(&quot;&quot;)) &#123; return; &#125; String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(&quot;DriverManager.Initialize: loading &quot; + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(&quot;DriverManager.Initialize: load failed: &quot; + ex); &#125; &#125;&#125; 上面的代码主要步骤是： 从系统变量中获取有关驱动的定义。 使用SPI来获取驱动的实现。 遍历使用SPI获取到的具体实现，实例化各个实现类。 根据第一步获取到的驱动列表来实例化具体实现类。 我们主要关注2,3步，这两步是SPI的用法，首先看第二步，使用SPI来获取驱动的实现，对应的代码是： 1ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); 这里没有去META-INF/services目录下查找配置文件，也没有加载具体实现类，做的事情就是封装了我们的接口类型和类加载器，并初始化了一个迭代器。 接着看第三步，遍历使用SPI获取到的具体实现，实例化各个实现类，对应的代码如下： 123456//获取迭代器Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();//遍历所有的驱动实现while(driversIterator.hasNext()) &#123; driversIterator.next();&#125; 在遍历的时候，首先调用driversIterator.hasNext()方法，这里会搜索classpath下以及jar包中所有的META-INF/services目录下的java.sql.Driver文件，并找到文件中的实现类的名字，此时并没有实例化具体的实现类（ServiceLoader具体的源码实现在下面）。 然后是调用driversIterator.next();方法，此时就会根据驱动名字具体实例化各个实现类了。现在驱动就被找到并实例化了。 可以看下截图，我在测试项目中添加了两个jar包，mysql-connector-java-6.0.6.jar和postgresql-42.0.0.0.jar，跟踪到DriverManager中之后： 可以看到此时迭代器中有两个驱动，mysql和postgresql的都被加载了。 SPI机制 - Common-Logging common-logging（也称Jakarta Commons Logging，缩写 JCL）是常用的日志库门面，具体日志库相关可以看这篇。我们看下它是怎么解耦的。 首先，日志实例是通过LogFactory的getLog(String)方法创建的： 123public static getLog(Class clazz) throws LogConfigurationException &#123; return getFactory().getInstance(clazz);&#125; LogFatory是一个抽象类，它负责加载具体的日志实现，分析其Factory.getFactory()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235public static org.apache.commons.logging.LogFactory getFactory() throws LogConfigurationException &#123; // Identify the class loader we will be using ClassLoader contextClassLoader = getContextClassLoaderInternal(); if (contextClassLoader == null) &#123; // This is an odd enough situation to report about. This // output will be a nuisance on JDK1.1, as the system // classloader is null in that environment. if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;Context classloader is null.&quot;); &#125; &#125; // Return any previously registered factory for this class loader org.apache.commons.logging.LogFactory factory = getCachedFactory(contextClassLoader); if (factory != null) &#123; return factory; &#125; if (isDiagnosticsEnabled()) &#123; logDiagnostic( &quot;[LOOKUP] LogFactory implementation requested for the first time for context classloader &quot; + objectId(contextClassLoader)); logHierarchy(&quot;[LOOKUP] &quot;, contextClassLoader); &#125; // Load properties file. // // If the properties file exists, then its contents are used as // &quot;attributes&quot; on the LogFactory implementation class. One particular // property may also control which LogFactory concrete subclass is // used, but only if other discovery mechanisms fail.. // // As the properties file (if it exists) will be used one way or // another in the end we may as well look for it first. // classpath根目录下寻找commons-logging.properties Properties props = getConfigurationFile(contextClassLoader, FACTORY_PROPERTIES); // Determine whether we will be using the thread context class loader to // load logging classes or not by checking the loaded properties file (if any). // classpath根目录下commons-logging.properties是否配置use_tccl ClassLoader baseClassLoader = contextClassLoader; if (props != null) &#123; String useTCCLStr = props.getProperty(TCCL_KEY); if (useTCCLStr != null) &#123; // The Boolean.valueOf(useTCCLStr).booleanValue() formulation // is required for Java 1.2 compatibility. if (Boolean.valueOf(useTCCLStr).booleanValue() == false) &#123; // Don&#x27;t use current context classloader when locating any // LogFactory or Log classes, just use the class that loaded // this abstract class. When this class is deployed in a shared // classpath of a container, it means webapps cannot deploy their // own logging implementations. It also means that it is up to the // implementation whether to load library-specific config files // from the TCCL or not. baseClassLoader = thisClassLoader; &#125; &#125; &#125; // 这里真正开始决定使用哪个factory // 首先，尝试查找vm系统属性org.apache.commons.logging.LogFactory，其是否指定factory // Determine which concrete LogFactory subclass to use. // First, try a global system property if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] Looking for system property [&quot; + FACTORY_PROPERTY + &quot;] to define the LogFactory subclass to use...&quot;); &#125; try &#123; String factoryClass = getSystemProperty(FACTORY_PROPERTY, null); if (factoryClass != null) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] Creating an instance of LogFactory class &#x27;&quot; + factoryClass + &quot;&#x27; as specified by system property &quot; + FACTORY_PROPERTY); &#125; factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); &#125; else &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] No system property [&quot; + FACTORY_PROPERTY + &quot;] defined.&quot;); &#125; &#125; &#125; catch (SecurityException e) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] A security exception occurred while trying to create an&quot; + &quot; instance of the custom factory class&quot; + &quot;: [&quot; + trim(e.getMessage()) + &quot;]. Trying alternative implementations...&quot;); &#125; // ignore &#125; catch (RuntimeException e) &#123; // This is not consistent with the behaviour when a bad LogFactory class is // specified in a services file. // // One possible exception that can occur here is a ClassCastException when // the specified class wasn&#x27;t castable to this LogFactory type. if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] An exception occurred while trying to create an&quot; + &quot; instance of the custom factory class&quot; + &quot;: [&quot; + trim(e.getMessage()) + &quot;] as specified by a system property.&quot;); &#125; throw e; &#125; // 第二，尝试使用java spi服务发现机制，载META-INF/services下寻找org.apache.commons.logging.LogFactory实现 // Second, try to find a service by using the JDK1.3 class // discovery mechanism, which involves putting a file with the name // of an interface class in the META-INF/services directory, where the // contents of the file is a single line specifying a concrete class // that implements the desired interface. if (factory == null) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] Looking for a resource file of name [&quot; + SERVICE_ID + &quot;] to define the LogFactory subclass to use...&quot;); &#125; try &#123; // META-INF/services/org.apache.commons.logging.LogFactory, SERVICE_ID final InputStream is = getResourceAsStream(contextClassLoader, SERVICE_ID); if (is != null) &#123; // This code is needed by EBCDIC and other strange systems. // It&#x27;s a fix for bugs reported in xerces BufferedReader rd; try &#123; rd = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;)); &#125; catch (java.io.UnsupportedEncodingException e) &#123; rd = new BufferedReader(new InputStreamReader(is)); &#125; String factoryClassName = rd.readLine(); rd.close(); if (factoryClassName != null &amp;&amp; !&quot;&quot;.equals(factoryClassName)) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] Creating an instance of LogFactory class &quot; + factoryClassName + &quot; as specified by file &#x27;&quot; + SERVICE_ID + &quot;&#x27; which was present in the path of the context classloader.&quot;); &#125; factory = newFactory(factoryClassName, baseClassLoader, contextClassLoader); &#125; &#125; else &#123; // is == null if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] No resource file with name &#x27;&quot; + SERVICE_ID + &quot;&#x27; found.&quot;); &#125; &#125; &#125; catch (Exception ex) &#123; // note: if the specified LogFactory class wasn&#x27;t compatible with LogFactory // for some reason, a ClassCastException will be caught here, and attempts will // continue to find a compatible class. if (isDiagnosticsEnabled()) &#123; logDiagnostic( &quot;[LOOKUP] A security exception occurred while trying to create an&quot; + &quot; instance of the custom factory class&quot; + &quot;: [&quot; + trim(ex.getMessage()) + &quot;]. Trying alternative implementations...&quot;); &#125; // ignore &#125; &#125; // 第三，尝试从classpath根目录下的commons-logging.properties中查找org.apache.commons.logging.LogFactory属性指定的factory // Third try looking into the properties file read earlier (if found) if (factory == null) &#123; if (props != null) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic( &quot;[LOOKUP] Looking in properties file for entry with key &#x27;&quot; + FACTORY_PROPERTY + &quot;&#x27; to define the LogFactory subclass to use...&quot;); &#125; String factoryClass = props.getProperty(FACTORY_PROPERTY); if (factoryClass != null) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic( &quot;[LOOKUP] Properties file specifies LogFactory subclass &#x27;&quot; + factoryClass + &quot;&#x27;&quot;); &#125; factory = newFactory(factoryClass, baseClassLoader, contextClassLoader); // TODO: think about whether we need to handle exceptions from newFactory &#125; else &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] Properties file has no entry specifying LogFactory subclass.&quot;); &#125; &#125; &#125; else &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic(&quot;[LOOKUP] No properties file available to determine&quot; + &quot; LogFactory subclass from..&quot;); &#125; &#125; &#125; // 最后，使用后备factory实现，org.apache.commons.logging.impl.LogFactoryImpl // Fourth, try the fallback implementation class if (factory == null) &#123; if (isDiagnosticsEnabled()) &#123; logDiagnostic( &quot;[LOOKUP] Loading the default LogFactory implementation &#x27;&quot; + FACTORY_DEFAULT + &quot;&#x27; via the same classloader that loaded this LogFactory&quot; + &quot; class (ie not looking in the context classloader).&quot;); &#125; // Note: unlike the above code which can try to load custom LogFactory // implementations via the TCCL, we don&#x27;t try to load the default LogFactory // implementation via the context classloader because: // * that can cause problems (see comments in newFactory method) // * no-one should be customising the code of the default class // Yes, we do give up the ability for the child to ship a newer // version of the LogFactoryImpl class and have it used dynamically // by an old LogFactory class in the parent, but that isn&#x27;t // necessarily a good idea anyway. factory = newFactory(FACTORY_DEFAULT, thisClassLoader, contextClassLoader); &#125; if (factory != null) &#123; /** * Always cache using context class loader. */ cacheFactory(contextClassLoader, factory); if (props != null) &#123; Enumeration names = props.propertyNames(); while (names.hasMoreElements()) &#123; String name = (String) names.nextElement(); String value = props.getProperty(name); factory.setAttribute(name, value); &#125; &#125; &#125; return factory;&#125; 可以看出，抽象类LogFactory加载具体实现的步骤如下： 从vm系统属性org.apache.commons.logging.LogFactory 使用SPI服务发现机制，发现org.apache.commons.logging.LogFactory的实现 查找classpath根目录commons-logging.properties的org.apache.commons.logging.LogFactory属性是否指定factory实现 使用默认factory实现，org.apache.commons.logging.impl.LogFactoryImpl LogFactory的getLog()方法返回类型是org.apache.commons.logging.Log接口，提供了从trace到fatal方法。可以确定，如果日志实现提供者只要实现该接口，并且使用继承自org.apache.commons.logging.LogFactory的子类创建Log，必然可以构建一个松耦合的日志系统。 SPI机制 - 插件体系 其实最具spi思想的应该属于插件开发，我们项目中也用到的这种思想，后面再说，这里具体说一下eclipse的插件思想。 Eclipse使用OSGi作为插件系统的基础，动态添加新插件和停止现有插件，以动态的方式管理组件生命周期。 一般来说，插件的文件结构必须在指定目录下包含以下三个文件： META-INF/MANIFEST.MF: 项目基本配置信息，版本、名称、启动器等 build.properties: 项目的编译配置信息，包括，源代码路径、输出路径 plugin.xml：插件的操作配置信息，包含弹出菜单及点击菜单后对应的操作执行类等 当eclipse启动时，会遍历plugins文件夹中的目录，扫描每个插件的清单文件MANIFEST.MF，并建立一个内部模型来记录它所找到的每个插件的信息，就实现了动态添加新的插件。 这也意味着是eclipse制定了一系列的规则，像是文件结构、类型、参数等。插件开发者遵循这些规则去开发自己的插件，eclipse并不需要知道插件具体是怎样开发的，只需要在启动的时候根据配置文件解析、加载到系统里就好了，是spi思想的一种体现。 SPI机制 - Spring中SPI机制在springboot的自动装配过程中，最终会加载META-INF/spring.factories文件，而加载的过程是由SpringFactoriesLoader加载的。从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。 1234567891011121314151617181920public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;// spring.factories文件的格式为：key=value1,value2,value3// 从所有的jar包中找到META-INF/spring.factories文件// 然后从文件中解析出key=factoryClass类名称的所有value值public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); // 取得资源文件的URL Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); // 遍历所有的URL while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); // 根据资源文件URL解析properties文件，得到对应的一组@Configuration类 Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); // 组装数据，并返回 result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result;&#125; SPI机制深入理解 提示 接下来，我们深入理解下SPI相关内容 SPI机制通常怎么使用看完上面的几个例子解析，应该都能知道大概的流程了： 有关组织或者公司定义标准。 具体厂商或者框架开发者实现。 程序猿使用。 定义标准定义标准，就是定义接口。比如接口java.sql.Driver 具体厂商或者框架开发者实现厂商或者框架开发者开发具体的实现： 在META-INF/services目录下定义一个名字为接口全限定名的文件，比如java.sql.Driver文件，文件内容是具体的实现名字，比如me.cxis.sql.MyDriver。 写具体的实现me.cxis.sql.MyDriver，都是对接口Driver的实现。 程序猿使用我们会引用具体厂商的jar包来实现我们的功能： 12345678ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);//获取迭代器Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();//遍历while(driversIterator.hasNext()) &#123; driversIterator.next(); //可以做具体的业务逻辑&#125; 使用规范最后总结一下jdk spi需要遵循的规范 SPI和API的区别是什么 这里实际包含两个问题，第一个SPI和API的区别？第二个什么时候用API，什么时候用SPI？ SPI - “接口”位于“调用方”所在的“包”中 概念上更依赖调用方。 组织上位于调用方所在的包中。 实现位于独立的包中。 常见的例子是：插件模式的插件。 API - “接口”位于“实现方”所在的“包”中 概念上更接近实现方。 组织上位于实现方所在的包中。 实现和接口在一个包中。 参考： difference-between-spi-and-api在新窗口打开 设计原则：小议 SPI 和 API在新窗口打开 SPI机制实现原理不妨看下JDK中ServiceLoader&lt;S&gt;方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259//ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; //查找配置文件的目录 private static final String PREFIX = &quot;META-INF/services/&quot;; //表示要被加载的服务的类或接口 private final Class&lt;S&gt; service; //这个ClassLoader用来定位，加载，实例化服务提供者 private final ClassLoader loader; // 访问控制上下文 private final AccessControlContext acc; // 缓存已经被实例化的服务提供者，按照实例化的顺序存储 private LinkedHashMap&lt;String,S&gt; providers = new LinkedHashMap&lt;&gt;(); // 迭代器 private LazyIterator lookupIterator; //重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机中的情况。 public void reload() &#123; //清空缓存中所有已实例化的服务提供者 providers.clear(); //新建一个迭代器，该迭代器会从头查找和实例化服务提供者 lookupIterator = new LazyIterator(service, loader); &#125; //私有构造器 //使用指定的类加载器和服务创建服务加载器 //如果没有指定类加载器，使用系统类加载器，就是应用类加载器。 private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;); loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload(); &#125; //解析失败处理的方法 private static void fail(Class&lt;?&gt; service, String msg, Throwable cause) throws ServiceConfigurationError &#123; throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg, cause); &#125; private static void fail(Class&lt;?&gt; service, String msg) throws ServiceConfigurationError &#123; throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg); &#125; private static void fail(Class&lt;?&gt; service, URL u, int line, String msg) throws ServiceConfigurationError &#123; fail(service, u + &quot;:&quot; + line + &quot;: &quot; + msg); &#125; //解析服务提供者配置文件中的一行 //首先去掉注释校验，然后保存 //返回下一行行号 //重复的配置项和已经被实例化的配置项不会被保存 private int parseLine(Class&lt;?&gt; service, URL u, BufferedReader r, int lc, List&lt;String&gt; names) throws IOException, ServiceConfigurationError &#123; //读取一行 String ln = r.readLine(); if (ln == null) &#123; return -1; &#125; //#号代表注释行 int ci = ln.indexOf(&#x27;#&#x27;); if (ci &gt;= 0) ln = ln.substring(0, ci); ln = ln.trim(); int n = ln.length(); if (n != 0) &#123; if ((ln.indexOf(&#x27; &#x27;) &gt;= 0) || (ln.indexOf(&#x27;\\t&#x27;) &gt;= 0)) fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;); int cp = ln.codePointAt(0); if (!Character.isJavaIdentifierStart(cp)) fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln); for (int i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123; cp = ln.codePointAt(i); if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != &#x27;.&#x27;)) fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln); &#125; if (!providers.containsKey(ln) &amp;&amp; !names.contains(ln)) names.add(ln); &#125; return lc + 1; &#125; //解析配置文件，解析指定的url配置文件 //使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中去 private Iterator&lt;String&gt; parse(Class&lt;?&gt; service, URL u) throws ServiceConfigurationError &#123; InputStream in = null; BufferedReader r = null; ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(); try &#123; in = u.openStream(); r = new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;)); int lc = 1; while ((lc = parseLine(service, u, r, lc, names)) &gt;= 0); &#125; return names.iterator(); &#125; //服务提供者查找的迭代器 private class LazyIterator implements Iterator&lt;S&gt; &#123; Class&lt;S&gt; service;//服务提供者接口 ClassLoader loader;//类加载器 Enumeration&lt;URL&gt; configs = null;//保存实现类的url Iterator&lt;String&gt; pending = null;//保存实现类的全名 String nextName = null;//迭代器中下一个实现类的全名 private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) &#123; this.service = service; this.loader = loader; &#125; private boolean hasNextService() &#123; if (nextName != null) &#123; return true; &#125; if (configs == null) &#123; try &#123; String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; nextName = pending.next(); return true; &#125; private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; try &#123; c = Class.forName(cn, false, loader); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, &quot;Provider &quot; + cn + &quot; not a subtype&quot;); &#125; try &#123; S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; &#125; public boolean hasNext() &#123; if (acc == null) &#123; return hasNextService(); &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public S next() &#123; if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; //获取迭代器 //返回遍历服务提供者的迭代器 //以懒加载的方式加载可用的服务提供者 //懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成 public Iterator&lt;S&gt; iterator() &#123; return new Iterator&lt;S&gt;() &#123; //按照实例化顺序返回已经缓存的服务提供者实例 Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders = providers.entrySet().iterator(); public boolean hasNext() &#123; if (knownProviders.hasNext()) return true; return lookupIterator.hasNext(); &#125; public S next() &#123; if (knownProviders.hasNext()) return knownProviders.next().getValue(); return lookupIterator.next(); &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; //为指定的服务使用指定的类加载器来创建一个ServiceLoader public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader) &#123; return new ServiceLoader&lt;&gt;(service, loader); &#125; //使用线程上下文的类加载器来创建ServiceLoader public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); &#125; //使用扩展类加载器为指定的服务创建ServiceLoader //只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略 public static &lt;S&gt; ServiceLoader&lt;S&gt; loadInstalled(Class&lt;S&gt; service) &#123; ClassLoader cl = ClassLoader.getSystemClassLoader(); ClassLoader prev = null; while (cl != null) &#123; prev = cl; cl = cl.getParent(); &#125; return ServiceLoader.load(service, prev); &#125; public String toString() &#123; return &quot;java.util.ServiceLoader[&quot; + service.getName() + &quot;]&quot;; &#125;&#125; 首先，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。 其次，LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。 最后，通过反射方法Class.forName()加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(LinkedHashMap&lt;String,S&gt;类型）然后返回实例对象。 所以我们可以看到ServiceLoader不是实例化以后，就去读取配置文件中的具体实现，并进行实例化。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法的时候会去加载配置文件进行解析，调用next方法的时候进行实例化并缓存。 所有的配置文件只会加载一次，服务提供者也只会被实例化一次，重新加载配置文件可使用reload方法。 SPI机制的缺陷通过上面的解析，可以发现，我们使用SPI机制的缺陷： 不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。 获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。 多个并发多线程使用 ServiceLoader 类的实例是不安全的。 参考文章 https://cxis.me/2017/04/17/Java%E4%B8%ADSPI%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top https://zhuanlan.zhihu.com/p/28909673 http://blog.itpub.net/69912579/viewspace-2656555/ https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html https://blog.csdn.net/sakurainluojia/article/details/53534949 https://www.jianshu.com/p/0d196ad23915","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"7.Java 基础 - 反射机制详解","path":"/2023/12/25/7.Java-基础-反射机制详解/","content":"JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了Java 反射的相关知识，希望可以提升你对Java中反射的认知效率。 反射基础RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。 反射就是把java类中的各种成分映射成一个个的Java对象 例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。 这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。 Class类Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(&quot;类名&quot;)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。 1234567891011121314151617181920212223public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; private static final int ANNOTATION= 0x00002000; private static final int ENUM = 0x00004000; private static final int SYNTHETIC = 0x00001000; private static native void registerNatives(); static &#123; registerNatives(); &#125; /* * Private constructor. Only the Java Virtual Machine creates Class objects. //私有构造器，只有JVM才能调用创建Class对象 * This constructor is not used and prevents the default constructor being * generated. */ private Class(ClassLoader loader) &#123; // Initialize final field for classLoader. The initialization value of non-null // prevents future JIT optimizations from assuming this final field is null. classLoader = loader; &#125; 到这我们也就可以得出以下几点信息： Class类也是类的一种，与class关键字是不一样的。 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件) 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。 Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载 Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。 [#类加载类加载机制和类字节码技术可以参考如下两篇文章： JVM基础 - 类字节码详解 源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行 JVM基础 - Java 类加载机制 这篇文章将带你深入理解Java 类加载机制 其中，这里我们需要回顾的是： 类加载机制流程 类的加载 反射的使用 提示 基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等 在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。 Class类对象的获取在类加载的时候，jvm会创建一个class对象 class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种 根据类名：类名.class 根据对象：对象.getClass() 根据全限定类名：Class.forName(全限定类名) 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void classTest() throws Exception &#123; // 获取Class对象的三种方式 logger.info(&quot;根据类名: \\t&quot; + User.class); logger.info(&quot;根据对象: \\t&quot; + new User().getClass()); logger.info(&quot;根据全限定类名:\\t&quot; + Class.forName(&quot;com.test.User&quot;)); // 常用的方法 logger.info(&quot;获取全限定类名:\\t&quot; + userClass.getName()); logger.info(&quot;获取类名:\\t&quot; + userClass.getSimpleName()); logger.info(&quot;实例化:\\t&quot; + userClass.newInstance());&#125;// ...package com.test;public class User &#123; private String name = &quot;init&quot;; private int age; public User() &#123;&#125; public User(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; private String getName() &#123; return name; &#125; private void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 输出结果： 123456根据类名: class com.test.User根据对象: class com.test.User根据全限定类名:\tclass com.test.User获取全限定类名:\tcom.test.User获取类名:\tUser实例化:\tUser [name=init, age=0] 再来看看 Class类的方法 方法名 说明 forName() (1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。 (2)为了产生Class引用，forName()立即就进行了初始化。 Object-getClass() 获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。 getName() 取全限定的类名(包括包名)，即类的完整名字。 getSimpleName() 获取类名(不包括包名) getCanonicalName() 获取全限定的类名(包括包名) isInterface() 判断Class对象是否是表示一个接口 getInterfaces() 返回Class对象数组，表示Class对象所引用的类所实现的所有接口。 getSupercalss() 返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。 newInstance() 返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。 getFields() 获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。 getDeclaredFields 获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。 简单测试下（这里例子源于https://blog.csdn.net/mcryeasy/article/details/52344729） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.cry;import java.lang.reflect.Field;interface I1 &#123;&#125;interface I2 &#123;&#125;class Cell&#123; public int mCellPublic;&#125;class Animal extends Cell&#123; private int mAnimalPrivate; protected int mAnimalProtected; int mAnimalDefault; public int mAnimalPublic; private static int sAnimalPrivate; protected static int sAnimalProtected; static int sAnimalDefault; public static int sAnimalPublic;&#125;class Dog extends Animal implements I1, I2 &#123; private int mDogPrivate; public int mDogPublic; protected int mDogProtected; private int mDogDefault; private static int sDogPrivate; protected static int sDogProtected; static int sDogDefault; public static int sDogPublic;&#125;public class Test &#123; public static void main(String[] args) throws IllegalAccessException, InstantiationException &#123; Class&lt;Dog&gt; dog = Dog.class; //类名打印 System.out.println(dog.getName()); //com.cry.Dog System.out.println(dog.getSimpleName()); //Dog System.out.println(dog.getCanonicalName());//com.cry.Dog //接口 System.out.println(dog.isInterface()); //false for (Class iI : dog.getInterfaces()) &#123; System.out.println(iI); &#125; /* interface com.cry.I1 interface com.cry.I2 */ //父类 System.out.println(dog.getSuperclass());//class com.cry.Animal //创建对象 Dog d = dog.newInstance(); //字段 for (Field f : dog.getFields()) &#123; System.out.println(f.getName()); &#125; /* mDogPublic sDogPublic mAnimalPublic sAnimalPublic mCellPublic //父类的父类的公共字段也打印出来了 */ System.out.println(&quot;---------&quot;); for (Field f : dog.getDeclaredFields()) &#123; System.out.println(f.getName()); &#125; /** 只有自己类声明的字段 mDogPrivate mDogPublic mDogProtected mDogDefault sDogPrivate sDogProtected sDogDefault sDogPublic */ &#125;&#125; getName、getCanonicalName与getSimpleName的区别： getSimpleName：只获取类名 getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。 getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。 12345678910111213141516171819202122package com.cry;public class Test &#123; private class inner&#123; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; //普通类 System.out.println(Test.class.getSimpleName()); //Test System.out.println(Test.class.getName()); //com.cry.Test System.out.println(Test.class.getCanonicalName()); //com.cry.Test //内部类 System.out.println(inner.class.getSimpleName()); //inner System.out.println(inner.class.getName()); //com.cry.Test$inner System.out.println(inner.class.getCanonicalName()); //com.cry.Test.inner //数组 System.out.println(args.getClass().getSimpleName()); //String[] System.out.println(args.getClass().getName()); //[Ljava.lang.String; System.out.println(args.getClass().getCanonicalName()); //java.lang.String[] //我们不能用getCanonicalName去加载类对象，必须用getName //Class.forName(inner.class.getCanonicalName()); 报错 Class.forName(inner.class.getName()); &#125;&#125; Constructor类及其用法 Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。 获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下： 方法返回值 方法名称 方法说明 static Class&lt;?&gt; forName(String className) 返回与带有给定字符串名的类或接口相关联的 Class 对象。 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回指定参数类型、具有public访问权限的构造函数对象 Constructor&lt;?&gt;[] getConstructors() 返回所有具有public访问权限的构造函数的Constructor对象数组 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 返回指定参数类型、所有声明的（包括private）构造函数对象 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有声明的（包括private）构造函数对象 T newInstance() 调用无参构造器创建此 Class 对象所表示的类的一个新实例。 下面看一个简单例子来了解Constructor对象的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class ConstructionTest implements Serializable &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = null; //获取Class对象的引用 clazz = Class.forName(&quot;com.example.javabase.User&quot;); //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常 User user = (User) clazz.newInstance(); user.setAge(20); user.setName(&quot;Jack&quot;); System.out.println(user); System.out.println(&quot;--------------------------------------------&quot;); //获取带String参数的public构造函数 Constructor cs1 =clazz.getConstructor(String.class); //创建User User user1= (User) cs1.newInstance(&quot;hiway&quot;); user1.setAge(22); System.out.println(&quot;user1:&quot;+user1.toString()); System.out.println(&quot;--------------------------------------------&quot;); //取得指定带int和String参数构造函数,该方法是私有构造private Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class); //由于是private必须设置可访问 cs2.setAccessible(true); //创建user对象 User user2= (User) cs2.newInstance(25,&quot;hiway2&quot;); System.out.println(&quot;user2:&quot;+user2.toString()); System.out.println(&quot;--------------------------------------------&quot;); //获取所有构造包含private Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; //获取构造函数参数类型 Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); System.out.println(&quot;构造函数[&quot;+i+&quot;]:&quot;+cons[i].toString() ); System.out.print(&quot;参数类型[&quot;+i+&quot;]:(&quot;); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125;&#125;class User &#123; private int age; private String name; public User() &#123; super(); &#125; public User(String name) &#123; super(); this.name = name; &#125; /** * 私有构造 * @param age * @param name */ private User(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 输出结果 12345678910111213/* output User&#123;age=20, name=&#x27;Jack&#x27;&#125;--------------------------------------------user1:User&#123;age=22, name=&#x27;hiway&#x27;&#125;--------------------------------------------user2:User&#123;age=25, name=&#x27;hiway2&#x27;&#125;--------------------------------------------构造函数[0]:private com.example.javabase.User(int,java.lang.String)参数类型[0]:(int,java.lang.String)构造函数[1]:public com.example.javabase.User(java.lang.String)参数类型[1]:(java.lang.String)构造函数[2]:public com.example.javabase.User()参数类型[2]:() 关于**Constructor类本身一些常用方法**如下(仅部分，其他可查API) 方法返回值 方法名称 方法说明 Class getDeclaringClass() 返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数） Type[] getGenericParameterTypes() 按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。 String getName() 以字符串形式返回此构造方法的名称。 Class&lt;?&gt;[] getParameterTypes() 按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型 T newInstance(Object… initargs) 使用此 Constructor对象表示的构造函数来创建新实例 String toGenericString() 返回描述此 Constructor 的字符串，其中包括类型参数。 代码演示如下： 12345678910111213141516171819202122232425Constructor cs3 = clazz.getDeclaredConstructor(int.class,String.class);System.out.println(&quot;-----getDeclaringClass-----&quot;);Class uclazz=cs3.getDeclaringClass();//Constructor对象表示的构造方法的类System.out.println(&quot;构造方法的类:&quot;+uclazz.getName());System.out.println(&quot;-----getGenericParameterTypes-----&quot;);//对象表示此 Constructor 对象所表示的方法的形参类型Type[] tps=cs3.getGenericParameterTypes();for (Type tp:tps) &#123; System.out.println(&quot;参数名称tp:&quot;+tp);&#125;System.out.println(&quot;-----getParameterTypes-----&quot;);//获取构造函数参数类型Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();for (Class claz:clazzs) &#123; System.out.println(&quot;参数名称:&quot;+claz.getName());&#125;System.out.println(&quot;-----getName-----&quot;);//以字符串形式返回此构造方法的名称System.out.println(&quot;getName:&quot;+cs3.getName());System.out.println(&quot;-----getoGenericString-----&quot;);//返回描述此 Constructor 的字符串，其中包括类型参数。System.out.println(&quot;getoGenericString():&quot;+cs3.toGenericString()); 输出结果 123456789101112-----getDeclaringClass-----构造方法的类:com.example.javabase.User-----getGenericParameterTypes-----参数名称tp:int参数名称tp:class java.lang.String-----getParameterTypes-----参数名称:int参数名称:java.lang.String-----getName-----getName:com.example.javabase.User-----getoGenericString-----getoGenericString():private com.example.javabase.User(int,java.lang.String) Field类及其用法 Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下： 方法返回值 方法名称 方法说明 Field getDeclaredField(String name) 获取指定name名称的(包含private修饰的)字段，不包括继承的字段 Field[] getDeclaredFields() 获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段 Field getField(String name) 获取指定name名称、具有public修饰的字段，包含继承字段 Field[] getFields() 获取修饰符为public的字段，包含继承字段 下面的代码演示了上述方法的使用过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ReflectField &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; Class&lt;?&gt; clazz = Class.forName(&quot;reflect.Student&quot;); //获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段, // 否则抛NoSuchFieldException Field field = clazz.getField(&quot;age&quot;); System.out.println(&quot;field:&quot;+field); //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取 Field fields[] = clazz.getFields(); for (Field f:fields) &#123; System.out.println(&quot;f:&quot;+f.getDeclaringClass()); &#125; System.out.println(&quot;================getDeclaredFields====================&quot;); //获取当前类所字段(包含private字段),注意不包含父类的字段 Field fields2[] = clazz.getDeclaredFields(); for (Field f:fields2) &#123; System.out.println(&quot;f2:&quot;+f.getDeclaringClass()); &#125; //获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段 Field field2 = clazz.getDeclaredField(&quot;desc&quot;); System.out.println(&quot;field2:&quot;+field2); &#125; /** 输出结果: field:public int reflect.Person.age f:public java.lang.String reflect.Student.desc f:public int reflect.Person.age f:public java.lang.String reflect.Person.name ================getDeclaredFields==================== f2:public java.lang.String reflect.Student.desc f2:private int reflect.Student.score field2:public java.lang.String reflect.Student.desc */&#125;class Person&#123; public int age; public String name; //省略set和get方法&#125;class Student extends Person&#123; public String desc; private int score; //省略set和get方法&#125; 上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField&#x2F;getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField&#x2F;getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下： 123456789101112131415161718192021222324//获取Class对象引用Class&lt;?&gt; clazz = Class.forName(&quot;reflect.Student&quot;);Student st= (Student) clazz.newInstance();//获取父类public字段并赋值Field ageField = clazz.getField(&quot;age&quot;);ageField.set(st,18);Field nameField = clazz.getField(&quot;name&quot;);nameField.set(st,&quot;Lily&quot;);//只获取当前类的字段,不获取父类的字段Field descField = clazz.getDeclaredField(&quot;desc&quot;);descField.set(st,&quot;I am student&quot;);Field scoreField = clazz.getDeclaredField(&quot;score&quot;);//设置可访问，score是private的scoreField.setAccessible(true);scoreField.set(st,88);System.out.println(st.toString());//输出结果：Student&#123;age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88&#125; //获取字段值System.out.println(scoreField.get(st));// 88 其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下： 方法返回值 方法名称 方法说明 void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 Object get(Object obj) 返回指定对象上此 Field 表示的字段的值 Class&lt;?&gt; getType() 返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。 boolean isEnumConstant() 如果此字段表示枚举类型的元素则返回 true；否则返回 false String toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串 String getName() 返回此 Field 对象表示的字段的名称 Class&lt;?&gt; getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段 void setAccessible(boolean flag) 将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性 上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如setInt()/getInt()、setBoolean()/getBoolean、setChar()/getChar()等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。 Method类及其用法 Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。 下面是Class类获取Method对象相关的方法： 方法返回值 方法名称 方法说明 Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 Method[] getDeclaredMethods() 返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 Method[] getMethods() 返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 同样通过案例演示上述方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Method;public class ReflectMethod &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; Class clazz = Class.forName(&quot;reflect.Circle&quot;); //根据参数获取public的Method,包含继承自父类的方法 Method method = clazz.getMethod(&quot;draw&quot;,int.class,String.class); System.out.println(&quot;method:&quot;+method); //获取所有public的方法: Method[] methods =clazz.getMethods(); for (Method m:methods)&#123; System.out.println(&quot;m::&quot;+m); &#125; System.out.println(&quot;=========================================&quot;); //获取当前类的方法包含private,该方法无法获取继承自父类的method Method method1 = clazz.getDeclaredMethod(&quot;drawCircle&quot;); System.out.println(&quot;method1::&quot;+method1); //获取当前类的所有方法包含private,该方法无法获取继承自父类的method Method[] methods1=clazz.getDeclaredMethods(); for (Method m:methods1)&#123; System.out.println(&quot;m1::&quot;+m); &#125; &#125;&#125;class Shape &#123; public void draw()&#123; System.out.println(&quot;draw&quot;); &#125; public void draw(int count , String name)&#123; System.out.println(&quot;draw &quot;+ name +&quot;,count=&quot;+count); &#125;&#125;class Circle extends Shape&#123; private void drawCircle()&#123; System.out.println(&quot;drawCircle&quot;); &#125; public int getAllCount()&#123; return 100; &#125;&#125; 输出结果: 1234567891011121314151617181920method:public void reflect.Shape.draw(int,java.lang.String)m::public int reflect.Circle.getAllCount()m::public void reflect.Shape.draw()m::public void reflect.Shape.draw(int,java.lang.String)m::public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionm::public final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionm::public final void java.lang.Object.wait() throws java.lang.InterruptedExceptionm::public boolean java.lang.Object.equals(java.lang.Object)m::public java.lang.String java.lang.Object.toString()m::public native int java.lang.Object.hashCode()m::public final native java.lang.Class java.lang.Object.getClass()m::public final native void java.lang.Object.notify()m::public final native void java.lang.Object.notifyAll()=========================================method1::private void reflect.Circle.drawCircle()m1::public int reflect.Circle.getAllCount()m1::private void reflect.Circle.drawCircle() 在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而getDeclaredMethod/getDeclaredMethods方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法： 1234567891011121314151617181920Class clazz = Class.forName(&quot;reflect.Circle&quot;);//创建对象Circle circle = (Circle) clazz.newInstance();//获取指定参数的方法对象MethodMethod method = clazz.getMethod(&quot;draw&quot;,int.class,String.class);//通过Method对象的invoke(Object obj,Object... args)方法调用method.invoke(circle,15,&quot;圈圈&quot;);//对私有无参方法的操作Method method1 = clazz.getDeclaredMethod(&quot;drawCircle&quot;);//修改私有方法的访问标识method1.setAccessible(true);method1.invoke(circle);//对有返回值得方法操作Method method2 =clazz.getDeclaredMethod(&quot;getAllCount&quot;);Integer count = (Integer) method2.invoke(circle);System.out.println(&quot;count:&quot;+count); 输出结果 123draw 圈圈,count=15drawCirclecount:100 在上述代码中调用方法，使用了Method类的invoke(Object obj,Object... args)第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。 方法返回值 方法名称 方法说明 Object invoke(Object obj, Object… args) 对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 Class&lt;?&gt; getReturnType() 返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型 Type getGenericReturnType() 返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。 Class&lt;?&gt;[] getParameterTypes() 按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组 Type[] getGenericParameterTypes() 按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型 String getName() 以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称 boolean isVarArgs() 判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。 String toGenericString() 返回描述此 Method 的字符串，包括类型参数。 getReturnType方法/getGenericReturnType方法都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息 123456public interface Type &#123; //1.8新增 default String getTypeName() &#123; return toString(); &#125;&#125; 而getParameterTypes/getGenericParameterTypes也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。 反射机制执行的流程 这部分主要参考自https://www.cnblogs.com/yougewe/p/10125073.html 先看个例子 12345678910111213141516171819202122232425262728public class HelloReflect &#123; public static void main(String[] args) &#123; try &#123; // 1. 使用外部配置的实现，进行动态加载类 TempFunctionTest test = (TempFunctionTest)Class.forName(&quot;com.tester.HelloReflect&quot;).newInstance(); test.sayHello(&quot;call directly&quot;); // 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象） Object t2 = new TempFunctionTest(); Method method = t2.getClass().getDeclaredMethod(&quot;sayHello&quot;, String.class); method.invoke(test, &quot;method invoke&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e ) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; public void sayHello(String word) &#123; System.out.println(&quot;hello,&quot; + word); &#125;&#125; 来看执行流程 反射获取类实例首先调用了 java.lang.Class 的静态方法，获取类信息。 12345678@CallerSensitivepublic static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; // 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader Class&lt;?&gt; caller = Reflection.getCallerClass(); // 调用native方法进行获取class信息 return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。 主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader. 最后，jvm又会回调 ClassLoader 进类加载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false);&#125; // sun.misc.Launcher public Class&lt;?&gt; loadClass(String var1, boolean var2) throws ClassNotFoundException &#123; int var3 = var1.lastIndexOf(46); if(var3 != -1) &#123; SecurityManager var4 = System.getSecurityManager(); if(var4 != null) &#123; var4.checkPackageAccess(var1.substring(0, var3)); &#125; &#125; if(this.ucp.knownToNotExist(var1)) &#123; Class var5 = this.findLoadedClass(var1); if(var5 != null) &#123; if(var2) &#123; this.resolveClass(var5); &#125; return var5; &#125; else &#123; throw new ClassNotFoundException(var1); &#125; &#125; else &#123; return super.loadClass(var1, var2); &#125; &#125;// java.lang.ClassLoaderprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; // 先获取锁 synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded // 如果已经加载了的话，就不用再加载了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; // 双亲委托加载 if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; // 父类没有加载到时，再自己加载 if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125;protected Object getClassLoadingLock(String className) &#123; Object lock = this; if (parallelLockMap != null) &#123; // 使用 ConcurrentHashMap来保存锁 Object newLock = new Object(); lock = parallelLockMap.putIfAbsent(className, newLock); if (lock == null) &#123; lock = newLock; &#125; &#125; return lock;&#125;protected final Class&lt;?&gt; findLoadedClass(String name) &#123; if (!checkName(name)) return null; return findLoadedClass0(name);&#125; 下面来看一下 newInstance() 的实现方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 首先肯定是 Class.newInstance@CallerSensitivepublic T newInstance() throws InstantiationException, IllegalAccessException&#123; if (System.getSecurityManager() != null) &#123; checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false); &#125; // NOTE: the following code may not be strictly correct under // the current Java memory model. // Constructor lookup // newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器 if (cachedConstructor == null) &#123; if (this == Class.class) &#123; // 不允许调用 Class 的 newInstance() 方法 throw new IllegalAccessException( &quot;Can not call newInstance() on the Class for java.lang.Class&quot; ); &#125; try &#123; // 获取无参构造器 Class&lt;?&gt;[] empty = &#123;&#125;; final Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED); // Disable accessibility checks on the constructor // since we have to do the security check here anyway // (the stack depth is wrong for the Constructor&#x27;s // security check to work) java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; c.setAccessible(true); return null; &#125; &#125;); cachedConstructor = c; &#125; catch (NoSuchMethodException e) &#123; throw (InstantiationException) new InstantiationException(getName()).initCause(e); &#125; &#125; Constructor&lt;T&gt; tmpConstructor = cachedConstructor; // Security check (same as in java.lang.reflect.Constructor) int modifiers = tmpConstructor.getModifiers(); if (!Reflection.quickCheckMemberAccess(this, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); if (newInstanceCallerCache != caller) &#123; Reflection.ensureMemberAccess(caller, this, null, modifiers); newInstanceCallerCache = caller; &#125; &#125; // Run constructor try &#123; // 调用无参构造器 return tmpConstructor.newInstance((Object[])null); &#125; catch (InvocationTargetException e) &#123; Unsafe.getUnsafe().throwException(e.getTargetException()); // Not reached return null; &#125;&#125; newInstance() 主要做了三件事： 权限检测，如果不通过直接抛出异常； 查找无参构造器，并将其缓存起来； 调用具体方法的无参构造方法，生成实例并返回； 下面是获取构造器的过程： 12345678910111213private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes, int which) throws NoSuchMethodException&#123; // 获取所有构造器 Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC)); for (Constructor&lt;T&gt; constructor : constructors) &#123; if (arrayContentsEq(parameterTypes, constructor.getParameterTypes())) &#123; return getReflectionFactory().copyConstructor(constructor); &#125; &#125; throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));&#125; getConstructor0() 为获取匹配的构造方器；分三步： 先获取所有的constructors, 然后通过进行参数类型比较； 找到匹配后，通过 ReflectionFactory copy一份constructor返回； 否则抛出 NoSuchMethodException; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 获取当前类所有的构造方法，通过jvm或者缓存// Returns an array of &quot;root&quot; constructors. These Constructor// objects must NOT be propagated to the outside world, but must// instead be copied via ReflectionFactory.copyConstructor.private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) &#123; checkInitted(); Constructor&lt;T&gt;[] res; // 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收 ReflectionData&lt;T&gt; rd = reflectionData(); if (rd != null) &#123; res = publicOnly ? rd.publicConstructors : rd.declaredConstructors; // 存在缓存，则直接返回 if (res != null) return res; &#125; // No cached value available; request value from VM if (isInterface()) &#123; @SuppressWarnings(&quot;unchecked&quot;) Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0]; res = temporaryRes; &#125; else &#123; // 使用native方法从jvm获取构造器 res = getDeclaredConstructors0(publicOnly); &#125; if (rd != null) &#123; // 最后，将从jvm中读取的内容，存入缓存 if (publicOnly) &#123; rd.publicConstructors = res; &#125; else &#123; rd.declaredConstructors = res; &#125; &#125; return res;&#125;// Lazily create and cache ReflectionDataprivate ReflectionData&lt;T&gt; reflectionData() &#123; SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData; int classRedefinedCount = this.classRedefinedCount; ReflectionData&lt;T&gt; rd; if (useCaches &amp;&amp; reflectionData != null &amp;&amp; (rd = reflectionData.get()) != null &amp;&amp; rd.redefinedCount == classRedefinedCount) &#123; return rd; &#125; // else no SoftReference or cleared SoftReference or stale ReflectionData // -&gt; create and replace new instance return newReflectionData(reflectionData, classRedefinedCount);&#125;// 新创建缓存，保存反射信息private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData, int classRedefinedCount) &#123; if (!useCaches) return null; // 使用cas保证更新的线程安全性，所以反射是保证线程安全的 while (true) &#123; ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount); // try to CAS it... if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) &#123; return rd; &#125; // 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了 oldReflectionData = this.reflectionData; classRedefinedCount = this.classRedefinedCount; if (oldReflectionData != null &amp;&amp; (rd = oldReflectionData.get()) != null &amp;&amp; rd.redefinedCount == classRedefinedCount) &#123; return rd; &#125; &#125;&#125; 如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤； 先尝试从缓存中获取； 如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用； 另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。 1234567891011121314151617181920// reflection data that might get invalidated when JVM TI RedefineClasses() is calledprivate static class ReflectionData&lt;T&gt; &#123; volatile Field[] declaredFields; volatile Field[] publicFields; volatile Method[] declaredMethods; volatile Method[] publicMethods; volatile Constructor&lt;T&gt;[] declaredConstructors; volatile Constructor&lt;T&gt;[] publicConstructors; // Intermediate results for getFields and getMethods volatile Field[] declaredPublicFields; volatile Method[] declaredPublicMethods; volatile Class&lt;?&gt;[] interfaces; // Value of classRedefinedCount when we created this ReflectionData instance final int redefinedCount; ReflectionData(int redefinedCount) &#123; this.redefinedCount = redefinedCount; &#125;&#125; 其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static boolean arrayContentsEq(Object[] a1, Object[] a2) &#123; if (a1 == null) &#123; return a2 == null || a2.length == 0; &#125; if (a2 == null) &#123; return a1.length == 0; &#125; if (a1.length != a2.length) &#123; return false; &#125; for (int i = 0; i &lt; a1.length; i++) &#123; if (a1[i] != a2[i]) &#123; return false; &#125; &#125; return true;&#125;// sun.reflect.ReflectionFactory/** Makes a copy of the passed constructor. The returned constructor is a &quot;child&quot; of the passed one; see the comments in Constructor.java for details. */public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) &#123; return langReflectAccess().copyConstructor(arg);&#125;// java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来Constructor&lt;T&gt; copy() &#123; // This routine enables sharing of ConstructorAccessor objects // among Constructor objects which refer to the same underlying // method in the VM. (All of this contortion is only necessary // because of the &quot;accessibility&quot; bit in AccessibleObject, // which implicitly requires that new java.lang.reflect // objects be fabricated for each reflective call on Class // objects.) if (this.root != null) throw new IllegalArgumentException(&quot;Can not copy a non-root Constructor&quot;); Constructor&lt;T&gt; res = new Constructor&lt;&gt;(clazz, parameterTypes, exceptionTypes, modifiers, slot, signature, annotations, parameterAnnotations); // root 指向当前 constructor res.root = this; // Might as well eagerly propagate this if already present res.constructorAccessor = constructorAccessor; return res;&#125; 通过上面，获取到 Constructor 了。 接下来就只需调用其相应构造器的 newInstance()，即返回实例了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// return tmpConstructor.newInstance((Object[])null); // java.lang.reflect.Constructor@CallerSensitivepublic T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, null, modifiers); &#125; &#125; if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0) throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;); ConstructorAccessor ca = constructorAccessor; // read volatile if (ca == null) &#123; ca = acquireConstructorAccessor(); &#125; @SuppressWarnings(&quot;unchecked&quot;) T inst = (T) ca.newInstance(initargs); return inst;&#125;// sun.reflect.DelegatingConstructorAccessorImplpublic Object newInstance(Object[] args) throws InstantiationException, IllegalArgumentException, InvocationTargetException&#123; return delegate.newInstance(args);&#125;// sun.reflect.NativeConstructorAccessorImplpublic Object newInstance(Object[] args) throws InstantiationException, IllegalArgumentException, InvocationTargetException&#123; // We can&#x27;t inflate a constructor belonging to a vm-anonymous class // because that kind of class can&#x27;t be referred to by name, hence can&#x27;t // be found from the generated bytecode. if (++numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) &#123; ConstructorAccessorImpl acc = (ConstructorAccessorImpl) new MethodAccessorGenerator(). generateConstructor(c.getDeclaringClass(), c.getParameterTypes(), c.getExceptionTypes(), c.getModifiers()); parent.setDelegate(acc); &#125; // 调用native方法，进行调用 constructor return newInstance0(c, args);&#125; 返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。 反射获取方法 第一步，先获取 Method; 1234567891011// java.lang.Class@CallerSensitivepublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123; checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true); Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes); if (method == null) &#123; throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes)); &#125; return method;&#125; 忽略第一个检查权限，剩下就只有两个动作了。 获取所有方法列表； 根据方法名称和方法列表，选出符合要求的方法； 如果没有找到相应方法，抛出异常，否则返回对应方法； 所以，先看一下怎样获取类声明的所有方法？ 12345678910111213141516171819202122// Returns an array of &quot;root&quot; methods. These Method objects must NOT// be propagated to the outside world, but must instead be copied// via ReflectionFactory.copyMethod.private Method[] privateGetDeclaredMethods(boolean publicOnly) &#123; checkInitted(); Method[] res; ReflectionData&lt;T&gt; rd = reflectionData(); if (rd != null) &#123; res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods; if (res != null) return res; &#125; // No cached value available; request value from VM res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly)); if (rd != null) &#123; if (publicOnly) &#123; rd.declaredPublicMethods = res; &#125; else &#123; rd.declaredMethods = res; &#125; &#125; return res;&#125; 很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。 不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。 12345678910111213141516171819202122232425262728293031323334353637383940414243// sun.misc.Reflectionpublic static Method[] filterMethods(Class&lt;?&gt; containingClass, Method[] methods) &#123; if (methodFilterMap == null) &#123; // Bootstrapping return methods; &#125; return (Method[])filter(methods, methodFilterMap.get(containingClass));&#125;// 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...private static Member[] filter(Member[] members, String[] filteredNames) &#123; if ((filteredNames == null) || (members.length == 0)) &#123; return members; &#125; int numNewMembers = 0; for (Member member : members) &#123; boolean shouldSkip = false; for (String filteredName : filteredNames) &#123; if (member.getName() == filteredName) &#123; shouldSkip = true; break; &#125; &#125; if (!shouldSkip) &#123; ++numNewMembers; &#125; &#125; Member[] newMembers = (Member[])Array.newInstance(members[0].getClass(), numNewMembers); int destIdx = 0; for (Member member : members) &#123; boolean shouldSkip = false; for (String filteredName : filteredNames) &#123; if (member.getName() == filteredName) &#123; shouldSkip = true; break; &#125; &#125; if (!shouldSkip) &#123; newMembers[destIdx++] = member; &#125; &#125; return newMembers;&#125; 第二步，根据方法名和参数类型过滤指定方法返回： 123456789101112131415161718private static Method searchMethods(Method[] methods, String name, Class&lt;?&gt;[] parameterTypes)&#123; Method res = null; // 使用常量池，避免重复创建String String internedName = name.intern(); for (int i = 0; i &lt; methods.length; i++) &#123; Method m = methods[i]; if (m.getName() == internedName &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes()) &amp;&amp; (res == null || res.getReturnType().isAssignableFrom(m.getReturnType()))) res = m; &#125; return (res == null ? res : getReflectionFactory().copyMethod(res));&#125; 大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。 但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。 这里是匹配最精确的子类进行返回（最优匹配） 最后，还是通过 ReflectionFactory, copy 方法后返回。 调用 method.invoke() 方法1234567891011121314151617@CallerSensitivepublic Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123; if (!override) &#123; if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); checkAccess(caller, clazz, obj, modifiers); &#125; &#125; MethodAccessor ma = methodAccessor; // read volatile if (ma == null) &#123; ma = acquireMethodAccessor(); &#125; return ma.invoke(obj, args);&#125; invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。 1234567891011121314151617181920212223242526272829303132333435363738// probably make the implementation more scalable.private MethodAccessor acquireMethodAccessor() &#123; // First check to see if one has been created yet, and take it // if so MethodAccessor tmp = null; if (root != null) tmp = root.getMethodAccessor(); if (tmp != null) &#123; // 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor methodAccessor = tmp; &#125; else &#123; // Otherwise fabricate one and propagate it up to the root tmp = reflectionFactory.newMethodAccessor(this); setMethodAccessor(tmp); &#125; return tmp;&#125;// sun.reflect.ReflectionFactorypublic MethodAccessor newMethodAccessor(Method method) &#123; checkInitted(); if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123; return new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); &#125; else &#123; NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method); DelegatingMethodAccessorImpl res = new DelegatingMethodAccessorImpl(acc); acc.setParent(res); return res; &#125;&#125; 两个Accessor详情： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// NativeMethodAccessorImpl / DelegatingMethodAccessorImplclass NativeMethodAccessorImpl extends MethodAccessorImpl &#123; private final Method method; private DelegatingMethodAccessorImpl parent; private int numInvocations; NativeMethodAccessorImpl(Method method) &#123; this.method = method; &#125; public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException &#123; // We can&#x27;t inflate methods belonging to vm-anonymous classes because // that kind of class can&#x27;t be referred to by name, hence can&#x27;t be // found from the generated bytecode. if (++numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123; MethodAccessorImpl acc = (MethodAccessorImpl) new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); parent.setDelegate(acc); &#125; return invoke0(method, obj, args); &#125; void setParent(DelegatingMethodAccessorImpl parent) &#123; this.parent = parent; &#125; private static native Object invoke0(Method m, Object obj, Object[] args);&#125;class DelegatingMethodAccessorImpl extends MethodAccessorImpl &#123; private MethodAccessorImpl delegate; DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) &#123; setDelegate(delegate); &#125; public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException &#123; return delegate.invoke(obj, args); &#125; void setDelegate(MethodAccessorImpl delegate) &#123; this.delegate = delegate; &#125;&#125; 进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke(); 最后被委托到 NativeMethodAccessorImpl.invoke(), 即： 12345678910111213141516171819202122public Object invoke(Object obj, Object[] args) throws IllegalArgumentException, InvocationTargetException&#123; // We can&#x27;t inflate methods belonging to vm-anonymous classes because // that kind of class can&#x27;t be referred to by name, hence can&#x27;t be // found from the generated bytecode. if (++numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) &#123; MethodAccessorImpl acc = (MethodAccessorImpl) new MethodAccessorGenerator(). generateMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes(), method.getReturnType(), method.getExceptionTypes(), method.getModifiers()); parent.setDelegate(acc); &#125; // invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。 return invoke0(method, obj, args);&#125; 其中， generateMethod() 是生成具体类的方法： 123456789101112131415161718/** This routine is not thread-safe */public MethodAccessor generateMethod(Class&lt;?&gt; declaringClass, String name, Class&lt;?&gt;[] parameterTypes, Class&lt;?&gt; returnType, Class&lt;?&gt;[] checkedExceptions, int modifiers)&#123; return (MethodAccessor) generate(declaringClass, name, parameterTypes, returnType, checkedExceptions, modifiers, false, false, null);&#125; generate() 戳详情。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287/** This routine is not thread-safe */private MagicAccessorImpl generate(final Class&lt;?&gt; declaringClass, String name, Class&lt;?&gt;[] parameterTypes, Class&lt;?&gt; returnType, Class&lt;?&gt;[] checkedExceptions, int modifiers, boolean isConstructor, boolean forSerialization, Class&lt;?&gt; serializationTargetClass)&#123; ByteVector vec = ByteVectorFactory.create(); asm = new ClassFileAssembler(vec); this.declaringClass = declaringClass; this.parameterTypes = parameterTypes; this.returnType = returnType; this.modifiers = modifiers; this.isConstructor = isConstructor; this.forSerialization = forSerialization; asm.emitMagicAndVersion(); // Constant pool entries: // ( * = Boxing information: optional) // (+ = Shared entries provided by AccessorGenerator) // (^ = Only present if generating SerializationConstructorAccessor) // [UTF-8] [This class&#x27;s name] // [CONSTANT_Class_info] for above // [UTF-8] &quot;sun/reflect/&#123;MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl&#125;&quot; // [CONSTANT_Class_info] for above // [UTF-8] [Target class&#x27;s name] // [CONSTANT_Class_info] for above // ^ [UTF-8] [Serialization: Class&#x27;s name in which to invoke constructor] // ^ [CONSTANT_Class_info] for above // [UTF-8] target method or constructor name // [UTF-8] target method or constructor signature // [CONSTANT_NameAndType_info] for above // [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method // [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot; // [UTF-8] invoke or newInstance descriptor // [UTF-8] descriptor for type of non-primitive parameter 1 // [CONSTANT_Class_info] for type of non-primitive parameter 1 // ... // [UTF-8] descriptor for type of non-primitive parameter n // [CONSTANT_Class_info] for type of non-primitive parameter n // + [UTF-8] &quot;java/lang/Exception&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;java/lang/ClassCastException&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;java/lang/NullPointerException&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;java/lang/IllegalArgumentException&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;java/lang/InvocationTargetException&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;&lt;init&gt;&quot; // + [UTF-8] &quot;()V&quot; // + [CONSTANT_NameAndType_info] for above // + [CONSTANT_Methodref_info] for NullPointerException&#x27;s constructor // + [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor // + [UTF-8] &quot;(Ljava/lang/String;)V&quot; // + [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot; // + [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor taking a String // + [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot; // + [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot; // + [CONSTANT_Methodref_info] for InvocationTargetException&#x27;s constructor // + [CONSTANT_Methodref_info] for &quot;super()&quot; // + [UTF-8] &quot;java/lang/Object&quot; // + [CONSTANT_Class_info] for above // + [UTF-8] &quot;toString&quot; // + [UTF-8] &quot;()Ljava/lang/String;&quot; // + [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot; // + [CONSTANT_Methodref_info] for Object&#x27;s toString method // + [UTF-8] &quot;Code&quot; // + [UTF-8] &quot;Exceptions&quot; // * [UTF-8] &quot;java/lang/Boolean&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(Z)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;booleanValue&quot; // * [UTF-8] &quot;()Z&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Byte&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(B)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;byteValue&quot; // * [UTF-8] &quot;()B&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Character&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(C)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;charValue&quot; // * [UTF-8] &quot;()C&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Double&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(D)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;doubleValue&quot; // * [UTF-8] &quot;()D&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Float&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(F)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;floatValue&quot; // * [UTF-8] &quot;()F&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Integer&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(I)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;intValue&quot; // * [UTF-8] &quot;()I&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Long&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(J)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;longValue&quot; // * [UTF-8] &quot;()J&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;java/lang/Short&quot; // * [CONSTANT_Class_info] for above // * [UTF-8] &quot;(S)V&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above // * [UTF-8] &quot;shortValue&quot; // * [UTF-8] &quot;()S&quot; // * [CONSTANT_NameAndType_info] for above // * [CONSTANT_Methodref_info] for above short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES; boolean usesPrimitives = usesPrimitiveTypes(); if (usesPrimitives) &#123; numCPEntries += NUM_BOXING_CPOOL_ENTRIES; &#125; if (forSerialization) &#123; numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES; &#125; // Add in variable-length number of entries to be able to describe // non-primitive parameter types and checked exceptions. numCPEntries += (short) (2 * numNonPrimitiveParameterTypes()); asm.emitShort(add(numCPEntries, S1)); final String generatedName = generateName(isConstructor, forSerialization); asm.emitConstantPoolUTF8(generatedName); asm.emitConstantPoolClass(asm.cpi()); thisClass = asm.cpi(); if (isConstructor) &#123; if (forSerialization) &#123; asm.emitConstantPoolUTF8 (&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;); &#125; else &#123; asm.emitConstantPoolUTF8(&quot;sun/reflect/ConstructorAccessorImpl&quot;); &#125; &#125; else &#123; asm.emitConstantPoolUTF8(&quot;sun/reflect/MethodAccessorImpl&quot;); &#125; asm.emitConstantPoolClass(asm.cpi()); superClass = asm.cpi(); asm.emitConstantPoolUTF8(getClassName(declaringClass, false)); asm.emitConstantPoolClass(asm.cpi()); targetClass = asm.cpi(); short serializationTargetClassIdx = (short) 0; if (forSerialization) &#123; asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false)); asm.emitConstantPoolClass(asm.cpi()); serializationTargetClassIdx = asm.cpi(); &#125; asm.emitConstantPoolUTF8(name); asm.emitConstantPoolUTF8(buildInternalSignature()); asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi()); if (isInterface()) &#123; asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi()); &#125; else &#123; if (forSerialization) &#123; asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi()); &#125; else &#123; asm.emitConstantPoolMethodref(targetClass, asm.cpi()); &#125; &#125; targetMethodRef = asm.cpi(); if (isConstructor) &#123; asm.emitConstantPoolUTF8(&quot;newInstance&quot;); &#125; else &#123; asm.emitConstantPoolUTF8(&quot;invoke&quot;); &#125; invokeIdx = asm.cpi(); if (isConstructor) &#123; asm.emitConstantPoolUTF8(&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;); &#125; else &#123; asm.emitConstantPoolUTF8 (&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;); &#125; invokeDescriptorIdx = asm.cpi(); // Output class information for non-primitive parameter types nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2); for (int i = 0; i &lt; parameterTypes.length; i++) &#123; Class&lt;?&gt; c = parameterTypes[i]; if (!isPrimitive(c)) &#123; asm.emitConstantPoolUTF8(getClassName(c, false)); asm.emitConstantPoolClass(asm.cpi()); &#125; &#125; // Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor emitCommonConstantPoolEntries(); // Boxing entries if (usesPrimitives) &#123; emitBoxingContantPoolEntries(); &#125; if (asm.cpi() != numCPEntries) &#123; throw new InternalError(&quot;Adjust this code (cpi = &quot; + asm.cpi() + &quot;, numCPEntries = &quot; + numCPEntries + &quot;)&quot;); &#125; // Access flags asm.emitShort(ACC_PUBLIC); // This class asm.emitShort(thisClass); // Superclass asm.emitShort(superClass); // Interfaces count and interfaces asm.emitShort(S0); // Fields count and fields asm.emitShort(S0); // Methods count and methods asm.emitShort(NUM_METHODS); emitConstructor(); emitInvoke(); // Additional attributes (none) asm.emitShort(S0); // Load class vec.trim(); final byte[] bytes = vec.getData(); // Note: the class loader is the only thing that really matters // here -- it&#x27;s important to get the generated code into the // same namespace as the target class. Since the generated code // is privileged anyway, the protection domain probably doesn&#x27;t // matter. return AccessController.doPrivileged( new PrivilegedAction&lt;MagicAccessorImpl&gt;() &#123; public MagicAccessorImpl run() &#123; try &#123; return (MagicAccessorImpl) ClassDefiner.defineClass (generatedName, bytes, 0, bytes.length, declaringClass.getClassLoader()).newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new InternalError(e); &#125; &#125; &#125;);&#125; 咱们主要看这一句：ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance(); 在ClassDefiner.defineClass方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。 而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。 反射调用流程小结最后，用几句话总结反射的实现原理： 反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化； 每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上； 反射也是考虑了线程安全的，放心使用； 反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销； 反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器； 当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离； 调度反射方法，最终是由jvm执行invoke0()执行； 参考文章 https://www.codercto.com/a/46094.html https://blog.csdn.net/sinat_38259539/article/details/71799078 https://blog.csdn.net/qq_40896997/article/details/94483820 https://www.cnblogs.com/zhaoguhong/p/6937364.html https://juejin.im/post/5c160420e51d452a60684431 https://blog.csdn.net/mcryeasy/java/article/details/52344729","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"6.Java 基础 - 异常机制详解","path":"/2023/12/25/6.Java-基础-异常机制详解/","content":"Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。 异常的层次结构异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。 Java异常类层次结构图： ThrowableThrowable 是 Java 语言中所有错误与异常的超类。 Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。 Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。 Error（错误）Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。 此类错误一般表示代码运行时 JVM 出现问题。通常有 VirtualMachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。 这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！ Exception（异常）程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。 运行时异常 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常） 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 可查的异常（checked exceptions）和不可查的异常（unchecked exceptions） 可查异常（编译器要求必须处置的异常）： 正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常(编译器不要求强制处置的异常) 包括运行时异常（RuntimeException与其子类）和错误（Error）。 异常基础提示 接下来我们看下异常使用的基础。 异常关键字 try – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。 catch – 用于捕获异常。catch用来捕获try语句块中发生的异常。 finally – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。 throw – 用于抛出异常。 throws – 用在方法签名中，用于声明该方法可能抛出的异常。 异常的申明(throws)在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示： 123public static void method() throws IOException, FileNotFoundException&#123; //something statements&#125; 注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。 通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。 123456789private static void readFile(String filePath) throws IOException &#123; File file = new File(filePath); String result; BufferedReader reader = new BufferedReader(new FileReader(file)); while((result = reader.readLine())!=null) &#123; System.out.println(result); &#125; reader.close();&#125; Throws抛出异常的规则： 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。 异常的抛出(throw)如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示： 123456public static double method(int value) &#123; if(value == 0) &#123; throw new ArithmeticException(&quot;参数不能为0&quot;); //抛出一个运行时异常 &#125; return 5.0 / value;&#125; 大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。 有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。 123456789private static void readFile(String filePath) throws MyException &#123; try &#123; // code &#125; catch (IOException e) &#123; MyException ex = new MyException(&quot;read file failed.&quot;); ex.initCause(e); throw ex; &#125;&#125; 异常的自定义习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException： 1234567public class MyException extends Exception &#123; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125; // ...&#125; 异常的捕获异常捕获处理的方法通常有： try-catch try-catch-finally try-finally try-with-resource try-catch在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理 123456789private static void readFile(String filePath) &#123; try &#123; // code &#125; catch (FileNotFoundException e) &#123; // handle FileNotFoundException &#125; catch (IOException e)&#123; // handle IOException &#125;&#125; 同一个 catch 也可以捕获多种类型异常，用 | 隔开 123456789private static void readFile(String filePath) &#123; try &#123; // code &#125; catch (FileNotFoundException | UnknownHostException e) &#123; // handle FileNotFoundException or UnknownHostException &#125; catch (IOException e)&#123; // handle IOException &#125;&#125; try-catch-finally 常规语法 1234567try &#123; //执行程序代码，可能会出现异常 &#125; catch(Exception e) &#123; //捕获异常并处理 &#125; finally &#123; //必执行的代码&#125; 执行的顺序 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句； 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行； 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句； 一个完整的例子 12345678910111213141516171819202122232425private static void readFile(String filePath) throws MyException &#123; File file = new File(filePath); String result; BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader(file)); while((result = reader.readLine())!=null) &#123; System.out.println(result); &#125; &#125; catch (IOException e) &#123; System.out.println(&quot;readFile method catch block.&quot;); MyException ex = new MyException(&quot;read file failed.&quot;); ex.initCause(e); throw ex; &#125; finally &#123; System.out.println(&quot;readFile method finally block.&quot;); if (null != reader) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; try-finally 可以直接用try-finally吗？ 可以。 try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。 try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。 1234567//以Lock加锁为例，演示try-finallyReentrantLock lock = new ReentrantLock();try &#123; //需要加锁的代码&#125; finally &#123; lock.unlock(); //保证锁一定被释放&#125; finally遇见如下情况不会执行 在前面的代码中用了System.exit()退出程序。 finally语句块中发生了异常。 程序所在的线程死亡。 关闭CPU。 try-with-resource try-with-resource是Java 7中引入的，很容易被忽略。 上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。 代码实现 1234567private static void tryWithResourceTest()&#123; try (Scanner scanner = new Scanner(new FileInputStream(&quot;c:/abc&quot;),&quot;UTF-8&quot;))&#123; // code &#125; catch (IOException e)&#123; // handle exception &#125;&#125; 看下Scanner 123456public final class Scanner implements Iterator&lt;String&gt;, Closeable &#123; // ...&#125;public interface Closeable extends AutoCloseable &#123; public void close() throws IOException;&#125; try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。 异常基础总结 try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。 try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。 finally语句块中的代码一定会被执行，常用于回收资源 。 throws：声明一个异常，告知方法调用者。 throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。 Java编程思想一书中，对异常的总结。 在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。） 解决问题并且重新调用产生异常的方法。 进行少许修补，然后绕过异常发生的地方继续执行。 用别的数据进行计算，以代替方法预计会返回的值。 把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。 把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。 终止程序。 进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。 让类库和程序更安全。 常用的异常在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类: RuntimeException java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。 java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等 java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.NegativeArraySizeException 数组长度为负异常 java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常 java.lang.SecurityException 安全性异常 java.lang.IllegalArgumentException 非法参数异常 IOException IOException：操作输入流和输出流时可能出现的异常。 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 其他 ClassCastException 类型转换异常类 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常类 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到抛出的异常 NumberFormatException 字符串转换为数字抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常 异常实践提示 在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。 当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。 异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。 这里给出几个被很多团队使用的异常处理最佳实践。 只针对不正常的情况才使用异常 异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现 代码1 123if (obj != null) &#123; //...&#125; 代码2 12345try &#123; obj.method(); &#125; catch (NullPointerException e) &#123; //...&#125; 主要原因有三点： 异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。 把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。 对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。 在 finally 块中清理资源或者使用 try-with-resource 语句当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。 错误示例 1234567891011121314public void doNotCloseResourceInTry() &#123; FileInputStream inputStream = null; try &#123; File file = new File(&quot;./tmp.txt&quot;); inputStream = new FileInputStream(file); // use the inputStream to read a file // do NOT do this inputStream.close(); &#125; catch (FileNotFoundException e) &#123; log.error(e); &#125; catch (IOException e) &#123; log.error(e); &#125;&#125; 问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。 所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。 方法一：使用 finally 代码块 与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。 123456789101112131415161718public void closeResourceInFinally() &#123; FileInputStream inputStream = null; try &#123; File file = new File(&quot;./tmp.txt&quot;); inputStream = new FileInputStream(file); // use the inputStream to read a file &#125; catch (FileNotFoundException e) &#123; log.error(e); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; log.error(e); &#125; &#125; &#125;&#125; 方法二：Java 7 的 try-with-resource 语法 如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。 12345678910public void automaticallyCloseResource() &#123; File file = new File(&quot;./tmp.txt&quot;); try (FileInputStream inputStream = new FileInputStream(file);) &#123; // use the inputStream to read a file &#125; catch (FileNotFoundException e) &#123; log.error(e); &#125; catch (IOException e) &#123; log.error(e); &#125;&#125; 尽量使用标准的异常 代码重用是值得提倡的，这是一条通用规则，异常也不例外。 重用现有的异常有几个好处： 它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。 对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。 异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。 Java标准异常中有几个是经常被使用的异常。如下表格： 异常 使用场合 IllegalArgumentException 参数的值不合适 IllegalStateException 参数的状态不合适 NullPointerException 在null被禁止的情况下参数值为null IndexOutOfBoundsException 下标越界 ConcurrentModificationException 在禁止并发修改的情况下，对象检测到并发修改 UnsupportedOperationException 对象不支持客户请求的方法 虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。 最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。 对异常进行文档说明 当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。 在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。 12345678/*** Method description* * @throws MyBusinessException - businuess exception description*/public void doSomething(String input) throws MyBusinessException &#123; // ...&#125; 同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。 优先捕获最具体的异常 大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。 但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。 总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。 你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。 123456789public void catchMostSpecificExceptionFirst() &#123; try &#123; doSomething(&quot;A message&quot;); &#125; catch (NumberFormatException e) &#123; log.error(e); &#125; catch (IllegalArgumentException e) &#123; log.error(e) &#125;&#125; 不要捕获 Throwable 类 Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！ 如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。 所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。 1234567public void doNotCatchThrowable() &#123; try &#123; // do something &#125; catch (Throwable t) &#123; // don&#x27;t do this! &#125;&#125; 不要忽略异常 很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。 1234567public void doNotIgnoreExceptions() &#123; try &#123; // do something &#125; catch (NumberFormatException e) &#123; // this will never happen &#125;&#125; 但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。 合理的做法是至少要记录异常的信息。 1234567public void logAnException() &#123; try &#123; // do something &#125; catch (NumberFormatException e) &#123; log.error(&quot;This should never happen: &quot; + e); // see this line &#125;&#125; 不要记录并抛出异常 这可能是本文中最常被忽略的最佳实践。 可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下： 123456try &#123; new Long(&quot;xyz&quot;);&#125; catch (NumberFormatException e) &#123; log.error(e); throw e;&#125; 这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下： 123456717:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: &quot;xyz&quot;Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;xyz&quot;at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)at java.lang.Long.parseLong(Long.java:589)at java.lang.Long.(Long.java:965)at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58) 如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。 1234567public void wrapException(String input) throws MyBusinessException &#123; try &#123; // do something &#125; catch (NumberFormatException e) &#123; throw new MyBusinessException(&quot;A message that describes the error.&quot;, e); &#125;&#125; 因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。 包装异常时不要抛弃原始的异常捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。 1234567public void wrapException(String input) throws MyBusinessException &#123; try &#123; // do something &#125; catch (NumberFormatException e) &#123; throw new MyBusinessException(&quot;A message that describes the error.&quot;, e); &#125;&#125; 不要使用异常控制程序的流程不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。 不要在finally块中使用return。try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。 如下是一个反例： 12345678910private int x = 0;public int checkReturn() &#123; try &#123; // x等于1，此处不返回 return ++x; &#125; finally &#123; // 返回的结果是2 return ++x; &#125;&#125; 深入理解异常 提示 我们再深入理解下异常，看下底层实现。 JVM处理异常的机制？提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。 1234567public static void simpleTryCatch() &#123; try &#123; testNPE(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。 当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。 所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。 然后我们使用javap来分析这段代码（需要先使用javac编译） 123456789101112//javap -c Main public static void simpleTryCatch(); Code: 0: invokestatic #3 // Method testNPE:()V 3: goto 11 6: astore_0 7: aload_0 8: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 11: return Exception table: from to target type 0 3 6 Class java/lang/Exception 看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。 异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下 from 可能发生异常的起始点 to 可能发生异常的结束点 target 上述from和to之前发生异常后的异常处理者的位置 type 异常处理者处理的异常的类信息 那么异常表用在什么时候呢 答案是异常发生的时候，当一个异常发生时 1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理 2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。 3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目 4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。 5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。 6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。 以上就是JVM处理异常的一些机制。 try-catch -finally 除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码 123456789public static void simpleTryCatchFinally() &#123; try &#123; testNPE(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(&quot;Finally&quot;); &#125;&#125; 同样我们使用javap分析一下代码 1234567891011121314151617181920212223242526public static void simpleTryCatchFinally(); Code: 0: invokestatic #3 // Method testNPE:()V 3: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 6: ldc #7 // String Finally 8: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 11: goto 41 14: astore_0 15: aload_0 16: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 19: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 22: ldc #7 // String Finally 24: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 27: goto 41 30: astore_1 31: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #7 // String Finally 36: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_1 40: athrow 41: return Exception table: from to target type 0 3 14 Class java/lang/Exception 0 3 30 any 14 19 30 any 和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为: 如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。 如果0到3之间，无论发生什么异常，都调用30位置的处理者 如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。 再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下 1234567891011121314151617181920212223242526public static void simpleTryCatchFinally(); Code: //try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。 0: invokestatic #3 // Method testNPE:()V 3: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 6: ldc #7 // String Finally 8: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 11: goto 41 //catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。 14: astore_0 15: aload_0 16: invokevirtual #5 // Method java/lang/Exception.printStackTrace:()V 19: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 22: ldc #7 // String Finally 24: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 27: goto 41 //finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。 30: astore_1 31: getstatic #6 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #7 // String Finally 36: invokevirtual #8 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_1 40: athrow //如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。 41: return Catch先后顺序的问题 我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题 123456789private static void misuseCatchException() &#123; try &#123; testNPE(); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; catch (Exception e) &#123; //error occurs during compilings with tips Exception Java.lang.Exception has already benn caught. e.printStackTrace(); &#125;&#125; 这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。 Return 和finally的问题 这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行 12345678910public static String tryCatchReturn() &#123; try &#123; testNPE(); return &quot;OK&quot;; &#125; catch (Exception e) &#123; return &quot;ERROR&quot;; &#125; finally &#123; System.out.println(&quot;tryCatchReturn&quot;); &#125;&#125; 答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。 123456789101112131415161718192021222324public static java.lang.String tryCatchReturn(); Code: 0: invokestatic #3 // Method testNPE:()V 3: ldc #6 // String OK 5: astore_0 6: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 9: ldc #8 // String tryCatchReturn 11: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 14: aload_0 15: areturn 返回OK字符串，areturn意思为return a reference from a method 16: astore_0 17: ldc #10 // String ERROR 19: astore_1 20: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 23: ldc #8 // String tryCatchReturn 25: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 28: aload_1 29: areturn //返回ERROR字符串 30: astore_2 31: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 34: ldc #8 // String tryCatchReturn 36: invokevirtual #9 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 39: aload_2 40: athrow 如果catch有未处理的异常，抛出去。 异常是否耗时？为什么会耗时？说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比： 123456789101112131415161718192021222324252627282930313233343536373839404142public class ExceptionTest &#123; private int testTimes; public ExceptionTest(int testTimes) &#123; this.testTimes = testTimes; &#125; public void newObject() &#123; long l = System.nanoTime(); for (int i = 0; i &lt; testTimes; i++) &#123; new Object(); &#125; System.out.println(&quot;建立对象：&quot; + (System.nanoTime() - l)); &#125; public void newException() &#123; long l = System.nanoTime(); for (int i = 0; i &lt; testTimes; i++) &#123; new Exception(); &#125; System.out.println(&quot;建立异常对象：&quot; + (System.nanoTime() - l)); &#125; public void catchException() &#123; long l = System.nanoTime(); for (int i = 0; i &lt; testTimes; i++) &#123; try &#123; throw new Exception(); &#125; catch (Exception e) &#123; &#125; &#125; System.out.println(&quot;建立、抛出并接住异常对象：&quot; + (System.nanoTime() - l)); &#125; public static void main(String[] args) &#123; ExceptionTest test = new ExceptionTest(10000); test.newObject(); test.newException(); test.catchException(); &#125; &#125; 运行结果： 123建立对象：575817 建立异常对象：9589080 建立、抛出并接住异常对象：47394475 建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。 那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章： https://www.iteye.com/blog/icyfenix-857722 参考文章 https://blog.csdn.net/MacWx/article/details/90204111 https://blog.csdn.net/hguisu/article/details/6155636 https://blog.csdn.net/ThinkWon/article/details/101681073 https://www.cnblogs.com/skywang12345/p/3544287.html https://www.codercto.com/a/33350.html","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"5.Java 基础 - 注解机制详解","path":"/2023/12/25/5.Java-基础-注解机制详解/","content":"注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它是框架学习和设计者必须掌握的基础。 注解基础注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面： 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。 这么来说是比较抽象的，我们具体看下注解的常见分类： Java自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。 元注解，元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。 自定义注解，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。 接下来我们通过这个分类角度来理解注解。 Java内置注解我们从最为常见的Java内置的注解开始说起，先看下下面的代码： 123456789101112131415161718192021222324252627282930313233class A&#123; public void test() &#123; &#125;&#125;class B extends A&#123; /** * 重载父类的test方法 */ @Override public void test() &#123; &#125; /** * 被弃用的方法 */ @Deprecated public void oldMethod() &#123; &#125; /** * 忽略告警 * * @return */ @SuppressWarnings(&quot;rawtypes&quot;) public List processList() &#123; List list = new ArrayList(); return list; &#125;&#125; Java 1.5开始自带的标准注解，包括@Override、@Deprecated和@SuppressWarnings： @Override：表示当前的方法定义将覆盖父类中的方法 @Deprecated：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告 @SuppressWarnings：表示关闭编译器警告信息 我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。 内置注解 - @Override我们先来看一下这个注解类型的定义： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。 内置注解 - @Deprecated这个注解的定义如下： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。 内置注解 - @SuppressWarnings这个注解我们也比较常用到，先来看下它的定义： 12345@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; String[] value();&#125; 它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示： 参数 作用 原描述 all 抑制所有警告 to suppress all warnings boxing 抑制装箱、拆箱操作时候的警告 to suppress warnings relative to boxing&#x2F;unboxing operations cast 抑制映射相关的警告 to suppress warnings relative to cast operations dep-ann 抑制启用注释的警告 to suppress warnings relative to deprecated annotation deprecation 抑制过期方法警告 to suppress warnings relative to deprecation fallthrough 抑制确在switch中缺失breaks的警告 to suppress warnings relative to missing breaks in switch statements finally 抑制finally模块没有返回的警告 to suppress warnings relative to finally block that don’t return hiding 抑制与隐藏变数的区域变数相关的警告 to suppress warnings relative to locals that hide variable（） incomplete-switch 忽略没有完整的switch语句 to suppress warnings relative to missing entries in a switch statement (enum case) nls 忽略非nls格式的字符 to suppress warnings relative to non-nls string literals null 忽略对null的操作 to suppress warnings relative to null analysis rawtype 使用generics时忽略没有指定相应的类型 to suppress warnings relative to un-specific types when using restriction 抑制与使用不建议或禁止参照相关的警告 to suppress warnings relative to usage of discouraged or serial 忽略在serializable类中没有声明serialVersionUID变量 to suppress warnings relative to missing serialVersionUID field for a serializable class static-access 抑制不正确的静态访问方式警告 to suppress warnings relative to incorrect static access synthetic-access 抑制子类没有按最优方法访问内部类的警告 to suppress warnings relative to unoptimized access from inner classes unchecked 抑制没有进行类型检查操作的警告 to suppress warnings relative to unchecked operations unqualified-field-access 抑制没有权限访问的域的警告 to suppress warnings relative to field access unqualified unused 抑制没被使用过的代码的警告 to suppress warnings relative to unused code 元注解上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：@Target，@Retention，@Documented，@Inherited, 在JDK 1.8中提供了两个元注解 @Repeatable和@Native。 元注解 - @Target Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。 Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。 1234567891011121314151617181920212223public enum ElementType &#123; TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 &#125; 元注解 - @Retention &amp; @RetentionTarget Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。 Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。 123456public enum RetentionPolicy &#123; SOURCE, // 源文件保留 CLASS, // 编译期保留，默认值 RUNTIME // 运行期保留，可通过反射去获取注解信息&#125; 为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。 123456789101112@Retention(RetentionPolicy.SOURCE)public @interface SourcePolicy &#123; &#125;@Retention(RetentionPolicy.CLASS)public @interface ClassPolicy &#123; &#125;@Retention(RetentionPolicy.RUNTIME)public @interface RuntimePolicy &#123; &#125; 用定义好的三个注解类分别去注解一个方法。 1234567891011121314public class RetentionTest &#123; @SourcePolicy\tpublic void sourcePolicy() &#123;\t&#125; @ClassPolicy\tpublic void classPolicy() &#123;\t&#125; @RuntimePolicy\tpublic void runtimePolicy() &#123;\t&#125;&#125; 通过执行 javap -verbose RetentionTest命令获取到的RetentionTest 的 class 字节码内容如下。 123456789101112131415161718192021222324252627282930313233343536373839&#123; public retention.RetentionTest(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public void sourcePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 7: 0 public void classPolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 11: 0 RuntimeInvisibleAnnotations: 0: #11() public void runtimePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 15: 0 RuntimeVisibleAnnotations: 0: #14()&#125; 从 RetentionTest 的字节码内容我们可以得出以下两点结论： 编译器并没有记录下 sourcePolicy() 方法的注解信息； 编译器分别使用了 RuntimeInvisibleAnnotations 和 RuntimeVisibleAnnotations 属性去记录了classPolicy()方法 和 runtimePolicy()方法 的注解信息； 元注解 - @Documented Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。 以下代码在使用Javadoc工具可以生成@TestDocAnnotation注解信息。 1234567891011121314import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Target; @Documented@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface TestDocAnnotation &#123; public String value() default &quot;default&quot;;&#125;@TestDocAnnotation(&quot;myMethodDoc&quot;)public void testDoc() &#123;&#125; 元注解 - @Inherited Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。 我们来测试下这个注解： 定义@Inherited注解： 1234567@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)public @interface TestInheritedAnnotation &#123; String [] values(); int number();&#125; 使用这个注解 1234567891011121314@TestInheritedAnnotation(values = &#123;&quot;value&quot;&#125;, number = 10)public class Person &#123;&#125;class Student extends Person&#123;\t@Test public void test()&#123; Class clazz = Student.class; Annotation[] annotations = clazz.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation.toString()); &#125; &#125;&#125; 输出 1xxxxxxx.TestInheritedAnnotation(values=[value], number=10) 即使Student类没有显示地被注解@TestInheritedAnnotation，但是它的父类Person被注解，而且@TestInheritedAnnotation被@Inherited注解，因此Student类自动有了该注解。 元注解 - @Repeatable (Java8)@Repeatable请参考Java 8 - 重复注解 元注解 - @Native (Java8)使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可 注解与反射接口 定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。 AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口 boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 Annotation[] getAnnotations() 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。 &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) 返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。getAnnotationsByType方法与 getAnnotation的区别在于，getAnnotationsByType会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。 &lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass) 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释 Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。 自定义注解 当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单： 定义自己的注解 12345678910111213141516package com.pdai.java.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyMethodAnnotation &#123; public String title() default &quot;&quot;; public String description() default &quot;&quot;;&#125; 使用注解 123456789101112131415161718192021222324252627282930package com.pdai.java.annotation;import java.io.FileNotFoundException;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;public class TestMethodAnnotation &#123; @Override @MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;) public String toString() &#123; return &quot;Override toString method&quot;; &#125; @Deprecated @MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;) public static void oldMethod() &#123; System.out.println(&quot;old method, don&#x27;t use it.&quot;); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;) @MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;) public static void genericsTest() throws FileNotFoundException &#123; List l = new ArrayList(); l.add(&quot;abc&quot;); oldMethod(); &#125;&#125; 用反射接口获取注解信息 在TestMethodAnnotation中添加Main方法进行测试： 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; try &#123; // 获取所有methods Method[] methods = TestMethodAnnotation.class.getClassLoader() .loadClass((&quot;com.pdai.java.annotation.TestMethodAnnotation&quot;)) .getMethods(); // 遍历 for (Method method : methods) &#123; // 方法上是否有MyMethodAnnotation注解 if (method.isAnnotationPresent(MyMethodAnnotation.class)) &#123; try &#123; // 获取并遍历方法上的所有注解 for (Annotation anno : method.getDeclaredAnnotations()) &#123; System.out.println(&quot;Annotation in Method &#x27;&quot; + method + &quot;&#x27; : &quot; + anno); &#125; // 获取MyMethodAnnotation对象信息 MyMethodAnnotation methodAnno = method .getAnnotation(MyMethodAnnotation.class); System.out.println(methodAnno.title()); &#125; catch (Throwable ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; &#125; catch (SecurityException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125; 测试的输出 1234567Annotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27; : @java.lang.Deprecated()Annotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=old static method, description=deprecated old static method)old static methodAnnotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning static method)test methodAnnotation in Method &#x27;public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)toStringMethod 深入理解注解提示 接下来，我们从其它角度深入理解注解 Java8提供了哪些新的注解？ @Repeatable 请参考Java 8 - 重复注解 ElementType.TYPE_USE 请参考Java 8 - 类型注解 ElementType.TYPE_PARAMETER ElementType.TYPE_USE(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了ElementType.TYPE(类、接口（包括注解类型）和枚举的声明)和ElementType.TYPE_PARAMETER(类型参数声明), 不妨再看个例子 123456789101112131415161718192021222324252627// 自定义ElementType.TYPE_PARAMETER注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE_PARAMETER)public @interface MyNotEmpty &#123;&#125;// 自定义ElementType.TYPE_USE注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE_USE)public @interface MyNotNull &#123;&#125;// 测试类public class TypeParameterAndTypeUseAnnotation&lt;@MyNotEmpty T&gt;&#123; //使用TYPE_PARAMETER类型，会编译不通过// public @MyNotEmpty T test(@MyNotEmpty T a)&#123;// new ArrayList&lt;@MyNotEmpty String&gt;();// return a;// &#125; //使用TYPE_USE类型，编译通过 public @MyNotNull T test2(@MyNotNull T a)&#123; new ArrayList&lt;@MyNotNull String&gt;(); return a; &#125;&#125; 注解支持继承吗？ 注解是不支持继承的 不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口. 虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。 区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。 注解实现的原理？ 网上很多标注解的原理文章根本没有说到点子上。 这里推荐你两篇文章： https://blog.csdn.net/qq_20009015/article/details/106038023 https://www.race604.com/annotation-processing/ 注解的应用场景提示 最后我们再看看实际开发中注解的一些应用场景。@pdai 配置化到注解化 - 框架的演进Spring 框架 配置化到注解化的转变。 继承实现到注解实现 - Junit3到Junit4 一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。 被测试类 12345678910111213141516public class HelloWorld &#123; public void sayHello()&#123; System.out.println(&quot;hello....&quot;); throw new NumberFormatException(); &#125; public void sayWorld()&#123; System.out.println(&quot;world....&quot;); &#125; public String say()&#123; return &quot;hello world!&quot;; &#125; &#125; Junit3 实现UT 通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。 12345678910111213141516171819202122232425262728293031323334353637public class HelloWorldTest extends TestCase&#123; private HelloWorld hw; @Override protected void setUp() throws Exception &#123; super.setUp(); hw=new HelloWorld(); &#125; //1.测试没有返回值 public void testHello()&#123; try &#123; hw.sayHello(); &#125; catch (Exception e) &#123; System.out.println(&quot;发生异常.....&quot;); &#125; &#125; public void testWorld()&#123; hw.sayWorld(); &#125; //2.测试有返回值的方法 // 返回字符串 public void testSay()&#123; assertEquals(&quot;测试失败&quot;, hw.say(), &quot;hello world!&quot;); &#125; //返回对象 public void testObj()&#123; assertNull(&quot;测试对象不为空&quot;, null); assertNotNull(&quot;测试对象为空&quot;,new String()); &#125; @Override protected void tearDown() throws Exception &#123; super.tearDown(); hw=null; &#125;\t&#125; Junit4 实现UT 通过定义@Before，@Test，@After等等注解来实现。 1234567891011121314151617181920212223242526272829303132333435363738public class HelloWorldTest &#123; private HelloWorld hw; @Before public void setUp() &#123; hw = new HelloWorld(); &#125; @Test(expected=NumberFormatException.class) // 1.测试没有返回值,有别于junit3的使用，更加方便 public void testHello() &#123; hw.sayHello(); &#125; @Test public void testWorld() &#123; hw.sayWorld(); &#125; @Test // 2.测试有返回值的方法 // 返回字符串 public void testSay() &#123; assertEquals(&quot;测试失败&quot;, hw.say(), &quot;hello world!&quot;); &#125; @Test // 返回对象 public void testObj() &#123; assertNull(&quot;测试对象不为空&quot;, null); assertNotNull(&quot;测试对象为空&quot;, new String()); &#125; @After public void tearDown() throws Exception &#123; hw = null; &#125; &#125; 这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解Junit4是如何实现运行的呢？可以看这篇文章：JUnit4源码分析运行原理在新窗口打开。 自定义注解和AOP - 通过切面实现解耦 最为常见的就是使用Spring AOP切面实现统一的操作日志管理，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。 自定义Log注解 123456789101112131415161718192021222324@Target(&#123; ElementType.PARAMETER, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Log &#123; /** * 模块 */ public String title() default &quot;&quot;; /** * 功能 */ public BusinessType businessType() default BusinessType.OTHER; /** * 操作人类别 */ public OperatorType operatorType() default OperatorType.MANAGE; /** * 是否保存请求的参数 */ public boolean isSaveRequestData() default true;&#125; 实现日志的切面, 对自定义注解Log作切点进行拦截 即对注解了@Log的方法进行切点拦截， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133@Aspect@Componentpublic class LogAspect &#123; private static final Logger log = LoggerFactory.getLogger(LogAspect.class); /** * 配置织入点 - 自定义注解的包路径 * */ @Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;) public void logPointCut() &#123; &#125; /** * 处理完请求后执行 * * @param joinPoint 切点 */ @AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;) public void doAfterReturning(JoinPoint joinPoint, Object jsonResult) &#123; handleLog(joinPoint, null, jsonResult); &#125; /** * 拦截异常操作 * * @param joinPoint 切点 * @param e 异常 */ @AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;) public void doAfterThrowing(JoinPoint joinPoint, Exception e) &#123; handleLog(joinPoint, e, null); &#125; protected void handleLog(final JoinPoint joinPoint, final Exception e, Object jsonResult) &#123; try &#123; // 获得注解 Log controllerLog = getAnnotationLog(joinPoint); if (controllerLog == null) &#123; return; &#125; // 获取当前的用户 User currentUser = ShiroUtils.getSysUser(); // *========数据库日志=========*// OperLog operLog = new OperLog(); operLog.setStatus(BusinessStatus.SUCCESS.ordinal()); // 请求的地址 String ip = ShiroUtils.getIp(); operLog.setOperIp(ip); // 返回参数 operLog.setJsonResult(JSONObject.toJSONString(jsonResult)); operLog.setOperUrl(ServletUtils.getRequest().getRequestURI()); if (currentUser != null) &#123; operLog.setOperName(currentUser.getLoginName()); if (StringUtils.isNotNull(currentUser.getDept()) &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) &#123; operLog.setDeptName(currentUser.getDept().getDeptName()); &#125; &#125; if (e != null) &#123; operLog.setStatus(BusinessStatus.FAIL.ordinal()); operLog.setErrorMsg(StringUtils.substring(e.getMessage(), 0, 2000)); &#125; // 设置方法名称 String className = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); operLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); // 设置请求方式 operLog.setRequestMethod(ServletUtils.getRequest().getMethod()); // 处理设置注解上的参数 getControllerMethodDescription(controllerLog, operLog); // 保存数据库 AsyncManager.me().execute(AsyncFactory.recordOper(operLog)); &#125; catch (Exception exp) &#123; // 记录本地异常日志 log.error(&quot;==前置通知异常==&quot;); log.error(&quot;异常信息:&#123;&#125;&quot;, exp.getMessage()); exp.printStackTrace(); &#125; &#125; /** * 获取注解中对方法的描述信息 用于Controller层注解 * * @param log 日志 * @param operLog 操作日志 * @throws Exception */ public void getControllerMethodDescription(Log log, OperLog operLog) throws Exception &#123; // 设置action动作 operLog.setBusinessType(log.businessType().ordinal()); // 设置标题 operLog.setTitle(log.title()); // 设置操作人类别 operLog.setOperatorType(log.operatorType().ordinal()); // 是否需要保存request，参数和值 if (log.isSaveRequestData()) &#123; // 获取参数的信息，传入到数据库中。 setRequestValue(operLog); &#125; &#125; /** * 获取请求的参数，放到log中 * * @param operLog * @param request */ private void setRequestValue(OperLog operLog) &#123; Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap(); String params = JSONObject.toJSONString(map); operLog.setOperParam(StringUtils.substring(params, 0, 2000)); &#125; /** * 是否存在注解，如果存在就获取 */ private Log getAnnotationLog(JoinPoint joinPoint) throws Exception &#123; Signature signature = joinPoint.getSignature(); MethodSignature methodSignature = (MethodSignature) signature; Method method = methodSignature.getMethod(); if (method != null) &#123; return method.getAnnotation(Log.class); &#125; return null; &#125;&#125; 使用@Log注解 以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Controller@RequestMapping(&quot;/system/dept&quot;)public class DeptController extends BaseController &#123; private String prefix = &quot;system/dept&quot;; @Autowired private IDeptService deptService; /** * 新增保存部门 */ @Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT) @RequiresPermissions(&quot;system:dept:add&quot;) @PostMapping(&quot;/add&quot;) @ResponseBody public AjaxResult addSave(@Validated Dept dept) &#123; if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123; return error(&quot;新增部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，部门名称已存在&quot;); &#125; return toAjax(deptService.insertDept(dept)); &#125; /** * 保存 */ @Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE) @RequiresPermissions(&quot;system:dept:edit&quot;) @PostMapping(&quot;/edit&quot;) @ResponseBody public AjaxResult editSave(@Validated Dept dept) &#123; if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) &#123; return error(&quot;修改部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，部门名称已存在&quot;); &#125; else if(dept.getParentId().equals(dept.getDeptId())) &#123; return error(&quot;修改部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，上级部门不能是自己&quot;); &#125; return toAjax(deptService.updateDept(dept)); &#125; /** * 删除 */ @Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE) @RequiresPermissions(&quot;system:dept:remove&quot;) @GetMapping(&quot;/remove/&#123;deptId&#125;&quot;) @ResponseBody public AjaxResult remove(@PathVariable(&quot;deptId&quot;) Long deptId) &#123; if (deptService.selectDeptCount(deptId) &gt; 0) &#123; return AjaxResult.warn(&quot;存在下级部门,不允许删除&quot;); &#125; if (deptService.checkDeptExistUser(deptId)) &#123; return AjaxResult.warn(&quot;部门存在用户,不允许删除&quot;); &#125; return toAjax(deptService.deleteDeptById(deptId)); &#125; // ...&#125; 同样的，你也可以看到权限管理也是通过类似的注解（@RequiresPermissions）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。 参考文章 https://blog.csdn.net/javazejian/article/details/71860633 https://blog.csdn.net/qq_20009015/article/details/106038023 https://www.zhihu.com/question/47449512 https://www.race604.com/annotation-processing/ https://www.runoob.com/w3cnote/java-annotation.html","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"4.Java 基础 - 泛型机制详解","path":"/2023/12/25/4.Java-基础-泛型机制详解/","content":"Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。本文综合多篇文章后，总结了Java 泛型的相关知识，希望可以提升你对Java中泛型的认知效率。 为什么会引入泛型 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 引入泛型的意义在于： 适用于多种数据类型执行相同的代码（代码复用） 我们通过一个例子来阐述，先看下下面的代码： 1234567891011121314private static int add(int a, int b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static float add(float a, float b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125;private static double add(double a, double b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b)); return a + b;&#125; 如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法： 1234private static &lt;T extends Number&gt; double add(T a, T b) &#123; System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue();&#125; 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型） 看下这个例子： 1234List list = new ArrayList();list.add(&quot;xxString&quot;);list.add(100d);list.add(new Person()); 我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现java.lang.ClassCastException异常。 引入泛型，它将提供类型的约束，提供编译前的检查： 123List&lt;String&gt; list = new ArrayList&lt;String&gt;();// list中只能放String, 不能放其它类型的元素 泛型的基本使用 提示 我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。 泛型类 从一个简单的泛型类看起： 12345678910111213141516class Point&lt;T&gt;&#123; // 此处可以随便写标识符号，T是type的简称 private T var ; // var的类型由T指定，即：由外部指定 public T getVar()&#123; // 返回值的类型由外部决定 return var ; &#125; public void setVar(T var)&#123; // 设置的类型也由外部决定 this.var = var ; &#125; &#125; public class GenericsDemo06&#123; public static void main(String args[])&#123; Point&lt;String&gt; p = new Point&lt;String&gt;() ; // 里面的var类型为String类型 p.setVar(&quot;it&quot;) ; // 设置字符串 System.out.println(p.getVar().length()) ; // 取得字符串的长度 &#125; &#125; 多元泛型 123456789101112131415161718192021222324252627class Notepad&lt;K,V&gt;&#123; // 此处指定了两个泛型类型 private K key ; // 此变量的类型由外部决定 private V value ; // 此变量的类型由外部决定 public K getKey()&#123; return this.key ; &#125; public V getValue()&#123; return this.value ; &#125; public void setKey(K key)&#123; this.key = key ; &#125; public void setValue(V value)&#123; this.value = value ; &#125; &#125; public class GenericsDemo09&#123; public static void main(String args[])&#123; Notepad&lt;String,Integer&gt; t = null ; // 定义两个泛型类型的对象 t = new Notepad&lt;String,Integer&gt;() ; // 里面的key为String，value为Integer t.setKey(&quot;汤姆&quot;) ; // 设置第一个内容 t.setValue(20) ; // 设置第二个内容 System.out.print(&quot;姓名；&quot; + t.getKey()) ; // 取得信息 System.out.print(&quot;，年龄；&quot; + t.getValue()) ; // 取得信息 &#125; &#125; 泛型接口 简单的泛型接口 12345678910111213141516171819202122interface Info&lt;T&gt;&#123; // 在接口上定义泛型 public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型 &#125; class InfoImpl&lt;T&gt; implements Info&lt;T&gt;&#123; // 定义泛型接口的子类 private T var ; // 定义属性 public InfoImpl(T var)&#123; // 通过构造方法设置属性内容 this.setVar(var) ; &#125; public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; &#125; public class GenericsDemo24&#123; public static void main(String arsg[])&#123; Info&lt;String&gt; i = null; // 声明接口对象 i = new InfoImpl&lt;String&gt;(&quot;汤姆&quot;) ; // 通过子类实例化对象 System.out.println(&quot;内容：&quot; + i.getVar()) ; &#125; &#125; 泛型方法泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html） 定义泛型方法语法格式 调用泛型方法语法格式 说明一下，定义泛型方法时，必须在返回值前边加一个&lt;T&gt;，来声明这是一个泛型方法，持有一个泛型T，然后才可以用泛型T作为方法的返回值。 Class&lt;T&gt;的作用就是指明泛型的具体类型，而Class&lt;T&gt;类型的变量c，可以用来创建泛型类的对象。 为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。 泛型方法要求的参数是Class&lt;T&gt;类型，而Class.forName()方法的返回值也是Class&lt;T&gt;，因此可以用Class.forName()作为参数。其中，forName()方法中的参数是何种类型，返回的Class&lt;T&gt;就是何种类型。在本例中，forName()方法中传入的是User类的完整路径，因此返回的是Class&lt;User&gt;类型的对象，因此调用泛型方法时，变量c的类型就是Class&lt;User&gt;，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。 当然，泛型方法不是仅仅可以有一个参数Class&lt;T&gt;，可以根据需要添加其他参数。 为什么要使用泛型方法呢？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。 泛型的上下限 先看下如下的代码，很明显是会报错的 （具体错误原因请参考后文）。 1234567891011121314151617181920class A&#123;&#125;class B extends A &#123;&#125;// 如下两个方法不会报错public static void funA(A a) &#123; // ... &#125;public static void funB(B b) &#123; funA(b); // ... &#125;// 如下funD方法会报错public static void funC(List&lt;A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;) // ... &#125; 那么如何解决呢？ 为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。&lt;? extends A&gt;表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。 1234567public static void funC(List&lt;? extends A&gt; listA) &#123; // ... &#125;public static void funD(List&lt;B&gt; listB) &#123; funC(listB); // OK // ... &#125; 泛型上下限的引入 在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 上限 1234567891011121314151617class Info&lt;T extends Number&gt;&#123; // 此处泛型只能是数字类型 private T var ; // 定义泛型变量 public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; // 直接打印 return this.var.toString() ; &#125;&#125;public class demo1&#123; public static void main(String args[])&#123; Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ; // 声明Integer的泛型对象 &#125;&#125; 下限 12345678910111213141516171819202122232425class Info&lt;T&gt;&#123; private T var ; // 定义泛型变量 public void setVar(T var)&#123; this.var = var ; &#125; public T getVar()&#123; return this.var ; &#125; public String toString()&#123; // 直接打印 return this.var.toString() ; &#125;&#125;public class GenericsDemo21&#123; public static void main(String args[])&#123; Info&lt;String&gt; i1 = new Info&lt;String&gt;() ; // 声明String的泛型对象 Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ; // 声明Object的泛型对象 i1.setVar(&quot;hello&quot;) ; i2.setVar(new Object()) ; fun(i1) ; fun(i2) ; &#125; public static void fun(Info&lt;? super String&gt; temp)&#123; // 只能接收String或Object类型的泛型，String类的父类只有Object类 System.out.print(temp + &quot;, &quot;) ; &#125;&#125; 小结 123456789&lt;?&gt; 无限制通配符&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类// 使用原则《Effictive Java》// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。 再看一个实际例子，加深印象 123456789101112131415private &lt;E extends Comparable&lt;? super E&gt;&gt; E max(List&lt;? extends E&gt; e1) &#123; if (e1 == null)&#123; return null; &#125; //迭代器返回的元素属于 E 的某个子类型 Iterator&lt;? extends E&gt; iterator = e1.iterator(); E result = iterator.next(); while (iterator.hasNext())&#123; E next = iterator.next(); if (next.compareTo(result) &gt; 0)&#123; result = next; &#125; &#125; return result;&#125; 上述代码中的类型参数 E 的范围是&lt;E extends Comparable&lt;? super E&gt;&gt;，我们可以分步查看： 要进行比较，所以 E 需要是可比较的类，因此需要 extends Comparable&lt;…&gt;（注意这里不要和继承的 extends 搞混了，不一样） Comparable&lt; ? super E&gt; 要对 E 进行比较，即 E 的消费者，所以需要用 super 而参数 List&lt; ? extends E&gt; 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大 多个限制 使用&amp;符号 1234567891011public class Client &#123; //工资低于2500元的上斑族并且站立的乘客车票打8折 public static &lt;T extends Staff &amp; Passenger&gt; void discount(T t)&#123; if(t.getSalary()&lt;2500 &amp;&amp; t.isStanding())&#123; System.out.println(&quot;恭喜你！您的车票打八折！&quot;); &#125; &#125; public static void main(String[] args) &#123; discount(new Me()); &#125;&#125; 泛型数组 具体可以参考下文中关于泛型数组的理解。 首先，我们泛型数组相关的申明： 123456List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误，需要强转类型 List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告 那么通常我们如何用呢？ 讨巧的使用场景 123456789101112131415public class GenericsDemo30&#123; public static void main(String args[])&#123; Integer i[] = fun1(1,2,3,4,5,6) ; // 返回泛型数组 fun2(i) ; &#125; public static &lt;T&gt; T[] fun1(T...arg)&#123; // 接收可变参数 return arg ; // 返回泛型数组 &#125; public static &lt;T&gt; void fun2(T param[])&#123; // 输出 System.out.print(&quot;接收泛型数组：&quot;) ; for(T t:param)&#123; System.out.print(t + &quot;、&quot;) ; &#125; &#125; &#125; 合理使用 123public ArrayWithTypeToken(Class&lt;T&gt; type, int size) &#123; array = (T[]) Array.newInstance(type, size);&#125; 具体可以查看后文解释。 深入理解泛型 提示 我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。 如何理解Java中的泛型是伪泛型？泛型中类型擦除 Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“类型擦除”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。 泛型的类型擦除原则是： 消除类型参数声明，即删除&lt;&gt;及其包围的部分。 根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。 为了保证类型安全，必要时插入强制类型转换代码。 自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。 那么如何进行擦除的呢？ 参考自：http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/ 擦除类定义中的类型参数 - 无限制类型擦除 当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如&lt;T&gt;和&lt;?&gt;的类型参数都被替换为Object。 擦除类定义中的类型参数 - 有限制类型擦除 当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如&lt;T extends Number&gt;和&lt;? extends Number&gt;的类型参数被替换为Number，&lt;? super Number&gt;被替换为Object。 擦除方法定义中的类型参数 擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。 如何证明类型的擦除呢？ 我们通过两个例子证明Java类型的类型擦除 原始类型相等 12345678910111213public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(&quot;abc&quot;); ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(); list2.add(123); System.out.println(list1.getClass() == list2.getClass()); // true &#125;&#125; 在这个例子中，我们定义了两个ArrayList数组，不过一个是ArrayList&lt;String&gt;泛型类型的，只能存储字符串；一个是ArrayList&lt;Integer&gt;泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的getClass()方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。 通过反射添加其它类型元素 12345678910111213141516public class Test &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); &#125; &#125;&#125; 在程序中定义了一个ArrayList泛型类型实例化为Integer对象，如果直接调用add()方法，那么只能存储整数数据，不过当我们利用反射调用add()方法的时候，却可以存储字符串，这说明了Integer泛型实例在编译之后被擦除掉了，只保留了原始类型。 如何理解类型擦除后保留的原始类型? 在上面，两次提到了原始类型，什么是原始类型？ 原始类型 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。 原始类型Object 123456789class Pair&lt;T&gt; &#123; private T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; &#125; Pair的原始类型为: 123456789class Pair &#123; private Object value; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; &#125; 因为在Pair&lt;T&gt;中，T 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如Pair&lt;String&gt;或Pair&lt;Integer&gt;，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。 从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。 如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。 比如: Pair这样声明的话 1public class Pair&lt;T extends Comparable&gt; &#123;&#125; 那么原始类型就是Comparable。 要区分原始类型和泛型变量的类型。 在调用泛型方法时，可以指定泛型，也可以不指定泛型: 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; /**不指定泛型的时候*/ int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型 Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number Object o = Test.add(1, &quot;asd&quot;); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object /**指定泛型的时候*/ int a = Test.&lt;Integer&gt;add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类 int b = Test.&lt;Integer&gt;add(1, 2.2); //编译错误，指定了Integer，不能为Float Number c = Test.&lt;Number&gt;add(1, 2.2); //指定为Number，所以可以为Integer和Float &#125; //这是一个简单的泛型方法 public static &lt;T&gt; T add(T x,T y)&#123; return y; &#125; &#125; 其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。 Object泛型 123456public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(1); list.add(&quot;121&quot;); list.add(new Date()); &#125; 如何理解泛型的编译期检查？ 既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？ Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。 例如： 123456public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;123&quot;); list.add(123);//编译错误 &#125; 在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。 那么，这个类型检查是针对谁的呢？我们先看看参数化类型和原始类型的兼容。 以 ArrayList举例子，以前的写法: 1ArrayList list = new ArrayList(); 现在的写法: 1ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况： 12ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况 这样是没有错误的，不过会有个编译时警告。 不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。 因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。 举例子： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list1 = new ArrayList(); list1.add(&quot;1&quot;); //编译通过 list1.add(1); //编译错误 String str1 = list1.get(0); //返回类型就是String ArrayList list2 = new ArrayList&lt;String&gt;(); list2.add(&quot;1&quot;); //编译通过 list2.add(1); //编译通过 Object object = list2.get(0); //返回类型就是Object new ArrayList&lt;String&gt;().add(&quot;11&quot;); //编译通过 new ArrayList&lt;String&gt;().add(22); //编译错误 String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String &#125; &#125; 通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。 泛型中参数话类型为什么不考虑继承关系？ 在Java中，像下面形式的引用传递是不允许的: 12ArrayList&lt;String&gt; list1 = new ArrayList&lt;Object&gt;(); //编译错误 ArrayList&lt;Object&gt; list2 = new ArrayList&lt;String&gt;(); //编译错误 我们先看第一种情况，将第一种情况拓展成下面的形式： 1234ArrayList&lt;Object&gt; list1 = new ArrayList&lt;Object&gt;(); list1.add(new Object()); list1.add(new Object()); ArrayList&lt;String&gt; list2 = list1; //编译错误 实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有ClassCastException了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。 再看第二种情况，将第二种情况拓展成下面的形式： 12345ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(new String()); list1.add(new String());ArrayList&lt;Object&gt; list2 = list1; //编译错误 没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。 我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？ 所以，要格外注意，泛型中的引用传递的问题。 如何理解泛型的多态？泛型的桥接方法 类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。 现在有这样一个泛型类： 123456789101112class Pair&lt;T&gt; &#123; private T value; public T getValue() &#123; return value; &#125; public void setValue(T value) &#123; this.value = value; &#125; &#125; 然后我们想要一个子类继承它。 123456789101112class DateInter extends Pair&lt;Date&gt; &#123; @Override public void setValue(Date value) &#123; super.setValue(value); &#125; @Override public Date getValue() &#123; return super.getValue(); &#125; &#125; 在这个子类中，我们设定父类的泛型类型为Pair&lt;Date&gt;，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。 1234567public Date getValue() &#123; return value; &#125; public void setValue(Date value) &#123; this.value = value; &#125; 所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？ 分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子： 1234567891011class Pair &#123; private Object value; public Object getValue() &#123; return value; &#125; public void setValue(Object value) &#123; this.value = value; &#125; &#125; 再看子类的两个重写的方法的类型： 12345678@Override public void setValue(Date value) &#123; super.setValue(value); &#125; @Override public Date getValue() &#123; return super.getValue(); &#125; 先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下： 12345public static void main(String[] args) throws ClassNotFoundException &#123; DateInter dateInter = new DateInter(); dateInter.setValue(new Date()); dateInter.setValue(new Object()); //编译错误 &#125; 如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。 为什么会这样呢？ 原因是这样的，我们传入父类的泛型类型是Date，Pair&lt;Date&gt;，我们的本意是将泛型类变为如下： 123456789class Pair &#123; private Date value; public Date getValue() &#123; return value; &#125; public void setValue(Date value) &#123; this.value = value; &#125; &#125; 然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。 可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。 于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。 首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下： 1234567891011121314151617181920212223242526272829303132333435class com.tao.test.DateInter extends com.tao.test.Pair&lt;java.util.Date&gt; &#123; com.tao.test.DateInter(); Code: 0: aload_0 1: invokespecial #8 // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V 4: return public void setValue(java.util.Date); //我们重写的setValue方法 Code: 0: aload_0 1: aload_1 2: invokespecial #16 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V 5: return public java.util.Date getValue(); //我们重写的getValue方法 Code: 0: aload_0 1: invokespecial #23 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object; 4: checkcast #26 // class java/util/Date 7: areturn public java.lang.Object getValue(); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: invokevirtual #28 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法; 4: areturn public void setValue(java.lang.Object); //编译时由编译器生成的桥方法 Code: 0: aload_0 1: aload_1 2: checkcast #26 // class java/util/Date 5: invokevirtual #30 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V 8: return &#125; 从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。 所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。 不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。 setValue方法是为了解决类型擦除与多态之间的冲突。 而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系： 那么父类的getValue方法如下： 123public Object getValue() &#123; return super.getValue(); &#125; 而子类重写的方法是： 123public Date getValue() &#123; return super.getValue(); &#125; 其实这在普通的类继承中也是普遍存在的重写，这就是协变。 并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。 如何理解基本类型不能作为泛型类型？ 比如，我们没有ArrayList&lt;int&gt;，只有ArrayList&lt;Integer&gt;, 为何？ 因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。 另外需要注意，我们能够使用list.add(1)是因为Java基础类型的自动装箱拆箱操作。 如何理解泛型类型不能实例化？ 不能实例化泛型类型, 这本质上是由于类型擦除决定的： 我们可以看到如下代码会在编译器中报错： 1T test = new T(); // ERROR 因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于T 被擦除为 Object，如果可以 new T() 则就变成了 new Object()，失去了本意。 如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现： 1234static &lt;T&gt; T newTclass (Class &lt; T &gt; clazz) throws InstantiationException, IllegalAccessException &#123; T obj = clazz.newInstance(); return obj;&#125; 泛型数组：能不能采用具体的泛型类型进行初始化？我们先来看下Oracle官网提供的一个例子： 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(new Integer(3));oa[1] = li; // Unsound, but passes run time store checkString s = lsa[1].get(0); // Run-time error ClassCastException. 由于 JVM 泛型的擦除机制，所以上面代码可以给 oa[1] 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 ClassCastException，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 ClassCastException，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。 而对于下面的代码来说是成立的： 1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(new Integer(3));oa[1] = li; // Correct.Integer i = (Integer) lsa[1].get(0); // OK 所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。 Oracle 官方文档：https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开 更进一步的，我们看看如下的代码： 123456List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误，需要强转类型 List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告 因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。 泛型数组：如何正确的初始化泛型数组实例？ 这个无论我们通过new ArrayList[10] 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。 我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length) 方法来创建一个具有指定类型和维度的数组，如下： 1234567891011121314151617181920212223public class ArrayWithTypeToken&lt;T&gt; &#123; private T[] array; public ArrayWithTypeToken(Class&lt;T&gt; type, int size) &#123; array = (T[]) Array.newInstance(type, size); &#125; public void put(int index, T item) &#123; array[index] = item; &#125; public T get(int index) &#123; return array[index]; &#125; public T[] create() &#123; return array; &#125;&#125;//...ArrayWithTypeToken&lt;Integer&gt; arrayToken = new ArrayWithTypeToken&lt;Integer&gt;(Integer.class, 100);Integer[] array = arrayToken.create(); 所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 T在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。 如何理解泛型类中的静态方法和静态变量？ 泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数 举例说明： 123456public class Test2&lt;T&gt; &#123; public static T one; //编译错误 public static T show(T one)&#123; //编译错误 return null; &#125; &#125; 因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。 但是要注意区分下面的一种情况： 123456public class Test2&lt;T&gt; &#123; public static &lt;T &gt;T show(T one)&#123; //这是正确的 return null; &#125; &#125; 因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。 如何理解异常中使用泛型？ 不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译： 123public class Problem&lt;T&gt; extends Exception &#123;&#125; 为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义： 1234567try&#123;&#125; catch(Problem&lt;Integer&gt; e1) &#123;&#125; catch(Problem&lt;Number&gt; e2) &#123;&#125; 类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样 1234567try&#123;&#125; catch(Problem&lt;Object&gt; e1) &#123;&#125; catch(Problem&lt;Object&gt; e2) &#123;&#125; 这个当然就是不行的。 不能再catch子句中使用泛型变量 1234567public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t) &#123; try &#123; ... &#125; catch(T e) &#123; //编译错误 ... &#125;&#125; 因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢： 123456789public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t)&#123; try &#123; &#125; catch(T e) &#123; //编译错误 &#125; catch(IndexOutOfBounds e) &#123; &#125; &#125; 根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是ArrayIndexOutofBounds，在编译之后还是会变成Throwable，ArrayIndexOutofBounds是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。 但是在异常声明中可以使用类型变量。下面方法是合法的。 12345678public static&lt;T extends Throwable&gt; void doWork(T t) throws T &#123; try&#123; ... &#125; catch(Throwable realCause) &#123; t.initCause(realCause); throw t; &#125;&#125; 上面的这样使用是没问题的。 如何获取泛型的参数类型？ 既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（java.lang.reflect.Type）获取泛型 java.lang.reflect.Type是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。 12345678910111213141516171819public class GenericType&lt;T&gt; &#123; private T data; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; public static void main(String[] args) &#123; GenericType&lt;String&gt; genericType = new GenericType&lt;String&gt;() &#123;&#125;; Type superclass = genericType.getClass().getGenericSuperclass(); //getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer] Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0]; System.out.println(type);//class java.lang.String &#125;&#125; 其中 ParameterizedType: 12345678910public interface ParameterizedType extends Type &#123; // 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer] Type[] getActualTypeArguments(); //返回当前class或interface声明的类型, 如List&lt;?&gt;返回List Type getRawType(); //返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null Type getOwnerType();&#125; 参考文章 泛型作为Java基础知识点之一，网上知识点比较多也比较散，本文主要综合了网络上比较好的文章，方便你快速学习。（以下是一部分我参考的链接） https://blog.csdn.net/sunxianghuang/article/details/51982979 https://blog.csdn.net/LonelyRoamer/article/details/7868820 https://docs.oracle.com/javase/tutorial/extra/generics/index.html https://blog.csdn.net/s10461/article/details/53941091 https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html https://www.cnblogs.com/rudy-laura/articles/3391013.html https://www.jianshu.com/p/986f732ed2f1 https://blog.csdn.net/u011240877/article/details/53545041","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"3.Java 基础 - 图谱 & Q/A","path":"/2023/12/25/3.Java-基础-图谱-Q-A/","content":"本文主要对Java基础知识体系小结，同时结合一些Q&amp;A进行理解。 参考文档 Thinking in Java (Java 编程思想) Gitbook中文文档 https://java.quanke.name/ Thinking in Java (Java 编程思想) Github https://github.com/quanke/think-in-java Thinking in Java (Java 编程思想) Gitbook2 https://www.gitbook.com/book/wizardforcel/thinking-in-java/details 知识体系 Q&amp;AJava 中应该使用什么数据类型来代表价格?如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。 怎么将 byte 转换为 String?可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。 Java 中怎样将 bytes 转换为 long 类型?String接收bytes的构造器转成String，再Long.parseLong() 我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。 存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C &#x3D; (C) B；可以，向下转型。但是不建议使用，容易出现类型转型异常. 哪个类包含 clone 方法? 是 Cloneable 还是 Object?java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。 Java 中 ++ 操作符是线程安全的吗?不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。 a &#x3D; a + b 与 a +&#x3D; b 的区别+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。 1234byte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok (因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错) 我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。 3*0.1 &#x3D;&#x3D; 0.3 将会返回什么? true 还是 false?false，因为有些浮点数不能完全精确的表示出来。 int 和 Integer 哪个会占用更多的内存?Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。 为什么 Java 中的 String 是不可变的(Immutable)?Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。 我们能在 Switch 中使用 String 吗?从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。 Java 中的构造器链是什么?当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。 枚举类JDK1.5出现 每个枚举值都需要调用一次构造函数 什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。 如何在Java中写出Immutable的类? 要写出这样的类，需要遵循以下几个原则: 1)immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。 2)Immutable类的所有的属性都应该是final的。 3)对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。 4)对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。 5)如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例) 我们能创建一个包含可变对象的不可变对象吗?是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。 有没有可能两个不相等的对象有相同的 hashcode?有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。 两个相同的对象会有不同的 hashcode 吗?不能，根据 hashcode 的规定，这是不可能的。 我们可以在 hashcode() 中使用随机数字吗?不行，因为对象的 hashcode 值必须是相同的。 Java 中，Comparator 与 Comparable 有什么不同?Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。 为什么在重写 equals 方法的时候需要重写 hashCode 方法?因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。 “a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别?如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。 a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?简介: hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hashcode。 1、hashcode的作用 List和Set，如何保证Set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。 2、hashcode重要吗 对于数组、List集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。 3、equals方法遵循的原则 对称性 若x.equals(y)为true，则y.equals(x)为true 自反性 x.equals(x)必须true 传递性 若x.equals(y)为true,y.equals(z)为true,则x.equals(z)必为true 一致性 只要x,y内容不变，无论调用多少次结果不变 其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false final、finalize 和 finally 的不同之处? final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。 Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。 finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。 Java 中的编译期常量是什么? 使用它又什么风险?变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。 静态内部类与顶级类有什么区别?一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。 Java 中，Serializable 与 Externalizable 的区别?Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。 说出 JDK 1.7 中的三个新特性?虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。 说出 5 个 JDK 1.8 引入的新特性?Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性: Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。 下述包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。 接口是什么? 为什么要使用接口而不是直接使用具体类?接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许普通方法，以此来保证抽象，但是 Java 8 中你可以在接口声明静态方法和默认普通方法。 Java 中，抽象类与接口之间有什么不同?Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制 参见第六条。 Object有哪些公用方法?clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。 11个方法，wait被重载了两次 equals与&#x3D;&#x3D;的区别区别1. ==是一个运算符 equals是Object类的方法 区别2. 比较时的区别 用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。 用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。 String、StringBuffer与StringBuilder的区别第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。 第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。 switch能否用String做参数Java1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，int，枚举均可用于switch，而boolean和浮点型不可以。 接口与抽象类 一个子类只能继承一个抽象类, 但能实现多个接口 抽象类可以有构造方法, 接口没有构造方法 抽象类可以有普通成员变量, 接口没有普通成员变量 抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认) 抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法 抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用） 抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法 抽象类和最终类抽象类可以没有抽象方法, 最终类可以没有最终方法 最终类不能被继承, 最终方法不能被重写(可以重载) 异常相关的关键字 throw、throws、try...catch、finally throws 用在方法签名上, 以便抛出的异常可以被调用者处理 throw 方法内部通过throw抛出异常 try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块 关于finally finally不管有没有异常都要处理 当try和catch中有return时，finally仍然会执行，finally比return先执行 不管有木有异常抛出, finally在return返回前执行 finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的 注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值 finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电 受检查异常和运行时异常 受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。 常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException 运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… 常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕获。 super出现在父类的子类中。有三种存在方式 super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用 super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法 super() 调用父类构造 注: super只能指代其直接父类 this() &amp; super()在构造方法中的区别 调用super()必须写在子类构造方法的第一行, 否则编译不通过 super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行 尽管可以用this调用一个构造器, 却不能调用2个 this和super不能出现在同一个构造器中, 否则编译不通过 this()、super()都指的对象,不可以在static环境中使用 本质this指向本对象的指针。super是一个关键字 构造内部类和静态内部类对象12345678910111213public class Enclosingone &#123;\tpublic class Insideone &#123;&#125;\tpublic static class Insideone&#123;&#125;&#125;public class Test &#123;\tpublic static void main(String[] args) &#123;\t// 构造内部类对象需要外部类的引用\tEnclosingone.Insideone obj1 = new Enclosingone().new Insideone();\t// 构造静态内部类的对象\tEnclosingone.Insideone obj2 = new Enclosingone.Insideone();\t&#125;&#125; 静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。 序列化声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数 Java移位运算符java中有三种移位运算符 &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0 &gt;&gt; :带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1 &gt;&gt;&gt; :无符号右移,忽略符号位,空位都以0补齐 形参&amp;实参形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。 局部变量为什么要初始化局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。 Java语言的鲁棒性Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"2.Java 基础 - 知识点","path":"/2023/12/25/2.Java-基础-知识点/","content":"本文主要对Java基础知识点进行总结。 数据类型包装类型八个基本类型: boolean&#x2F;1 byte&#x2F;8 char&#x2F;16 short&#x2F;16 int&#x2F;32 float&#x2F;32 long&#x2F;64 double&#x2F;64 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 缓存池new Integer(123) 与 Integer.valueOf(123) 的区别在于: new Integer(123) 每次都会新建一个对象 Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下: boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。 如果在缓冲池之外： 123Integer m = 323;Integer n = 323;System.out.println(m == n); // false String概览String 被声明为 final，因此它不可被继承。 内部使用 char 数组存储数据**(Java 9 之后，String 类的实现改用 byte 数组存储字符串)**，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 不可变的好处1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 Program Creek : Why String is immutable in Java? String, StringBuffer and StringBuilder1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder String.intern()使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。 12345String s1 = new String(&quot;aaa&quot;);String s2 = new String(&quot;aaa&quot;);System.out.println(s1 == s2); // falseString s3 = s1.intern();System.out.println(s1.intern() == s3); // true 如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。 123String s4 = &quot;bbb&quot;;String s5 = &quot;bbb&quot;;System.out.println(s4 == s5); // true HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？ 运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。 不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。 HotSpot也是发展的，由于一些问题在新窗口打开的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格： JDK版本 是否有永久代，字符串常量池放在哪里？ 方法区逻辑上规范，由哪些实际的部分实现的？ jdk1.6及之前 有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上 这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代 jdk1.7 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中； 这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现 jdk1.8及之后 取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中 这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现 运算参数传递Java 的参数是以值传递的形式传入方法中，而不是引用传递。 以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。 1234567891011121314151617181920212223242526272829303132333435public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125;public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(&quot;B&quot;); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(&quot;A&quot;); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName(&quot;B&quot;); &#125;&#125; StackOverflow: Is Java “pass-by-reference” or “pass-by-value”? float 与 double1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。 1// float f = 1.1; 1.1f 字面量才是 float 类型。 1float f = 1.1f; 隐式类型转换因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。 12short s1 = 1;// s1 = s1 + 1; 但是使用 += 运算符可以执行隐式类型转换。 1s1 += 1; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型: 1s1 = (short) (s1 + 1); StackOverflow : Why don’t Java’s +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; compound assignment operators require casting? switch从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = &quot;a&quot;;switch (s) &#123; case &quot;a&quot;: System.out.println(&quot;aaa&quot;); break; case &quot;b&quot;: System.out.println(&quot;bbb&quot;); break;&#125; switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 123456789// long x = 111;// switch (x) &#123; // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;// case 111:// System.out.println(111);// break;// case 222:// System.out.println(222);// break;// &#125; StackOverflow : Why can’t your switch statement data type be long, Java? 继承访问权限Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员(字段以及方法)加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 123456789101112public class AccessExample &#123; private int id; public String getId() &#123; return id + &quot;&quot;; &#125; public void setId(String id) &#123; this.id = Integer.valueOf(id); &#125;&#125; 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 123456789101112131415public class AccessWithInnerClassExample &#123; private class InnerClass &#123; int x; &#125; private InnerClass innerClass; public AccessWithInnerClassExample() &#123; innerClass = new InnerClass(); &#125; public int getValue() &#123; return innerClass.x; // 直接访问 &#125;&#125; 抽象类与接口1. 抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。 1234567891011121314151617181920public abstract class AbstractClassExample &#123; protected int x; private int y; public abstract void func1(); public void func2() &#123; System.out.println(&quot;func2&quot;); &#125;&#125;public class AbstractExtendClassExample extends AbstractClassExample &#123; @Override public void func1() &#123; System.out.println(&quot;func1&quot;); &#125;&#125;// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiatedAbstractClassExample ac2 = new AbstractExtendClassExample();ac2.func1(); 2. 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415161718192021222324public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println(&quot;func2&quot;); &#125; int x = 123; // int y; // Variable &#x27;y&#x27; might not have been initialized public int z = 0; // Modifier &#x27;public&#x27; is redundant for interface fields // private int k = 0; // Modifier &#x27;private&#x27; not allowed here // protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here // private void fun3(); // Modifier &#x27;private&#x27; not allowed here&#125;public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println(&quot;func1&quot;); &#125;&#125;// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择 使用接口: 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类: 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 深入理解 abstract class 和 interface When to Use Abstract Class and Interface super 访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。 访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。 12345678910111213141516171819202122232425262728293031public class SuperExample &#123; protected int x; protected int y; public SuperExample(int x, int y) &#123; this.x = x; this.y = y; &#125; public void func() &#123; System.out.println(&quot;SuperExample.func()&quot;); &#125;&#125;public class SuperExtendExample extends SuperExample &#123; private int z; public SuperExtendExample(int x, int y, int z) &#123; super(x, y); this.z = z; &#125; @Override public void func() &#123; super.func(); System.out.println(&quot;SuperExtendExample.func()&quot;); &#125;&#125;SuperExample e = new SuperExtendExample(1, 2, 3);e.func();SuperExample.func()SuperExtendExample.func() Using the Keyword super 重写与重载1. 重写(Override) 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有以下两个限制: 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。 2. 重载(Overload) 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 Object 通用方法概览123456789101112131415161718192021public final native Class&lt;?&gt; getClass()public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedExceptionprotected void finalize() throws Throwable &#123;&#125; equals()1. 等价关系 (一)自反性 1x.equals(x); // true (二)对称性 1x.equals(y) == y.equals(x); // true (三)传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; (四)一致性 多次调用 equals() 方法结果不变 1x.equals(y) == x.equals(y); // true (五)与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false 1x.equals(null); // false; 2. equals() 与 == 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 1234567891011121314151617181920212223public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法: 31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 12345678910public class ToStringExample &#123; private int number; public ToStringExample(int number) &#123; this.number = number; &#125;&#125;ToStringExample example = new ToStringExample(123);System.out.println(example.toString());ToStringExample@4554617c clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 123456public class CloneExample &#123; private int a; private int b;&#125;CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27; 重写 clone() 得到以下实现: 12345678910111213141516public class CloneExample &#123; private int a; private int b; @Override protected CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125;CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 1234567891011121314151617181920212223242526272829303132public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125;ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 12345678910111213141516171819202122232425262728293031323334353637public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125;DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526272829public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125;CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 关键字final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable &#x27;x&#x27;final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 static1. 静态变量 静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。 实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。 1234567891011public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field &#x27;x&#x27; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 12345678910public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field &#x27;y&#x27; cannot be referenced from a static context // int b = this.y; // &#x27;A.this&#x27; cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 1234567891011public class A &#123; static &#123; System.out.println(&quot;123&quot;); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125;123 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 1234567891011121314public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 12345678public static String staticField = &quot;静态变量&quot;;static &#123; System.out.println(&quot;静态语句块&quot;);&#125;public String field = &quot;实例变量&quot;;&#123; System.out.println(&quot;普通语句块&quot;);&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(&quot;构造函数&quot;);&#125; 存在继承的情况下，初始化顺序为: 父类(静态变量、静态语句块) 子类(静态变量、静态语句块) 父类(实例变量、普通语句块) 父类(构造函数) 子类(实例变量、普通语句块) 子类(构造函数) 反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类: Field : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method : 可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor : 可以用 Constructor 创建新的对象。 Advantages of Using Reflection: Extensibility Features : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names. Class Browsers and Visual Development Environments : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code. Debuggers and Test Tools : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite. Drawbacks of Reflection: Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection. Performance Overhead : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications. Security Restrictions : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet. Exposure of Internals :Since reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform. 相关文章：Java 基础 - 反射机制详解 异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种: 受检异常 : 需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 : 是程序运行时错误，例如除 0 会引发 ArithmeticException，此时程序崩溃并且无法恢复。 相关文章：Java 基础 - 异常机制详解 泛型123456public class Box&lt;T&gt; &#123; // T stands for &quot;Type&quot; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 相关文章：Java 基础 - 泛型机制详解 注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 相关文章：Java 基础 - 注解机制详解 特性Java 各版本的新特性New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7?在新窗口打开 Java 8 特性在新窗口打开 Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 What are the main differences between Java and C++? JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac” 参考资料 Eckel B. Java 编程思想[M]. 机械工业出版社, 2002. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"1.Java 基础 - 面向对象","path":"/2023/12/25/1.Java-基础-面向对象/","content":"本文主要介绍Java OOP 面向对象基础和相关类图。 三大特性封装利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 优点: 减少耦合: 可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块 有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的 以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。 注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。 12345678910111213141516171819202122public class Person &#123; private String name; private int gender; private int age; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender == 0 ? &quot;man&quot; : &quot;woman&quot;; &#125; public void work() &#123; if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123; System.out.println(name + &quot; is working very hard!&quot;); &#125; else &#123; System.out.println(name + &quot; can&#x27;t work any more!&quot;); &#125; &#125;&#125; 继承继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。 Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。 1Animal animal = new Cat(); 多态多态分为编译时多态和运行时多态: 编译时多态主要指方法的重载 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定 运行时多态有三个条件: 继承 覆盖(重写) 向上转型 下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。 12345678910111213141516171819202122232425262728public class Instrument &#123; public void play() &#123; System.out.println(&quot;Instrument is playing...&quot;); &#125;&#125;public class Wind extends Instrument &#123; public void play() &#123; System.out.println(&quot;Wind is playing...&quot;); &#125;&#125;public class Percussion extends Instrument &#123; public void play() &#123; System.out.println(&quot;Percussion is playing...&quot;); &#125;&#125;public class Music &#123; public static void main(String[] args) &#123; List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) &#123; instrument.play(); &#125; &#125;&#125; 类图以下类图使用 PlantUML在新窗口打开 绘制，更多语法及使用请参考: http://plantuml.com/ 。 泛化关系 (Generalization)用来描述继承关系，在 Java 中使用 extends 关键字。 123456789101112@startumltitle Generalizationclass Vehicalclass Carclass TruckVehical &lt;|-- CarVehical &lt;|-- Truck@enduml 实现关系 (Realization)用来实现一个接口，在 Java 中使用 implements 关键字。 123456789101112@startumltitle Realizationinterface MoveBehaviorclass Flyclass RunMoveBehavior &lt;|.. FlyMoveBehavior &lt;|.. Run@enduml 聚合关系 (Aggregation)表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。 1234567891011121314@startumltitle Aggregationclass Computerclass Keyboardclass Mouseclass ScreenComputer o-- KeyboardComputer o-- MouseComputer o-- Screen@enduml 组合关系 (Composition)和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。 123456789101112@startumltitle Compositionclass Companyclass DepartmentAclass DepartmentBCompany *-- DepartmentACompany *-- DepartmentB@enduml 关联关系 (Association)表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 12345678910@startumltitle Associationclass Schoolclass StudentSchool &quot;1&quot; - &quot;n&quot; Student@enduml 依赖关系 (Dependency)和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式: A 类是 B 类中的(某中方法的)局部变量； A 类是 B 类方法当中的一个参数； A 类向 B 类发送消息，从而影响 B 类发生变化； 12345678910111213141516171819@startumltitle Dependencyclass Vehicle &#123; move(MoveBehavior)&#125;interface MoveBehavior &#123; move()&#125;note &quot;MoveBehavior.move()&quot; as NVehicle ..&gt; MoveBehaviorVehicle .. N@enduml # 参考资料 Java 编程思想 敏捷软件开发: 原则、模式与实践 面向对象设计的 SOLID 原则在新窗口打开 看懂 UML 类图和时序图在新窗口打开 UML 系列——时序图(顺序图)sequence diagram在新窗口打开 面向对象编程三大特性 —— 封装、继承、多态在新窗口打开 javaoop基础知识总结 https://blog.csdn.net/weixin_38173324/article/details/70037927 Java实现OOP(面向对象编程) https://www.cnblogs.com/AlanLee/p/6475334.html Java 抽象类与oop三大特征 http://www.cnblogs.com/wujing-hubei/p/6012105.html","tags":["Java","Java基础"],"categories":["Java","Java基础"]},{"title":"Spring Boot 无侵入式 实现 API 接口统一 JSON 格式返回","path":"/2023/12/25/Spring-Boot-无侵入式-实现-API-接口统一-JSON-格式返回/","content":"无侵入式 统一返回JSON格式其实本没有没打算写这篇博客的，但还是要写一下写这篇博客的起因是因为，现在呆着的这家公司居然没有统一的API返回格式?，询问主管他居然告诉我用HTTP状态码就够用了（fxxk），天哪HTTP状态码真的够用吗？ 在仔细的阅读了项目源码后发现，在API请求的是居然没有业务异常（黑人问好）。好吧 居然入坑了只能遵照项目风格了，懒得吐槽了。 因为项目已经开发了半年多了, 要是全部接口都做修改工作量还是挺大的, 只能用这种无侵入式的方案来解决. 项目源代码: https://github.com/469753862/galaxy-blogs/tree/master/code/responseResult 定义JSON格式定义返回JSON格式后端返回给前端一般情况下使用JSON格式, 定义如下 1234567&#123; &quot;code&quot;: 200, &quot;message&quot;: &quot;OK&quot;, &quot;data&quot;: &#123; &#125;&#125; code: 返回状态码 message: 返回信息的描述 data: 返回值 定义JavaBean字段定义状态码枚举类123456789101112131415161718192021@ToString@Getterpublic enum ResultStatus &#123; SUCCESS(HttpStatus.OK, 200, &quot;OK&quot;), BAD_REQUEST(HttpStatus.BAD_REQUEST, 400, &quot;Bad Request&quot;), INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR, 500, &quot;Internal Server Error&quot;),; /** 返回的HTTP状态码, 符合http请求 */ private HttpStatus httpStatus; /** 业务异常码 */ private Integer code; /** 业务异常信息描述 */ private String message; ResultStatus(HttpStatus httpStatus, Integer code, String message) &#123; this.httpStatus = httpStatus; this.code = code; this.message = message; &#125;&#125; 状态码和信息以及http状态码就能一一对应了便于维护, 有同学有疑问了为什么要用到http状态码呀,因为我要兼容项目以前的代码, 没有其他原因, 当然其他同学不喜欢http状态码的可以吧源码中HttpStatus给删除了 定义返回体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Getter@ToStringpublic class Result&lt;T&gt; &#123; /** 业务错误码 */ private Integer code; /** 信息描述 */ private String message; /** 返回参数 */ private T data; private Result(ResultStatus resultStatus, T data) &#123; this.code = resultStatus.getCode(); this.message = resultStatus.getMessage(); this.data = data; &#125; /** 业务成功返回业务代码和描述信息 */ public static Result&lt;Void&gt; success() &#123; return new Result&lt;Void&gt;(ResultStatus.SUCCESS, null); &#125; /** 业务成功返回业务代码,描述和返回的参数 */ public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; return new Result&lt;T&gt;(ResultStatus.SUCCESS, data); &#125; /** 业务成功返回业务代码,描述和返回的参数 */ public static &lt;T&gt; Result&lt;T&gt; success(ResultStatus resultStatus, T data) &#123; if (resultStatus == null) &#123; return success(data); &#125; return new Result&lt;T&gt;(resultStatus, data); &#125; /** 业务异常返回业务代码和描述信息 */ public static &lt;T&gt; Result&lt;T&gt; failure() &#123; return new Result&lt;T&gt;(ResultStatus.INTERNAL_SERVER_ERROR, null); &#125; /** 业务异常返回业务代码,描述和返回的参数 */ public static &lt;T&gt; Result&lt;T&gt; failure(ResultStatus resultStatus) &#123; return failure(resultStatus, null); &#125; /** 业务异常返回业务代码,描述和返回的参数 */ public static &lt;T&gt; Result&lt;T&gt; failure(ResultStatus resultStatus, T data) &#123; if (resultStatus == null) &#123; return new Result&lt;T&gt;(ResultStatus.INTERNAL_SERVER_ERROR, null); &#125; return new Result&lt;T&gt;(resultStatus, data); &#125;&#125; 因为使用构造方法进行创建对象太麻烦了, 我们使用静态方法来创建对象这样简单明了 Result实体返回测试1234567891011121314151617181920212223@RestController@RequestMapping(&quot;/hello&quot;)public class HelloController &#123; private static final HashMap&lt;String, Object&gt; INFO; static &#123; INFO = new HashMap&lt;&gt;(); INFO.put(&quot;name&quot;, &quot;galaxy&quot;); INFO.put(&quot;age&quot;, &quot;70&quot;); &#125; @GetMapping(&quot;/hello&quot;) public Map&lt;String, Object&gt; hello() &#123; return INFO; &#125; @GetMapping(&quot;/result&quot;) @ResponseBody public Result&lt;Map&lt;String, Object&gt;&gt; helloResult() &#123; return Result.success(INFO); &#125;&#125; 到这里我们已经简单的实现了统一JSON格式了, 但是我们也发现了一个问题了,想要返回统一的JSON格式需要返回Result&lt;Object&gt;才可以, 我明明返回Object可以了, 为什么要重复劳动, 有没有解决方法, 当然是有的啦, 下面我们开始优化我们的代码吧 统一返回JSON格式进阶-全局处理(@RestControllerAdvice)我师傅经常告诉我的一句话: “你就是一个小屁孩, 你遇到的问题都已经不知道有多少人遇到过了, 你会想到的问题, 已经有前辈想到过了. 你准备解决的问题, 已经有人把坑填了”。是不是很鸡汤, 是不是很励志, 让我对前辈们充满着崇拜, 事实上他对我说的是: “自己去百度”, 这五个大字, 其实这五个大字已经说明上明的B话了, 通过不断的百度和Google发现了很多的解决方案. 我们都知道使用@ResponseBody注解会把返回Object序列化成JSON字符串,就先从这个入手吧, 大致就是在序列化前把Object赋值给Result&lt;Object&gt;就可以了, 大家可以观摩org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice和org.springframework.web.bind.annotation.ResponseBody @ResponseBody继承类我们已经决定从@ResponseBody注解入手了就创建一个注解类继承@ResponseBody, 很干净什么都没有哈哈,@ResponseResultBody 可以标记在类和方法上这样我们就可以跟自由的进行使用了 1234567@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@ResponseBodypublic @interface ResponseResultBody &#123;&#125; ResponseBodyAdvice继承类12345678910111213141516171819202122232425@RestControllerAdvicepublic class ResponseResultBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; private static final Class&lt;? extends Annotation&gt; ANNOTATION_TYPE = ResponseResultBody.class; /** * 判断类或者方法是否使用了 @ResponseResultBody */ @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ANNOTATION_TYPE) || returnType.hasMethodAnnotation(ANNOTATION_TYPE); &#125; /** * 当类或者方法使用了 @ResponseResultBody 就会调用这个方法 */ @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; // 防止重复包裹的问题出现 if (body instanceof Result) &#123; return body; &#125; return Result.success(body); &#125;&#125; RestControllerAdvice返回测试12345678910111213141516171819202122232425262728293031323334@RestController@RequestMapping(&quot;/helloResult&quot;)@ResponseResultBodypublic class HelloResultController &#123; private static final HashMap&lt;String, Object&gt; INFO; static &#123; INFO = new HashMap&lt;String, Object&gt;(); INFO.put(&quot;name&quot;, &quot;galaxy&quot;); INFO.put(&quot;age&quot;, &quot;70&quot;); &#125; @GetMapping(&quot;hello&quot;) public HashMap&lt;String, Object&gt; hello() &#123; return INFO; &#125; /** 测试重复包裹 */ @GetMapping(&quot;result&quot;) public Result&lt;Map&lt;String, Object&gt;&gt; helloResult() &#123; return Result.success(INFO); &#125; @GetMapping(&quot;helloError&quot;) public HashMap&lt;String, Object&gt; helloError() throws Exception &#123; throw new Exception(&quot;helloError&quot;); &#125; @GetMapping(&quot;helloMyError&quot;) public HashMap&lt;String, Object&gt; helloMyError() throws Exception &#123; throw new ResultException(); &#125;&#125; 是不是很神奇, 直接返回Object就可以统一JSON格式了, 就不用每个返回都返回Result&lt;T&gt;对象了,直接让SpringMVC帮助我们进行统一的管理, 简直完美 只想看接口哦, helloError和helloMyError是会直接抛出异常的接口,我好像没有对异常返回进行统一的处理哦 统一返回JSON格式进阶-异常处理(@ExceptionHandler))卧槽, 异常处理, 差点把这茬给忘了, 这个异常处理就有很多方法了,先看看我师傅的处理方式, 我刚拿到这个代码的时候很想吐槽, 对异常类的处理这么残暴的吗, 直接用PrintWriter直接输出结果, 果然是老师傅, 我要是有100个异常类, 不得要写100个 if else了. 赶紧改改睡吧 1234567891011121314151617181920212223242526272829@Configurationpublic class MyExceptionHandler implements HandlerExceptionResolver &#123; public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; PrintWriter out = getPrintWrite(response); if (ex instanceof XXXException) &#123; out.write(JsonUtil.formatJson(ResultEnum.PAY_ERROR.getCode(), ex.getMessage())); &#125; else &#123; out.write(JsonUtil.formatJson(ResultEnum.FAIL.getCode(), &quot;服务器异常&quot;)); &#125; if (null != out) &#123; out.close(); &#125; return mav; &#125; private PrintWriter getPrintWrite(HttpServletResponse response) &#123; PrintWriter out = null; try &#123; response.setHeader(&quot;Content-type&quot;, &quot;text/html;charset=UTF-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); out = response.getWriter(); &#125; catch (IOException e) &#123; log.error(&quot;PrintWriter is exception&quot;, e); &#125; return out; &#125;&#125; 上面的代码看看还是没有问题的, 别学过去哦, 异常处理@ResponseStatus(不推荐)@ResponseStatus用法如下,可用在Controller类和Controller方法上以及Exception类上但是这样的工作量还是挺大的 12345678910111213141516171819202122232425262728293031323334@RestController@RequestMapping(&quot;/error&quot;)@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR, reason = &quot;Java的异常&quot;)public class HelloExceptionController &#123; private static final HashMap&lt;String, Object&gt; INFO; static &#123; INFO = new HashMap&lt;String, Object&gt;(); INFO.put(&quot;name&quot;, &quot;galaxy&quot;); INFO.put(&quot;age&quot;, &quot;70&quot;); &#125; @GetMapping() public HashMap&lt;String, Object&gt; helloError() throws Exception &#123; throw new Exception(&quot;helloError&quot;); &#125; @GetMapping(&quot;helloJavaError&quot;) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR, reason = &quot;Java的异常&quot;) public HashMap&lt;String, Object&gt; helloJavaError() throws Exception &#123; throw new Exception(&quot;helloError&quot;); &#125; @GetMapping(&quot;helloMyError&quot;) public HashMap&lt;String, Object&gt; helloMyError() throws Exception &#123; throw new MyException(); &#125;&#125;@ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR, reason = &quot;自己定义的异常&quot;)class MyException extends Exception &#123;&#125; 全局异常处理@ExceptionHandler(推荐)把ResponseResultBodyAdvice类进行改造一下,代码有点多了 主要参考了org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleException()方法, 有空可以看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Slf4j@RestControllerAdvicepublic class ResponseResultBodyAdvice implements ResponseBodyAdvice&lt;Object&gt; &#123; private static final Class&lt;? extends Annotation&gt; ANNOTATION_TYPE = ResponseResultBody.class; /** 判断类或者方法是否使用了 @ResponseResultBody */ @Override public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) &#123; return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ANNOTATION_TYPE) || returnType.hasMethodAnnotation(ANNOTATION_TYPE); &#125; /** 当类或者方法使用了 @ResponseResultBody 就会调用这个方法 */ @Override public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) &#123; if (body instanceof Result) &#123; return body; &#125; return Result.success(body); &#125; /** * 提供对标准Spring MVC异常的处理 * * @param ex the target exception * @param request the current request */ @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Result&lt;?&gt;&gt; exceptionHandler(Exception ex, WebRequest request) &#123; log.error(&quot;ExceptionHandler: &#123;&#125;&quot;, ex.getMessage()); HttpHeaders headers = new HttpHeaders(); if (ex instanceof ResultException) &#123; return this.handleResultException((ResultException) ex, headers, request); &#125; // TODO: 2019/10/05 galaxy 这里可以自定义其他的异常拦截 return this.handleException(ex, headers, request); &#125; /** 对ResultException类返回返回结果的处理 */ protected ResponseEntity&lt;Result&lt;?&gt;&gt; handleResultException(ResultException ex, HttpHeaders headers, WebRequest request) &#123; Result&lt;?&gt; body = Result.failure(ex.getResultStatus()); HttpStatus status = ex.getResultStatus().getHttpStatus(); return this.handleExceptionInternal(ex, body, headers, status, request); &#125; /** 异常类的统一处理 */ protected ResponseEntity&lt;Result&lt;?&gt;&gt; handleException(Exception ex, HttpHeaders headers, WebRequest request) &#123; Result&lt;?&gt; body = Result.failure(); HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR; return this.handleExceptionInternal(ex, body, headers, status, request); &#125; /** * org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler#handleExceptionInternal(java.lang.Exception, java.lang.Object, org.springframework.http.HttpHeaders, org.springframework.http.HttpStatus, org.springframework.web.context.request.WebRequest) * &lt;p&gt; * A single place to customize the response body of all exception types. * &lt;p&gt;The default implementation sets the &#123;@link WebUtils#ERROR_EXCEPTION_ATTRIBUTE&#125; * request attribute and creates a &#123;@link ResponseEntity&#125; from the given * body, headers, and status. */ protected ResponseEntity&lt;Result&lt;?&gt;&gt; handleExceptionInternal( Exception ex, Result&lt;?&gt; body, HttpHeaders headers, HttpStatus status, WebRequest request) &#123; if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) &#123; request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, ex, WebRequest.SCOPE_REQUEST); &#125; return new ResponseEntity&lt;&gt;(body, headers, status); &#125;&#125;","tags":["框架","Spring","分布式","微服务","SpringBoot"],"categories":["框架","Spring","SpringBoot"]},{"title":"Redis 分布式锁使用不当，酿成一个重大事故","path":"/2023/12/25/Redis-分布式锁使用不当，酿成一个重大事故/","content":"基于Redis使用分布式锁在当今已经不是什么新鲜事了。 本篇文章主要是基于我们实际项目中因为redis分布式锁造成的事故分析及解决方案。我们项目中的抢购订单采用的是分布式锁来解决的，有一次，运营做了一个飞天茅台的抢购活动，库存100瓶，但是却超卖了100瓶！要知道，这个地球上飞天茅台的稀缺性啊！！！ 事故定为P0级重大事故…只能坦然接受。整个项目组被扣绩效了~~事故发生后，CTO指名点姓让我带头冲锋来处理。 好吧，冲~ 事故现场经过一番了解后，得知这个抢购活动接口以前从来没有出现过这种情况，但是这次为什么会超卖呢？ 原因在于：之前的抢购商品都不是什么稀缺性商品，而这次活动居然是飞天茅台，通过埋点数据分析，各项数据基本都是成倍增长，活动热烈程度可想而知！话不多说，直接上核心代码，机密部分做了伪代码处理。。。 12345678910111213141516171819202122232425262728public SeckillActivityRequestVO seckillHandle(SeckillActivityRequestVO request) &#123; SeckillActivityRequestVO response; String key = &quot;key:&quot; + request.getSeckillId; try &#123; Boolean lockFlag = redisTemplate.opsForValue().setIfAbsent(key, &quot;val&quot;, 10, TimeUnit.SECONDS); if (lockFlag) &#123; // HTTP请求用户服务进行用户相关的校验 // 用户活动校验 // 库存校验 Object stock = redisTemplate.opsForHash().get(key+&quot;:info&quot;, &quot;stock&quot;); assert stock != null; if (Integer.parseInt(stock.toString()) &lt;= 0) &#123; // 业务异常 &#125; else &#123; redisTemplate.opsForHash().increment(key+&quot;:info&quot;, &quot;stock&quot;, -1); // 生成订单 // 发布订单创建成功事件 // 构建响应VO &#125; &#125; &#125; finally &#123; // 释放锁 stringRedisTemplate.delete(&quot;key&quot;); // 构建响应VO &#125; return response;&#125; 以上代码，通过分布式锁过期时间有效期10s来保障业务逻辑有足够的执行时间；采用try-finally语句块保证锁一定会及时释放。业务代码内部也对库存进行了校验。看起来很安全啊~ 别急，继续分析。。。 事故原因飞天茅台抢购活动吸引了大量新用户下载注册我们的APP，其中，不乏很多羊毛党，采用专业的手段来注册新用户来薅羊毛和刷单。当然我们的用户系统提前做好了防备，接入阿里云人机验证、三要素认证以及自研的风控系统等各种十八般武艺，挡住了大量的非法用户。此处不禁点个赞~ 但也正因如此，让用户服务一直处于较高的运行负载中。 抢购活动开始的一瞬间，大量的用户校验请求打到了用户服务。导致用户服务网关出现了短暂的响应延迟，有些请求的响应时长超过了10s，但由于HTTP请求的响应超时我们设置的是30s，这就导致接口一直阻塞在用户校验那里，10s后，分布式锁已经失效了，此时有新的请求进来是可以拿到锁的，也就是说锁被覆盖了。这些阻塞的接口执行完之后，又会执行释放锁的逻辑，这就把其他线程的锁释放了，导致新的请求也可以竞争到锁~这真是一个极其恶劣的循环。这个时候只能依赖库存校验，但是偏偏库存校验不是非原子性的，采用的是get and compare 的方式，超卖的悲剧就这样发生了~~~ 事故分析仔细分析下来，可以发现，这个抢购接口在高并发场景下，是有严重的安全隐患的，主要集中在三个地方： 没有其他系统风险容错处理 由于用户服务吃紧，网关响应延迟，但没有任何应对方式，这是超卖的导火索。 看似安全的分布式锁其实一点都不安全 虽然采用了set key value [EX seconds] [PX milliseconds] [NX|XX]的方式，但是如果线程A执行的时间较长没有来得及释放，锁就过期了，此时线程B是可以获取到锁的。当线程A执行完成之后，释放锁，实际上就把线程B的锁释放掉了。这个时候，线程C又是可以获取到锁的，而此时如果线程B执行完释放锁实际上就是释放的线程C设置的锁。这是超卖的直接原因。 非原子性的库存校验 非原子性的库存校验导致在并发场景下，库存校验的结果不准确。这是超卖的根本原因。 通过以上分析，问题的根本原因在于库存校验严重依赖了分布式锁。因为在分布式锁正常set、del的情况下，库存校验是没有问题的。但是，当分布式锁不安全可靠的时候，库存校验就没有用了。 解决方案知道了原因之后，我们就可以对症下药了。 实现相对安全的分布式锁相对安全的定义：set、del是一一映射的，不会出现把其他现成的锁del的情况。从实际情况的角度来看，即使能做到set、del一一映射，也无法保障业务的绝对安全。因为锁的过期时间始终是有界的，除非不设置过期时间或者把过期时间设置的很长，但这样做也会带来其他问题。故没有意义。要想实现相对安全的分布式锁，必须依赖key的value值。在释放锁的时候，通过value值的唯一性来保证不会勿删。我们基于LUA脚本实现原子性的get and compare，如下： 12345public void safedUnLock(String key, String val) &#123; String luaScript = &quot;local in = ARGV[1] local curr=redis.call(&#x27;get&#x27;, KEYS[1]) if in==curr then redis.call(&#x27;del&#x27;, KEYS[1]) end return &#x27;OK&#x27;&quot;&quot;; RedisScript&lt;String&gt; redisScript = RedisScript.of(luaScript); redisTemplate.execute(redisScript, Collections.singletonList(key), Collections.singleton(val));&#125; 我们通过LUA脚本来实现安全地解锁。 实现安全的库存校验如果我们对于并发有比较深入的了解的话，会发现想 get and compare&#x2F; read and save 等操作，都是非原子性的。如果要实现原子性，我们也可以借助LUA脚本来实现。但就我们这个例子中，由于抢购活动一单只能下1瓶，因此可以不用基于LUA脚本实现而是基于redis本身的原子性。原因在于： 12// redis会返回操作之后的结果，这个过程是原子性的Long currStock = redisTemplate.opsForHash().increment(&quot;key&quot;, &quot;stock&quot;, -1); 发现没有，代码中的库存校验完全是“画蛇添足”。 改进之后的代码经过以上的分析之后，我们决定新建一个DistributedLocker类专门用于处理分布式锁。 123456789101112131415161718192021222324252627public SeckillActivityRequestVO seckillHandle(SeckillActivityRequestVO request) &#123; SeckillActivityRequestVO response; String key = &quot;key:&quot; + request.getSeckillId(); String val = UUID.randomUUID().toString(); try &#123; Boolean lockFlag = distributedLocker.lock(key, val, 10, TimeUnit.SECONDS); if (!lockFlag) &#123; // 业务异常 &#125; // 用户活动校验 // 库存校验，基于redis本身的原子性来保证 Long currStock = stringRedisTemplate.opsForHash().increment(key + &quot;:info&quot;, &quot;stock&quot;, -1); if (currStock &lt; 0) &#123; // 说明库存已经扣减完了。 // 业务异常。 log.error(&quot;[抢购下单] 无库存&quot;); &#125; else &#123; // 生成订单 // 发布订单创建成功事件 // 构建响应 &#125; &#125; finally &#123; distributedLocker.safedUnLock(key, val); // 构建响应 &#125; return response;&#125; 深度思考分布式锁有必要么改进之后，其实可以发现，我们借助于redis本身的原子性扣减库存，也是可以保证不会超卖的。对的。但是如果没有这一层锁的话，那么所有请求进来都会走一遍业务逻辑，由于依赖了其他系统，此时就会造成对其他系统的压力增大。这会增加的性能损耗和服务不稳定性，得不偿失。基于分布式锁可以在一定程度上拦截一些流量。 分布式锁的选型有人提出用RedLock来实现分布式锁。RedLock的可靠性更高，但其代价是牺牲一定的性能。在本场景，这点可靠性的提升远不如性能的提升带来的性价比高。如果对于可靠性极高要求的场景，则可以采用RedLock来实现。 再次思考分布式锁有必要么由于bug需要紧急修复上线，因此我们将其优化并在测试环境进行了压测之后，就立马热部署上线了。实际证明，这个优化是成功的，性能方面略微提升了一些，并在分布式锁失效的情况下，没有出现超卖的情况。然而，还有没有优化空间呢？有的！由于服务是集群部署，我们可以将库存均摊到集群中的每个服务器上，通过广播通知到集群的各个服务器。网关层基于用户ID做hash算法来决定请求到哪一台服务器。这样就可以基于应用缓存来实现库存的扣减和判断。性能又进一步提升了！ 12345678910111213141516171819202122232425// 通过消息提前初始化好，借助ConcurrentHashMap实现高效线程安全private static ConcurrentHashMap&lt;Long, Boolean&gt; SECKILL_FLAG_MAP = new ConcurrentHashMap&lt;&gt;();// 通过消息提前设置好。由于AtomicInteger本身具备原子性，因此这里可以直接使用HashMapprivate static Map&lt;Long, AtomicInteger&gt; SECKILL_STOCK_MAP = new HashMap&lt;&gt;();...public SeckillActivityRequestVO seckillHandle(SeckillActivityRequestVO request) &#123; SeckillActivityRequestVO response; Long seckillId = request.getSeckillId(); if(!SECKILL_FLAG_MAP.get(requestseckillId)) &#123; // 业务异常 &#125; // 用户活动校验 // 库存校验 if(SECKILL_STOCK_MAP.get(seckillId).decrementAndGet() &lt; 0) &#123; SECKILL_FLAG_MAP.put(seckillId, false); // 业务异常 &#125; // 生成订单 // 发布订单创建成功事件 // 构建响应 return response;&#125; 通过以上的改造，我们就完全不需要依赖redis了。性能和安全性两方面都能进一步得到提升！当然，此方案没有考虑到机器的动态扩容、缩容等复杂场景，如果还要考虑这些话，则不如直接考虑分布式锁的解决方案。 总结稀缺商品超卖绝对是重大事故。如果超卖数量多的话，甚至会给平台带来非常严重的经营影响和社会影响。经过本次事故，让我意识到对于项目中的任何一行代码都不能掉以轻心，否则在某些场景下，这些正常工作的代码就会变成致命杀手！对于一个开发者而言，则设计开发方案时，一定要将方案考虑周全。怎样才能将方案考虑周全？唯有持续不断地学习！","tags":["Redis","NoSQL","分布式锁"],"categories":["DataBase","NoSQL"]},{"title":"Java中如何更优雅的处理空值","path":"/2023/12/25/Java中如何更优雅的处理空值/","content":"导语在笔者几年的开发经验中，经常看到项目中存在到处空值判断的情况，这些判断，会让人觉得摸不着头绪，它的出现很有可能和当前的业务逻辑并没有关系。但它会让你很头疼。 有时候，更可怕的是系统因为这些空值的情况，会抛出空指针异常，导致业务系统发生问题。 此篇文章，我总结了几种关于空值的处理手法，希望对读者有帮助。 业务中的空值场景存在一个UserSearchService用来提供用户查询的功能: 12345public interface UserSearchService&#123; List&lt;User&gt; listUser(); User get(Integer id); &#125; 问题现场对于面向对象语言来讲，抽象层级特别的重要。尤其是对接口的抽象，它在设计和开发中占很大的比重，我们在开发时希望尽量面向接口编程。 对于以上描述的接口方法来看，大概可以推断出可能它包含了以下两个含义: listUser(): 查询用户列表 get(Integer id): 查询单个用户 在所有的开发中，XP推崇的TDD模式可以很好的引导我们对接口的定义，所以我们将TDD作为开发代码的”推动者”。 对于以上的接口，当我们使用TDD进行测试用例先行时，发现了潜在的问题： listUser() 如果没有数据，那它是返回空集合还是null呢？ get(Integer id) 如果没有这个对象，是抛异常还是返回null呢？ 深入listUser研究我们先来讨论 1listUser() 这个接口，我经常看到如下实现: 1234567public List&lt;User&gt; listUser()&#123; List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample()); if(CollectionUtils.isEmpty(userList))&#123;//spring util工具类 return null; &#125; return userList; &#125; 这段代码返回是null,从我多年的开发经验来讲，对于集合这样返回值，最好不要返回null，因为如果返回了null，会给调用者带来很多麻烦。你将会把这种调用风险交给调用者来控制。 如果调用者是一个谨慎的人，他会进行是否为null的条件判断。如果他并非谨慎，或者他是一个面向接口编程的狂热分子(当然，面向接口编程是正确的方向)，他会按照自己的理解去调用接口，而不进行是否为null的条件判断，如果这样的话，是非常危险的，它很有可能出现空指针异常！ 根据墨菲定律来判断: “很有可能出现的问题，在将来一定会出现!” 基于此，我们将它进行优化: 1234567public List&lt;User&gt; listUser()&#123; List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample()); if(CollectionUtils.isEmpty(userList))&#123; return Lists.newArrayList();//guava类库提供的方式 &#125; return userList; &#125; 对于接口(List listUser())，它一定会返回List，即使没有数据，它仍然会返回List（集合中没有任何元素）; 通过以上的修改，我们成功的避免了有可能发生的空指针异常，这样的写法更安全！ 深入研究get方法对于接口 1User get(Integer id) 你能看到的现象是，我给出id，它一定会给我返回User.但事实真的很有可能不是这样的。 我看到过的实现: 123public User get(Integer id)&#123; return userRepository.selectByPrimaryKey(id);//从数据库中通过id直接获取实体对象 &#125; 相信很多人也都会这样写。 通过代码的时候得知它的返回值很有可能是null! 但我们通过的接口是分辨不出来的! 这个是个非常危险的事情。尤其对于调用者来说！ 我给出的建议是，需要在接口明明时补充文档,比如对于异常的说明,使用注解@exception: 1234567891011public interface UserSearchService&#123; /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体 * @exception UserNotFoundException */ User get(Integer id); &#125; 我们把接口定义加上了说明之后，调用者会看到，如果调用此接口，很有可能抛出“UserNotFoundException(找不到用户)”这样的异常。 这种方式可以在调用者调用接口的时候看到接口的定义，但是，这种方式是”弱提示”的！ 如果调用者忽略了注释，有可能就对业务系统产生了风险，这个风险有可能导致一个亿！ 除了以上这种”弱提示”的方式，还有一种方式是，返回值是有可能为空的。那要怎么办呢？ 我认为我们需要增加一个接口，用来描述这种场景. 引入jdk8的Optional,或者使用guava的Optional.看如下定义: 123456789public interface UserSearchService&#123; /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体,此实体有可能是缺省值 */ Optional&lt;User&gt; getOptional(Integer id); &#125; Optional有两个含义: 存在 or 缺省。 那么通过阅读接口getOptional()，我们可以很快的了解返回值的意图，这个其实是我们想看到的，它去除了二义性。 它的实现可以写成: 123public Optional&lt;User&gt; getOptional(Integer id)&#123; return Optional.ofNullable(userRepository.selectByPrimaryKey(id)); &#125; 深入入参通过上述的所有接口的描述，你能确定入参id一定是必传的吗？我觉得答案应该是：不能确定。除非接口的文档注释上加以说明。 那如何约束入参呢? 我给大家推荐两种方式： 强制约束 文档性约束（弱提示） 1.强制约束，我们可以通过jsr 303进行严格的约束声明: 12345678910111213141516public interface UserSearchService&#123; /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体 * @exception UserNotFoundException */ User get(@NotNull Integer id); /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体,此实体有可能是缺省值 */ Optional&lt;User&gt; getOptional(@NotNull Integer id); &#125; 当然，这样写，要配合AOP的操作进行验证，但让spring已经提供了很好的集成方案，在此我就不在赘述了。 2.文档性约束 在很多时候，我们会遇到遗留代码，对于遗留代码，整体性改造的可能性很小。 我们更希望通过阅读接口的实现，来进行接口的说明。 jsr 305规范，给了我们一个描述接口入参的一个方式(需要引入库 com.google.code.findbugs:jsr305): 可以使用注解: @Nullable @Nonnull @CheckForNull 进行接口说明。比如: 1234567891011121314151617public interface UserSearchService&#123; /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体 * @exception UserNotFoundException */ @CheckForNull User get(@NonNull Integer id); /** * 根据用户id获取用户信息 * @param id 用户id * @return 用户实体,此实体有可能是缺省值 */ Optional&lt;User&gt; getOptional(@NonNull Integer id); &#125; 小结通过 空集合返回值,Optional,jsr 303，jsr 305这几种方式，可以让我们的代码可读性更强，出错率更低！ 空集合返回值 ：如果有集合这样返回值时，除非真的有说服自己的理由，否则，一定要返回空集合，而不是null Optional: 如果你的代码是jdk8，就引入它！如果不是，则使用Guava的Optional,或者升级jdk版本！它很大程度的能增加了接口的可读性！ jsr 303: 如果新的项目正在开发，不防加上这个试试！一定有一种特别爽的感觉! jsr 305: 如果老的项目在你的手上，你可以尝试的加上这种文档型注解，有助于你后期的重构，或者新功能增加了，对于老接口的理解! 空对象模式场景我们来看一个DTO转化的场景，对象: 1234567891011@Data static class PersonDTO&#123; private String dtoName; private String dtoAge; &#125; @Data static class Person&#123; private String name; private String age; &#125; 需求是将Person对象转化成PersonDTO，然后进行返回。 当然对于实际操作来讲，返回如果Person为空，将返回null,但是PersonDTO是不能返回null的（尤其Rest接口返回的这种DTO）。 在这里，我们只关注转化操作，看如下代码: 1234567891011121314@Test public void shouldConvertDTO()&#123; PersonDTO personDTO = new PersonDTO(); Person person = new Person(); if(!Objects.isNull(person))&#123; personDTO.setDtoAge(person.getAge()); personDTO.setDtoName(person.getName()); &#125;else&#123; personDTO.setDtoAge(&quot;&quot;); personDTO.setDtoName(&quot;&quot;); &#125; &#125; 优化修改这样的数据转化，我们认识可读性非常差，每个字段的判断，如果是空就设置为空字符串(“”) 换一种思维方式进行思考，我们是拿到Person这个类的数据，然后进行赋值操作(setXXX),其实是不关系Person的具体实现是谁的。 那我们可以创建一个Person子类: 1234567891011static class NullPerson extends Person&#123; @Override public String getAge() &#123; return &quot;&quot;; &#125; @Override public String getName() &#123; return &quot;&quot;; &#125; &#125; 它作为Person的一种特例而存在，如果当Person为空的时候，则返回一些get*的默认行为. 所以代码可以修改为: 12345678910111213@Test public void shouldConvertDTO()&#123; PersonDTO personDTO = new PersonDTO(); Person person = getPerson(); personDTO.setDtoAge(person.getAge()); personDTO.setDtoName(person.getName()); &#125; private Person getPerson()&#123; return new NullPerson();//如果Person是null ,则返回空对象 &#125; 其中getPerson()方法，可以用来根据业务逻辑获取Person有可能的对象（对当前例子来讲，如果Person不存在，返回Person的的特例NUllPerson），如果修改成这样，代码的可读性就会变的很强了。 使用Optional可以进行优化空对象模式，它的弊端在于需要创建一个特例对象，但是如果特例的情况比较多，我们是不是需要创建多个特例对象呢，虽然我们也使用了面向对象的多态特性，但是，业务的复杂性如果真的让我们创建多个特例对象，我们还是要再三考虑一下这种模式，它可能会带来代码的复杂性。 对于上述代码，还可以使用Optional进行优化。 1234567891011121314@Test public void shouldConvertDTO()&#123; PersonDTO personDTO = new PersonDTO(); Optional.ofNullable(getPerson()).ifPresent(person -&gt; &#123; personDTO.setDtoAge(person.getAge()); personDTO.setDtoName(person.getName()); &#125;); &#125; private Person getPerson()&#123; return null; &#125; Optional对空值的使用，我觉得更为贴切，它只适用于”是否存在”的场景。 如果只对控制的存在判断，我建议使用Optional. Optioanl的正确使用Optional如此强大，它表达了计算机最原始的特性(0 or 1),那它如何正确的被使用呢! Optional不要作为参数如果你写了一个public方法，这个方法规定了一些输入参数，这些参数中有一些是可以传入null的，那这时候是否可以使用Optional呢？ 我给的建议是: 一定不要这样使用! 举个例子: 123public interface UserService&#123; List&lt;User&gt; listUser(Optional&lt;String&gt; username); &#125; 这个例子的方法 listUser,可能在告诉我们需要根据username查询所有数据集合，如果username是空，也要返回所有的用户集合. 当我们看到这个方法的时候，会觉得有一些歧义: “如果username是absent,是返回空集合吗？还是返回全部的用户数据集合？” Optioanl是一种分支的判断，那我们究竟是关注 Optional还是Optional.get()呢？ 我给大家的建议是，如果不想要这样的歧义，就不要使用它！ 如果你真的想表达两个含义，就給它拆分出两个接口: 1234public interface UserService&#123; List&lt;User&gt; listUser(String username); List&lt;User&gt; listUser(); &#125; 我觉得这样的语义更强，并且更能满足 软件设计原则中的 “单一职责”。 如果你觉得你的入参真的有必要可能传null,那请使用jsr 303或者jsr 305进行说明和验证! 请记住! Optional不能作为入参的参数! Optional作为返回值当个实体的返回那Optioanl可以做为返回值吗？ 其实它是非常满足是否存在这个语义的。 你如说，你要根据id获取用户信息，这个用户有可能存在或者不存在。 你可以这样使用: 123public interface UserService&#123; Optional&lt;User&gt; get(Integer id); &#125; 当调用这个方法的时候，调用者很清楚get方法返回的数据，有可能不存在，这样可以做一些更合理的判断，更好的防止空指针的错误！ 当然，如果业务方真的需要根据id必须查询出User的话，就不要这样使用了，请说明，你要抛出的异常. 只有当考虑它返回null是合理的情况下，才进行Optional的返回 集合实体的返回不是所有的返回值都可以这样用的！如果你返回的是集合： 123public interface UserService&#123; Optional&lt;List&lt;User&gt;&gt; listUser(); &#125; 这样的返回结果，会让调用者不知所措，是否我判断Optional之后，还用进行isEmpty的判断呢？ 这样带来的返回值歧义！我认为是没有必要的。 我们要约定，对于List这种集合返回值，如果集合真的是null的，请返回空集合(Lists.newArrayList); 使用Optional变量1Optional&lt;User&gt; userOpt = ... 如果有这样的变量userOpt,请记住 ： 一定不能直接使用get ，如果这样用，就丧失了Optional本身的含义 （ 比如userOp.get() ） 不要直接使用getOrThrow ,如果你有这样的需求：获取不到就抛异常。那就要考虑，是否是调用的接口设计的是否合理 getter中的使用对于一个java bean,所有的属性都有可能返回null,那是否需要改写所有的getter成为Optional类型呢？ 我给大家的建议是，不要这样滥用Optional. 即便 我java bean中的getter是符合Optional的，但是因为java bean 太多了，这样会导致你的代码有50%以上进行Optinal的判断，这样便污染了代码。(我想说，其实你的实体中的字段应该都是由业务含义的，会认真的思考过它存在的价值的，不能因为Optional的存在而滥用) 我们应该更关注于业务，而不只是空值的判断。 请不要在getter中滥用Optional. 小结可以这样总结Optional的使用： 当使用值为空的情况，并非源于错误时，可以使用Optional! Optional不要用于集合操作! 不要滥用Optional,比如在java bean的getter中!","tags":["Java"],"categories":["Java"]},{"title":"Java 性能优化：35 个小细节，提升你的 Java 代码运行效率","path":"/2023/12/25/Java-性能优化：35-个小细节，提升你的-Java-代码运行效率/","content":"前言代码优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。 代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是 1.减小代码的体积 2.提高代码运行的效率 代码优化细节1、尽量指定类、方法的final修饰符 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。 此举能够使性能平均提高50% 。 2、尽量重用对象 特别是String对象的使用，出现字符串连接时应该使用StringBuilder&#x2F;StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流 Java编程过程中，进行数据库连接、I&#x2F;O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 5、尽量减少对变量的重复计算 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： 123for (int i = 0; i &lt; list.size(); i++) &#123; // todo ...&#125; 建议替换为： 123for (int i = 0, int length = list.size(); i &lt; length; i++) &#123; // todo ...&#125; 这样，在list.size()很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建 例如： 1234String str = &quot;aaa&quot;;if (i == 1) &#123;\tlist.add(str);&#125; 建议替换为： 1234if (i == 1) &#123;\tString str = &quot;aaa&quot;;\tlist.add(str);&#125; 7、慎用异常 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层 除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder() &#x2F;&#x2F; 默认分配16个字符的空间 （2）StringBuilder(int size) &#x2F;&#x2F; 默认分配size个字符的空间 （3）StringBuilder(String str) &#x2F;&#x2F; 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间； （2）把原来的4096个字符拷贝到新的的字符数组中去。 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy()命令 11、乘法和除法使用移位操作 例如： 1234for (val = 0; val &lt; 100000; val += 5) &#123;\ta = val * 8;\tb = val / 2;&#125; 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： 1234for (val = 0; val &lt; 100000; val += 5) &#123;\ta = val &lt;&lt; 3;\tb = val &gt;&gt; 1;&#125; 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用 例如： 123for (int i = 1; i &lt;= count; i++) &#123;\tObject obj = new Object();&#125; 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： 1234Object obj = null;for (int i = 0; i &lt;= count; i++) &#123; obj = new Object(); &#125; 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList 14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销 15、不要将数组声明为public static final 因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变。 16、尽量在合适的场合使用单例 使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： （1）控制资源的使用，通过线程同步来控制资源的并发访问 （2）控制实例的产生，以达到节约资源的目的 （3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量 要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： 123public class A &#123;\tprivate static B b = new B();&#125; 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 18、及时清除不再需要的会话 为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历 这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断 12345678910if (list instanceof RandomAccess) &#123; for (int i = 0; i &lt; list.size(); i++) &#123; &#125;&#125; else &#123; Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext()) &#123; iterator.next() &#125;&#125; foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法 这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名 这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 22、不要创建一些不使用的对象，不要导入一些不使用的类 这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射 关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池 这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 25、使用带缓冲的输入输出流进行IO操作 带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了 27、不要让public方法中有太多的形参 public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合 2、参数太多势必导致方法调用的出错概率增加 至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参。 28、字符串变量和字符串常量equals的时候将字符串常量写在前面 这是一个比较常见的小技巧了，如果有以下代码： 12345678String str = &quot;123&quot;;if (str.equals(&quot;123&quot;)) &#123; // todo...&#125;// 建议修改为：String str = &quot;123&quot;;if (&quot;123&quot;.equals(str)) &#123; // todo ...&#125; 这么做主要是可以避免空指针异常 29、请知道，在java中if (i &#x3D;&#x3D; 1)和if (1 &#x3D;&#x3D; i)是没有区别的，但从阅读习惯上讲，建议使用前者 平时有人问，”if (i &#x3D;&#x3D; 1)”和”if (1&#x3D;&#x3D; i)”有没有区别，这就要从C&#x2F;C++讲起。 在C&#x2F;C++中，”if (i &#x3D;&#x3D; 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： 123456int i = 2;if (i == 1) &#123; // todo ...&#125; else &#123;\t// todo ...&#125; C&#x2F;C++判断”i&#x3D;&#x3D;1″不成立，所以以0表示，即false。但是如果： 123456int i = 2;if (i = 1) &#123; // todo ... &#125; else &#123; // todo ... &#125; 万一程序员一个不小心，把”if (i &#x3D;&#x3D; 1)”写成”if (i &#x3D; 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C&#x2F;C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为： 123456int i = 2;if (1 == i) &#123; // todo ... &#125; else &#123; // todo ... &#125; 这样，即使开发者不小心写成了”1 &#x3D; i”，C&#x2F;C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C&#x2F;C++这种”if (i &#x3D; 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i &#x3D;&#x3D; 1)”和”if (1 &#x3D;&#x3D; i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString()方法 看一下对数组使用toString()打印出来的是什么： 1234public static void main(String[] args) &#123; int[] is = new int[]&#123;1, 2, 3&#125;;\tSystem.out.println(is.toString());&#125; 结果是： 1[I@18a992f 本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。 31、不要对超出范围的基本数据类型做向下强制转型 这绝不会得到想要的结果： 12345public static void main(String[] args) &#123; long l = 12345678901234L; int i = (int)l; System.out.println(i);&#125; 我们可能期望得到其中的某几位，但是结果却是： 11942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是： 10000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010 一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是： 10111 0011 1100 1110 0010 1111 1111 0010 这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论 1、整型默认的数据类型是int，long l &#x3D; 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成””float f &#x3D; 3.5f” 2、接下来再写一句”int ii &#x3D; l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉 如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢 把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试： 12345678910111213141516171819202122public static void main(String[] args) &#123; int loopTime = 50000;\tInteger i = 0;\tlong startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = String.valueOf(i); &#125;\tSystem.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123;\tString str = i.toString();\t&#125;\tSystem.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i + &quot;&quot;;\t&#125;\tSystem.out.println(&quot;i + \\&quot;\\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);&#125; 运行结果为： 123String.valueOf()：11ms Integer.toString()：5ms i + &quot;&quot;：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单： 1、String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断 2、Integer.toString()方法就不说了，直接调用了 3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串 三者对比下来，明显是2最快、1次之、3最慢 34、使用最有效率的方式去遍历Map 遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： 1234567891011public static void main(String[] args) &#123;\tHashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put(&quot;111&quot;, &quot;222&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + &quot;\\t&quot; + entry.getValue());\t&#125;&#125; 如果你只是想遍历一下这个Map的key值，那用”Set keySet &#x3D; hm.keySet();”会比较合适一些 35、对资源的close()建议分开操作 意思是，比如我有这么一段代码： 123456try&#123;\tXXX.close();\tYYY.close();&#125; catch (Exception e) &#123; // todo ...&#125; 建议修改为： 1234567891011try &#123; XXX.close(); &#125; catch (Exception e) &#123; // todo ... &#125;try &#123; YYY.close(); &#125; catch (Exception e) &#123; // todo ... &#125; 虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。","tags":["Java","性能优化"],"categories":["Java"]},{"title":"使用基于 SpringMVC 的透明 RPC 开发微服务","path":"/2023/12/25/使用基于-SpringMVC-的透明-RPC-开发微服务/","content":"来源：fredal.xin&#x2F;develop-with-transparent-rpc 我司目前 RPC 框架是基于 Java Rest 的方式开发的，形式上可以参考 SpringCloud Feign 的实现。Rest 风格随着微服务的架构兴起，Spring MVC 几乎成为了 Rest 开发的规范，同时对于 Spring 的使用者门槛也比较低。 REST 与 RPC 风格的开发方式RPC 框架采用类 Feign 方式的一个简单的实现例子如下： 12345@RpcClient(schemaId=&quot;hello&quot;)public interface Hello &#123; @GetMapping(&quot;/message&quot;) HelloMessage hello(@RequestParam String name);&#125; 而服务提供者直接使用 spring mvc 来暴露服务接口： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private HelloService helloService; @GetMapping(&quot;/message&quot;) public HelloMessage getMessage(@RequestParam(name=&quot;name&quot;)String name) &#123; HelloMessage hello = helloService.gen(name); return hello; &#125;&#125; 基于 REST 风格开发的方式有很多优点。一是使用门槛较低，服务端完全基于 Spring MVC，客户端 api 的书写方式也兼容了大部分 Spring 的注解，包括@RequestParam、@RequestBody 等。二是带来的解耦特性，微服务应用注重服务自治，对外则提供松耦合的 REST 接口，这种方式更灵活，可以减轻历史包袱带来的痛点，同时除了提供给类 SDK 的消费者服务外，还可提供浏览器等非 SDK 的消费者服务。 当然这种方式在实际运用中也带来了很多麻烦。首先，不一致的客户端与服务端 API 带来了出错的可能性，Controller 接口的返回值类型与 RpcClient 的返回值类型可能写的不一致从而导致反序列化失败。其次，RpcClient 的书写虽然兼容了 Spring 的注解，但对于某些开发同学仍然存在不小的门槛，例如写 url param 时@RequestParam 注解常常忘写，写 body param 时候@RequestBody 注解忘记写，用@RequestBody 注解来标注 String 参数，方法类型不指定等等（基本上和使用 Feign 的门槛一样）。 还有一点，就是比起常见的 RPC 方式，REST 方式相当于多写了一层 Controller，而不是直接将 Service 暴露成接口。DDD 实践中，将一个巨石应用拆分成各个限界上下文时，往往是对旧代码的 Service 方法进行拆分，REST 风格意味着需要多写 Controller 接入表示层，而在内部微服务应用间相互调用的场景下，暴露应用服务层甚至领域服务层给调用者可能是更简便的方法，在满足 DDD 的同时更符合 RPC 的语义。 那么我们希望能通过一种基于透明 RPC 风格的开发方式来优雅简便地开发微服务。 首先我们希望服务接口的定义能更简便，不用写多余的注解和信息： 1234@RpcClient(schemaId=&quot;hello&quot;)public interface Hello &#123; HelloMessage hello(String name);&#125; 然后我们就可以实现这个服务，并通过使用注解的方式简单的发布服务： 1234567@RpcService(schemaId=&quot;hello&quot;)public class HelloImpl implements Hello&#123; @Override HelloMessage hello(String name)&#123; return new HelloMessage(name); &#125;&#125; 这样客户端在引用 Hello 接口后可以直接使用里面的 hello()方法调用到服务端的实现类 HelloImpl 中，从而获得一个 HelloMessage 对象。相比之前的 REST 实现方式，在简洁性以及一致性上都得到了提升。 隐式的服务契约服务契约指客户端与服务端之间对于接口的描述定义。REST 风格开发方式中，我们使用 Spring MVC annotation 来声明接口的请求、返回参数。但是在透明 RPC 开发方式中，理论上我们可以不用写任何 RESTful 的 annotation 的，这时候怎么去定义服务契约呢。 其实这里运用了隐式的服务契约，可以不事先定义契约和接口，而是直接定义实现类，根据实现类去自动生成默认的契约，注册到服务中心。 默认的服务契约内容包括方法类型的选择、URL 地址以及参数注解的处理。方法类型的判断基于入参类型，如果入参类型中包含自定义类型、Object 或者集合等适合放在 Body 中的类型，则会判断为使用 POST 方法，而如果入参仅有 String 或者基本类型等，则判断使用 GET 方法。POST 方法会将所有参数作为 Body 进行传送，而 GET 方法则将参数作为 URL PARAM 进行传送。URL 地址的默认规则为/类名/方法类型+方法名，未被注解的方法都会按此 URL 注册到服务中心。 服务端的 REST 编程模型我们可以发现，两种开发风格最大的改变是服务端编程模型的改变，从 REST 风格的 SpringMVC 编程模型变成了透明 RPC 编程模型。我们应该怎样去实现这一步呢？ 我们目前的运行架构如上图，服务端的编程模型完全基于 Spring MVC，通信模型则是基于 servlet 的。我们期望服务端的编程模型可以转换为 RPC，那么势必需要我们对通信模型做一定的改造。 从 DispatcherServlet 说起那么首先，我们需要对 Spring MVC 实现的 servlet 规范 DispatcherServlet 做一定的了解，知道它是怎么处理一个请求的。 DispatcherServlet 主要包含三部分逻辑，映射处理器(HandlerMapping)，映射适配器(HandlerAdapter)，视图处理器(ViewResolver)。DispatcherServlet 通过 HandlerMapping 找到合适的 Handler，再通过 HandlerAdapter 进行适配，最终返回 ModelAndView 经由 ViewResolver 处理返回给前端。 回到主题上，我们想要改造这部分通信模型从而能够实现 RPC 的编程模型有两种办法，一是直接编写一个新的 Servlet，实现 REST over Servlet 的效果，从而对服务端通信逻辑得到一个完整的控制，这样我们可以为服务端添加自定义的运行模型(服务端限流、调用链处理等)。二是仅仅修改一部分 HandlerMapping 的代码，将请求映射变得可以适配 RPC 的编程模型。 鉴于工作量与现实条件，我们选择后一种方法，继续沿用 DispatcherServlet，但改造部分 HandlerMapping 的代码。 首先我们会通过 Scanner 扫描到标注了@RpcClient 注解的接口以及其实现类，我们会将其注册到 HandlerMapping 中，所以首先我们要看 HandlerMapping 中有没有能扩展注册逻辑的地方。 接着我们再考虑处理请求的事儿，我们需要 HandlerMapping 能够做到在没有 Spring Annotation 的情况下也能为不同的参数选择不同的 argumentResolver 参数处理器，这一点在 springMVC 中是通过标注注解来区分的(RequestMapping、RequestBody 等)，所以我们还需要看看 HandlerMapping 中有没有能扩展参数注解逻辑的地方。 带着这两点目的，我们先来看 HandlerMapping 的逻辑。 HandlerMapping 的初始化HandlerMapping 的初始化源码比较长，我们直接一笔略过不是很重要的部分了。首先 RequestMappingHandlerMapping 的父类 AbstractHandlerMethodMapping 类实现了 InitializingBean 接口，在属性初始化完成后会调用 afterPropertiesSet()方法，在该方法中调用 initHandlerMethods()进行 HandlerMethod 初始化。InitHandlerMethods 方法中使用 detectHandlerMethods 方法从 bean 中根据 bean name 查找 handlerMethod，此方法中调用 registerHandlerMethod 来注册正常的 handlerMethod。 123protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123; this.mappingRegistry.register(mapping, handler, method); &#125; 我们发现这个方法是 protected 的，那么第一步我们找到了去哪注册我们的 RPC 方法到 RequestMappingHandlerMapping 中。接口可以看到入参是 handler 方法，但在 handlerMapping 中真正被注册的 handlerMethod 对象，显然这部分逻辑在 mappingRegistry 的 register 方法中。register 方法中我们找到了转换的关键方法： 1HandlerMethod handlerMethod = createHandlerMethod(handler, method); 此方法中调用了 handlerMethod 对象的构造器来构造一个 handlerMethod对象。handlerMethod 的属性中包含一个叫 parameters 的 methodParameter 对象数组。我们知道 handlerMethod 对象对应的是一个实现方法，那么 methodParameter 对象对应的就是入参了。 接着往 methodParameter 对象里看，发现了一个叫 parameterAnnotations 的 Annotation 数组，看样子这就是我们第二个需要关注的地方了。那么总结一下，滤去无需关注的部分，handlerMapping 的初始化整个如下图所示： HandlerAdapter 的请求处理这边 dispatcherServlet 在真正处理请求的时候是用 handlerAdapter 去处理再返回 ModelAndView 对象的，但是所有相关对象都是注册在 handlerMapping 中。 我们直接来看看 RequestMappingHandlerAdapter 的处理逻辑吧，handlerAdapter 在 handle 方法中调用 handleInternal 方法，并调用 invokeHandlerMethod 方法，此方法中使用 createInvocableHandlerMethod 方法将 handlerMethod 对象包装成了一个 servletInvocableHandlerMethod 对象，此对象最终调用 invokeAndHandle 方法完成对应请求逻辑的处理。我们只关注 invokeAndHandle 里面的 invokeForRequest 方法，该方法作为对入参的处理正是我们的目标。最终我们看到了此方法中的 getMethodArgumentValues 方法中的一段对入参注解的处理逻辑: 12345678910if (this.argumentResolvers.supportsParameter(parameter)) &#123; try &#123; args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); &#125; catch (Exception var9) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(this.getArgumentResolutionErrorMessage(&quot;Error resolving argument&quot;, i), var9); &#125; throw var9; &#125;&#125; 显然，这里使用 supportsParameter 方法来作为判断依据选择 argumentResolver，里层的逻辑就是一个简单的遍历选择真正支持入参的参数处理器。实际上 RequestMappingHandlerAdapte 在初始化时候就注册了一堆参数处理器： 1234567891011121314151617 private List&lt;HandlerMethodReturnValueHandler&gt; getDefaultReturnValueHandlers() &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;(); // Single-purpose return value types handlers.add(new ModelAndViewMethodReturnValueHandler()); handlers.add(new ModelMethodProcessor()); handlers.add(new ViewMethodReturnValueHandler()); handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters())); handlers.add(new StreamingResponseBodyReturnValueHandler()); handlers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.contentNegotiationManager, this.requestResponseBodyAdvice)); handlers.add(new HttpHeadersReturnValueHandler()); handlers.add(new CallableMethodReturnValueHandler()); handlers.add(new DeferredResultMethodReturnValueHandler()); handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));\t//...&#125; 我们调个眼熟的 RequestResponseBodyMethodProcessor 来看看其 supportsParameter 方法: 1234@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class);&#125; 这里直接调用了 MethodParameter 自身的 public 方法 hasParameterAnnotation 方法来判断是否有相应的注解，比如有 RequestBody 注解那么我们就选用 RequestResponseBodyMethodProcessor 来作为其参数处理器。 还是滤去无用逻辑，整个流程如下： 服务端的 RPC 编程模型以上我们了解了 DispatcherServlet 在 REST 编程模型中是部分逻辑，现在我们依据之前讲的改造部分 HandlerMapping 的代码从而使其适配 RPC 编程模型。 RPC 方法注册首先我们需要将方法注册到 handlerMapping，而这点由上述 RequestHandlerMapping 的初始化流程得知直接调用 registerHandlerMethod 方法即可。结合我们的扫描逻辑，大致代码如下： 1234567891011121314151617181920212223242526272829303132333435public class RpcRequestMappingHandlerMapping extends RequestMappingHandlerMapping&#123;\tpublic void registerRpcToMvc(final String prefix) &#123; final AdvancedApiToMvcScanner scanner = new AdvancedApiToMvcScanner(RpcService.class); scanner.setBasePackage(basePackage); Map&lt;Class&lt;?&gt;, Set&lt;MethodTemplate&gt;&gt; mvcMap; //扫描到注解了@RpcService的接口及method元信息 try &#123; mvcMap = scanner.scan(); &#125; catch (final IOException e) &#123; throw new FatalBeanException(&quot;failed to scan&quot;); &#125; for (final Class&lt;?&gt; clazz : mvcMap.keySet()) &#123; final Set&lt;MethodTemplate&gt; methodTemplates = mvcMap.get(clazz); for (final MethodTemplate methodTemplate : methodTemplates) &#123; if (methodTemplate == null) &#123; continue; &#125; final Method method = methodTemplate.getMethod(); Http.HttpMethod httpMethod; String uriTemplate = null; //隐式契约：方法类型和url地址 httpMethod = MvcFuncUtil.judgeMethodType(method); uriTemplate = MvcFuncUtil.genMvcFuncName(clazz, httpMethod.name(), method); final RequestMappingInfo requestMappingInfo = RequestMappingInfo .paths(this.resolveEmbeddedValuesInPatterns(new String[]&#123;uriTemplate&#125;)) .methods(RequestMethod.valueOf(httpMethod.name())) .build(); //注册到spring mvc this.registerHandlerMethod(handler, method, requestMappingInfo); &#125; &#125; &#125;&#125; 我们自定义了注册方法，只需在容器启动时调用即可。 RPC 请求处理以上所说，光完成注册是不够的，我们需要对入参注解做一些处理，例如我们虽然没有写注解@RequestBody User user，我们仍然希望 handlerAdapter 在处理的时候能够以为我们写了，并用 RequestResponseBodyMethodProcessor 参数解析器来进行处理。 我们直接重写 RequestMappingHandlerMapping 的 createHandlerMethod 方法： 1234567891011@Overrideprotected HandlerMethod createHandlerMethod(Object handler, Method method) &#123; HandlerMethod handlerMethod; if (handler instanceof String) &#123; String beanName = (String) handler; handlerMethod = new HandlerMethod(beanName, this.getApplicationContext().getAutowireCapableBeanFactory(), method); &#125; else &#123; handlerMethod = new HandlerMethod(handler, method); &#125; return new RpcHandlerMethod(handlerMethod);&#125; 我们自定义了自己的 HandlerMethod 对象： 12345678910111213141516public class RpcHandlerMethod extends HandlerMethod &#123; protected RpcHandlerMethod(HandlerMethod handlerMethod) &#123; super(handlerMethod); initMethodParameters(); &#125; private void initMethodParameters() &#123; MethodParameter[] methodParameters = super.getMethodParameters(); Annotation[][] parameterAnnotations = null; for (int i = 0; i &lt; methodParameters.length; i++) &#123; SynthesizingMethodParameter methodParameter = (SynthesizingMethodParameter) methodParameters[i]; methodParameters[i] = new RpcMethodParameter(methodParameter); &#125; &#125;&#125; 很容易看到，这里的重点是初始化了自定义的 MethodParameter 对象： 12345678910111213141516171819202122232425262728public class RpcMethodParameter extends SynthesizingMethodParameter &#123; private volatile Annotation[] annotations; protected RpcMethodParameter(SynthesizingMethodParameter original) &#123; super(original); this.annotations = initParameterAnnotations(); &#125; private Annotation[] initParameterAnnotations() &#123; List&lt;Annotation&gt; annotationList = new ArrayList&lt;&gt;(); final Class&lt;?&gt; parameterType = this.getParameterType(); if (MvcFuncUtil.isRequestParamClass(parameterType)) &#123; annotationList.add(MvcFuncUtil.newRequestParam(MvcFuncUtil.genMvcParamName(this.getParameterIndex()))); &#125; else if (MvcFuncUtil.isRequestBodyClass(parameterType)) &#123; annotationList.add(MvcFuncUtil.newRequestBody()); &#125; return annotationList.toArray(new Annotation[]&#123;&#125;); &#125; @Override public Annotation[] getParameterAnnotations() &#123; if (annotations != null &amp;&amp; annotations.length &gt; 0) &#123; return annotations; &#125; return super.getParameterAnnotations(); &#125;&#125; 自定义的 MethodParameter 对象中重写了 getParameterAnnotations 方法，而次方法正是 argumentResolver 用来判断自己是否适合该参数的方法。我们做了些改造使得合适的参数会被合适的参数解析器”误以为”加了对应的注解，从而自己会去进行正常的参数处理逻辑。整个处理流程如下，粉红色部分也正是我们所扩展的点了： RPC 编程模型经过改造之后，我们已经可以实现文章开头所描述的透明 RPC 来开发微服务了，整个运行架构变成了下面这样：","tags":["框架","Spring","SpringMVC","分布式","微服务"],"categories":["框架","Spring","SpringMVC"]},{"title":"图文讲解哈希表","path":"/2023/12/25/图文讲解哈希表/","content":"今天我们来说一种新的数据结构散列（哈希）表，散列是应用非常广泛的数据结构，在我们的刷题过程中，散列表的出场率特别高。所以我们快来一起把散列表的内些事给整明白吧，文章框架如下。 说散列表之前，我们先设想以下场景。 袁厨穿越回了古代，凭借从现代学习的做饭手艺，开了一个袁记菜馆，正值开业初期，店里生意十分火爆，但是顾客结账时就犯难了，由于菜品太多，每当结账时，老板娘总是按照菜单一个一个找价格（遍历查找），每次都要找半天，所以结账的地方总是排起长队，顾客们表示用户体验很差。袁厨一想这不是办法啊，太浪费大家时间了，所以袁厨就先把菜单按照首字母排序（二分查找），然后查找的时候根据首字母查找，这样结账的时候就能大大提高检索效率啦！但是呢？工作日顾客不多，老板娘完全应付的过来，但是每逢节假日，还是会排起长队。那么有没有什么更好的办法呢？对呀！我们把所有的价格都背下来不就可以了吗？每个菜的价格我们都了如指掌，结账的时候我们只需把每道菜的价格相加即可。所以袁厨和老板娘加班加点的进行背诵。下次再结账的时候一说吃了什么菜，我们立马就知道价格啦。自此以后收银台再也没有出现过长队啦，袁记菜馆开着开着一不小心就成了天下第一饭店。 下面我们来看一下袁记菜馆老板娘进化史。 上面的后期结账的过程则模拟了我们的散列表查找，那么在计算机中是如何使用进行查找的呢？ 散列表查找步骤散列表，最有用的基本数据结构之一。是根据关键码的值直接进行访问的数据结构，散列表的实现常常叫做散列（hasing）。散列是一种用于以常数平均时间执行插入、删除和查找的技术，下面我们来看一下散列过程。 我们的整个散列过程主要分为两步 （1）通过散列函数计算记录的散列地址，并按此散列地址存储该记录。就好比麻辣鱼，我们就让它在川菜区，糖醋鱼，我们就让它在鲁菜区。但是我们需要注意的是，无论什么记录我们都需要用同一个散列函数计算地址，然后再存储。 （2)当我们查找时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。因为我们存和取的时候用的都是一个散列函数，因此结果肯定相同。 刚才我们在散列过程中提到了散列函数，那么散列函数是什么呢？ 我们假设某个函数为 f，使得 存储位置 &#x3D; f (key) 那样我们就能通过查找关键字不需要比较就可获得需要的记录的存储位置。这种存储技术被称为散列技术。散列技术是在通过记录的存储位置和它的关键字之间建立一个确定的对应关系 f ,使得每个关键字 key 都对应一个存储位置 f(key)。见下图 这里的 f 就是我们所说的散列函数（哈希）函数。我们利用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间就是我们本文的主人公——散列(哈希) 上图为我们描述了用散列函数将关键字映射到散列表，但是大家有没有考虑到这种情况，那就是将关键字映射到同一个槽中的情况，即 f(k4) &#x3D; f(k3) 时。这种情况我们将其称之为冲突，k3 和 k4 则被称之为散列函数 f 的同义词，如果产生这种情况，则会让我们查找错误。幸运的是我们能找到有效的方法解决冲突。 首先我们可以对哈希函数下手，我们可以精心设计哈希函数，让其尽可能少的产生冲突，所以我们创建哈希函数时应遵循以下规则 （1）必须是一致的，假设你输入辣子鸡丁时得到的是在看，那么每次输入辣子鸡丁时，得到的也必须为在看。如果不是这样，散列表将毫无用处。 （2）计算简单，假设我们设计了一个算法，可以保证所有关键字都不会冲突，但是这个算法计算复杂，会耗费很多时间，这样的话就大大降低了查找效率，反而得不偿失。所以咱们散列函数的计算时间不应该超过其他查找技术与关键字的比较时间，不然的话我们干嘛不使用其他查找技术呢? （3）散列地址分布均匀我们刚才说了冲突的带来的问题，所以我们最好的办法就是让散列地址尽量均匀分布在存储空间中，这样即保证空间的有效利用，又减少了处理冲突而消耗的时间。 现在我们已经对散列表，散列函数等知识有所了解啦，那么我们来看几种常用的散列函数构造方法。这些方法的共同点为都是将原来的数字按某种规律变成了另一个数字。所以是很容易理解的。 散列函数构造方法直接定址法如果我们对盈利为0-9的菜品设计哈希表，我们则直接可以根据作为地址，则 f(key) &#x3D; key; 即下面这种情况。 有没有感觉上面的图很熟悉，没错我们经常用的数组其实就是一张哈希表，关键码就是数组的索引下标，然后我们通过下标直接访问数组中的元素。 另外我们假设每道菜的成本为50块，那我们还可以根据盈利+成本来作为地址，那么则 f(key) &#x3D; key + 50。也就是说我们可以根据线性函数值作为散列地址。 f(key) &#x3D; a * key + b a,b均为常数 优点：简单、均匀、无冲突。 应用场景：需要事先知道关键字的分布情况，适合查找表较小且连续的情况 数字分析法该方法也是十分简单的方法，就是分析我们的关键字，取其中一段，或对其位移，叠加，用作地址。比如我们的学号，前 6 位都是一样的，但是后面 3 位都不相同，我们则可以用学号作为键，后面的 3 位做为我们的散列地址。如果我们这样还是容易产生冲突，则可以对抽取数字再进行处理。我们的目的只有一个，提供一个散列函数将关键字合理的分配到散列表的各位置。这里我们提到了一种新的方式抽取，这也是在散列函数中经常用到的手段。 优点：简单、均匀、适用于关键字位数较大的情况 应用场景：关键字位数较大，知道关键字分布情况且关键字的若干位较均匀 折叠法其实这个方法也很简单，也是处理我们的关键字然后用作我们的散列地址，主要思路是将关键字从左到右分割成位数相等的几部分，然后叠加求和，并按散列表表长，取后几位作为散列地址。 比如我们的关键字是123456789，则我们分为三部分 123 ，456 ，789 然后将其相加得 1368 然后我们再取其后三位 368 作为我们的散列地址。 优点：事先不需要知道关键字情况 应用场景：适合关键字位数较多的情况 除法散列法在用来设计散列函数的除法散列法中，通过取 key 除以 p 的余数，将关键字映射到 p 个槽中的某一个上，对于散列表长度为 m 的散列函数公式为 f(k) &#x3D; k mod p (p &lt;&#x3D; m) 例如，如果散列表长度为 12，即 m &#x3D; 12 ，我们的参数 p 也设为12，那 k &#x3D; 100时 f(k) &#x3D; 100 % 12 &#x3D; 4 由于只需要做一次除法操作，所以除法散列法是非常快的。 由上面的公式可以看出，该方法的重点在于 p 的取值，如果 p 值选的不好，就可能会容易产生同义词。见下面这种情况。我们哈希表长度为6，我们选择6为p值，则有可能产生这种情况，所有关键字都得到了0这个地址数。 那我们在选用除法散列法时选取 p 值时应该遵循怎样的规则呢？ m 不应为 2 的幂，因为如果 m &#x3D; 2^p ，则 f(k) 就是 k 的 p 个最低位数字。例 12 % 8 &#x3D; 4 ，12的二进制表示位1100，后三位为100。 若散列表长为 m ,通常 p 为 小于或等于表长（最好接近m）的最小质数或不包含小于 20 质因子的合数。 合数：合数是指在大于1的整数中除了能被1和本身整除外，还能被其他数（0除外）整除的数。 质因子：质因子（或质因数）在数论里是指能整除给定正整数的质数。 注：这里的2，3，5为质因子 还是上面的例子，我们根据规则选择 5 为 p 值，我们再来看。这时我们发现只有 6 和 36 冲突，相对来说就好了很多。 优点：计算效率高，灵活 应用场景：不知道关键字分布情况 乘法散列法构造散列函数的乘法散列法主要包含两个步骤 用关键字 k 乘上常数 A(0 &lt; A &lt; 1)，并提取 k A 的小数部分 用 m 乘以这个值，再向下取整 散列函数为 f (k) &#x3D; ⌊ m(kA mod 1) ⌋ 这里的 kA mod 1 的含义是取 keyA 的小数部分，即 kA - ⌊kA⌋ 。 优点：对 m 的选择不是特别关键一般选择它为 2 的某个幂次（m &#x3D; 2 ^ p ,p为某个整数） 应用场景：不知道关键字情况 平方取中法这个方法就比较简单了，假设关键字是 321，那么他的平方就是 103041，再抽取中间的 3 位就是 030 或 304 用作散列地址。再比如关键字是 1234 那么它的平方就是 1522756 ，抽取中间 3 位就是 227 用作散列地址. 优点：灵活，适用范围广泛 适用场景：不知道关键字分布，而位数又不是很大的情况。 随机数法故名思意，取关键字的随机函数值为它的散列地址。也就是 **f(key) &#x3D; random(key)**。这里的random是随机函数。（具体解析见随机探测法） 适用场景：关键字的长度不等时 上面我们的例子都是通过数字进行举例，那么如果是字符串可不可以作为键呢？当然也是可以的，各种各样的符号我们都可以转换成某种数字来对待，比如我们经常接触的ASCII 码，所以是同样适用的。 以上就是常用的散列函数构造方法，其实他们的中心思想是一致的，将关键字经过加工处理之后变成另外一个数字，而这个数字就是我们的存储位置，是不是有一种间谍传递情报的感觉。 一个好的哈希函数可以帮助我们尽可能少的产生冲突，但是也不能完全避免产生冲突，那么遇到冲突时应该怎么做呢？下面给大家带来几种常用的处理散列冲突的方法。 处理散列冲突的方法我们在使用 hash 函数之后发现关键字 key1 不等于 key2 ，但是 f(key1) &#x3D; f(key2)，即有冲突，那么该怎么办呢？不急我们慢慢往下看。 开放地址法了解开放地址法之前我们先设想以下场景。 袁记菜馆内，铃铃铃，铃铃铃 电话铃响了 大鹏：老袁，给我订个包间，我今天要去带几个客户去你那谈生意。 袁厨：大鹏啊，你常用的那个包间被人订走啦。 大鹏：老袁你这不仗义呀，咋没给我留住呀，那你给我找个空房间吧。 袁厨：好滴老哥 哦，穿越回古代就没有电话啦，那看来穿越的时候得带着几个手机了。 上面的场景其实就是一种处理冲突的方法—–开放地址法 开放地址法就是一旦发生冲突，就去寻找下一个空的散列地址，只要列表足够大，空的散列地址总能找到，并将记录存入，为了使用开放寻址法插入一个元素，需要连续地检查散列表，或称为探查，我们常用的有线性探测，二次探测，随机探测。 线性探测法下面我们先来看一下线性探测，公式： 我们来看一个例子，我们的关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，我们再用散列函数 f(key) &#x3D; key mod 12。 我们求出每个 key 的 f(key)见下表 我们查看上表发现，前五位的 f(key) 都不相同，即没有冲突，可以直接存入，但是到了第六位 f(37) &#x3D; f(25) &#x3D; 1,那我们就需要利用上面的公式 f(37) &#x3D; f (f(37) + 1 ) mod 12 &#x3D; 2，这其实就是我们的订包间的做法。下面我们看一下将上面的所有数存入哈希表是什么情况吧。 注：蓝色为计算哈希值，红色为存入哈希表 我们把这种解决冲突的开放地址法称为线性探测法。下面我们通过视频来模拟一下线性探测法的存储过程。 &lt;video id&#x3D;”video” controls&#x3D;””src&#x3D;”http://mpvideo.qpic.cn/0bf23udbgaagw4aa2n5tqrpvnxodcpoqmeya.f10002.mp4?dis_k=7098b34ae4d0d564f208a7d543987175&amp;dis_t=1609338638&amp;spec_id=MzU4MDUyMDQyNQ%3D%3D1609338634&amp;vid=wxv_1612509429344567297&amp;format_id=10002“ preload&#x3D;”none”&gt; 另外我们在解决冲突的时候，会遇到 48 和 37 虽然不是同义词，却争夺一个地址的情况，我们称其为堆积。因为堆积使得我们需要不断的处理冲突，插入和查找效率都会大大降低。 通过上面的视频我们应该了解了线性探测的执行过程了，那么我们考虑一下这种情况，若是我们的最后一位不为21，为 34 时会有什么事情发生呢？ 此时他第一次会落在下标为 10 的位置，那么如果继续使用线性探测的话，则需要通过不断取余后得到结果，数据量小还好，要是很大的话那也太慢了吧，但是明明他的前面就有一个空房间呀，如果向前移动只需移动一次即可。不要着急，前辈们已经帮我们想好了解决方法 二次探测法其实理解了我们的上个例子之后，这个一下就能整明白了，根本不用费脑子，这个方法就是更改了一下di的取值 注：这里的是 -1^2 为负值 而不是 （-1)^2 所以对于我们的34来说，当di &#x3D; -1时，就可以找到空位置了。 二次探测法的目的就是为了不让关键字聚集在某一块区域。另外还有一种有趣的方法，位移量采用随机函数计算得到，接着往下看吧. 随机探测法大家看到这是不又有新问题了，刚才我们在散列函数构造规则的第一条中说 （1）必须是一致的，假设你输入辣子鸡丁时得到的是在看，那么每次输入辣子鸡丁时，得到的也必须为在看。如果不是这样，散列表将毫无用处。 咦？怎么又是在看哈哈，那么问题来了，我们使用随机数作为他的偏移量，那么我们查找的时候岂不是查不到了？因为我们 di 是随机生成的呀，这里的随机其实是伪随机数，伪随机数含义为，我们设置随机种子相同，则不断调用随机函数可以生成不会重复的数列，我们在查找时，用同样的随机种子，它每次得到的数列是相同的，那么相同的 di 就能得到相同的散列地址。 随机种子（Random Seed）是计算机专业术语，一种以随机数作为对象的以真随机数（种子）为初始条件的随机数。一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数 通过上面的测试是不是一下就秒懂啦，使用相同的随机种子，生成的数列是相同的。所以为什么我们可以使用随机数作为它的偏移量。 下面我们再来看一下其他的函数处理散列冲突的方法 再哈希法这个方法其实也特别简单，利用不同的哈希函数再求得一个哈希地址，直到不出现冲突为止。 f,(key) &#x3D; RH,( key ) (i &#x3D; 1,2,3,4…..k) 这里的RH,就是不同的散列函数，你可以把我们之前说过的那些散列函数都用上，每当发生冲突时就换一个散列函数，相信总有一个能够解决冲突的。这种方法能使关键字不产生聚集，但是代价就是增加了计算时间。是不是很简单啊。 链地址法下面我们再设想以下情景。 袁记菜馆内，铃铃铃，铃铃铃电话铃又响了，那个大鹏又来订房间了。 大鹏：老袁啊，我一会去你那吃个饭，还是上回那个包间 袁厨：大鹏你下回能不能早点说啊，又没人订走了，这回是老王订的 大鹏：老王这个老东西啊，反正也是熟人，你再给我整个桌子，我拼在他后面吧 不好意思啊各位同学，信鸽最近太贵了还没来得及买。上面的情景就是模拟我们的新的处理冲突的方法链地址法。 上面我们都是遇到冲突之后，就换地方。那么我们有没有不换地方的办法呢？那就是我们现在说的链地址法。 还记得我们说过的同义词吗？就是 key 不同 f(key) 相同的情况，我们将这些同义词存储在一个单链表中，这种表叫做同义词子表，散列表中只存储同义词子表的头指针。我们还是用刚才的例子，关键字集合为{12，67，56，16，25，37，22，29，15，47，48，21}，表长为12，我们再用散列函数 f(key) &#x3D; key mod 12。我们用了链地址法之后就再也不存在冲突了，无论有多少冲突，我们只需在同义词子表中添加结点即可。下面我们看下链地址法的存储情况。 链地址法虽然能够不产生冲突，但是也带来了查找时需要遍历单链表的性能消耗，有得必有失嘛。 公共溢出区法下面我们再来看一种新的方法，这回大鹏又要来吃饭了。 袁记菜馆内….. 袁厨：呦，这是什么风把你给刮来了，咋没开你的大奔啊。 大鹏：哎呀妈呀，别那么多废话了，我快饿死了，你快给我找个位置，我要吃点饭。 袁厨：你来的，太不巧了，咱们的店已经满了，你先去旁边的小屋看会电视，等有空了我再叫你。小屋里面还有几个和你一样来晚的，你们一起看吧。 大鹏：电视？看电视？ 上面的情景就是模拟我们的公共溢出区法，这也是很好理解的，你不是冲突吗？那冲突的各位我先给你安排个地方呆着，这样你就有地方住了。我们为所有冲突的关键字建立了一个公共的溢出区来存放。 那么我们怎么进行查找呢？我们首先通过散列函数计算出散列地址后，先于基本表对比，如果不相等再到溢出表去顺序查找。这种解决冲突的方法，对于冲突很少的情况性能还是非常高的。 散列表查找算法(线性探测法)下面我们来看一下散列表查找算法的实现 首先需要定义散列列表的结构以及一些相关常数，其中elem代表散列表数据存储数组，count代表的是当前插入元素个数，size代表哈希表容量，NULLKEY散列表初始值，然后我们如果查找成功就返回索引，如果不存在该元素就返回元素不存在。 我们将哈希表初始化，为数组元素赋初值。 插入操作的具体步骤： （1）通过哈希函数(除法散列法)，将key转化为数组下标 （2）如果该下标中没有元素，则插入，否则说明有冲突，则利用线性探测法处理冲突。详细步骤见注释 查找操作的具体步骤： （1）通过哈希函数（同插入时一样），将key转化成数组下标 （2）通过数组下标找到key值，如果key一致，则查找成功，否则利用线性探测法继续查找。 下面我们来看一下完整代码 散列表性能分析如果没有冲突的话，散列查找是我们查找中效率最高的，时间复杂度为O(1),但是没有冲突的情况是一种理想情况，那么散列查找的平均查找长度取决于哪些方面呢？ 1.散列函数是否均匀我们在上文说到，可以通过设计散列函数减少冲突，但是由于不同的散列函数对一组关键字产生冲突可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。 2.处理冲突的方法相同关键字，相同散列函数，不同处理冲突方式，会使平均查找长度不同，比如我们线性探测有时会堆积，则不如二次探测法好，因为链地址法处理冲突时不会产生任何堆积，因而具有最佳的平均查找性能 3.散列表的装填因子本来想在上文中提到装填因子的，但是后来发现即使没有说明也不影响我们对哈希表的理解，下面我们来看一下装填因子的总结 装填因子 α &#x3D; 填入表中的记录数 &#x2F; 散列表长度 散列因子则代表着散列表的装满程度，表中记录越多，α就越大，产生冲突的概率就越大。我们上面提到的例子中 表的长度为12，填入记录数为6，那么此时的 α &#x3D; 6 &#x2F; 12 &#x3D; 0.5 所以说当我们的 α 比较大时再填入元素那么产生冲突的可能性就非常大了。所以说散列表的平均查找长度取决于装填因子，而不是取决于记录数。所以说我们需要做的就是选择一个合适的装填因子以便将平均查找长度限定在一个范围之内。","tags":["算法","数据结构","哈希表"],"categories":["算法","数据结构"]},{"title":"SQL优化最干货总结","path":"/2023/12/25/SQL优化最干货总结/","content":"前言BATJTMD等大厂的面试难度越来越高，但无论从大厂还是到小公司，一直未变的一个重点就是对SQL优化经验的考察。一提到数据库，先“说一说你对SQL优化的见解吧？”。 SQL优化已经成为衡量程序猿优秀与否的硬性指标，甚至在各大厂招聘岗位职能上都有明码标注，如果是你，在这个问题上能吊打面试官还是会被吊打呢？ 目录 前言 SELECT语句 - 语法顺序： SELECT语句 - 执行顺序： SQL优化策略 一、避免不走索引的场景 二、SELECT语句其他优化 三、增删改 DML 语句优化 四、查询条件优化 五、建表优化 有朋友疑问到，SQL优化真的有这么重要么？如下图所示，SQL优化在提升系统性能中是：（成本最低 &amp;&amp; 优化效果最明显） 的途径。如果你的团队在SQL优化这方面搞得很优秀，对你们整个大型系统可用性方面无疑是一个质的跨越，真的能让你们老板省下不止几沓子钱。 优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引。 优化效果：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引。 123456789101112131415String result = &quot;嗯，不错，&quot;; if (&quot;SQL优化经验足&quot;) &#123; if (&quot;熟悉事务锁&quot;) &#123; if (&quot;并发场景处理666&quot;) &#123; if (&quot;会打王者荣耀&quot;) &#123; result += &quot;明天入职&quot; &#125; &#125; &#125;&#125; else &#123; result += &quot;先回去等消息吧&quot;;&#125; Logger.info(&quot;面试官：&quot; + result ); 别看了，上面这是一道送命题。 好了我们言归正传，首先，对于MySQL层优化我一般遵从五个原则： 减少数据访问：设置合理的字段类型，启用压缩，通过索引访问等减少磁盘IO 返回更少的数据：只返回需要的字段和数据分页处理 减少磁盘io及网络io 减少交互次数：批量DML操作，函数存储等减少数据连接次数 减少服务器CPU开销：尽量减少数据库排序操作以及全表查询，减少cpu 内存占用 利用更多资源：使用表分区，可以增加并行操作，更大限度利用cpu资源 总结到SQL优化中，就三点: 最大化利用索引； 尽可能避免全表扫描； 减少无效数据的查询； 理解SQL优化原理 ，首先要搞清楚SQL执行顺序： SELECT语句 - 语法顺序：123456789101. SELECT 2. DISTINCT &lt;select_list&gt;3. FROM &lt;left_table&gt;4. &lt;join_type&gt; JOIN &lt;right_table&gt;5. ON &lt;join_condition&gt;6. WHERE &lt;where_condition&gt;7. GROUP BY &lt;group_by_list&gt;8. HAVING &lt;having_condition&gt;9. ORDER BY &lt;order_by_condition&gt;10.LIMIT &lt;limit_number&gt; SELECT语句 - 执行顺序： FROM&lt;表名&gt; # 选取表，将多个表数据通过笛卡尔积变成一个表。ON&lt;筛选条件&gt; # 对笛卡尔积的虚表进行筛选JOIN &lt;join, left join, right join…&gt;&lt;join表&gt; # 指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中WHERE&lt;where条件&gt; # 对上述虚表进行筛选GROUP BY&lt;分组条件&gt; # 分组&lt;SUM()等聚合函数&gt; # 用于having子句进行判断，在书写上这类聚合函数是写在having判断里面的HAVING&lt;分组筛选&gt; # 对分组后的结果进行聚合筛选SELECT&lt;返回数据列表&gt; # 返回的单列必须在group by子句中，聚合函数除外DISTINCT# 数据除重ORDER BY&lt;排序条件&gt; # 排序LIMIT&lt;行数限制&gt; SQL优化策略 声明：以下SQL优化策略适用于数据量较大的场景下，如果数据量较小，没必要以此为准，以免画蛇添足。 一、避免不走索引的场景1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如下： 1SELECT * FROM t WHERE username LIKE &#x27;%陈%&#x27; 优化方式：尽量在字段后面使用模糊查询。如下： 1SELECT * FROM t WHERE username LIKE &#x27;陈%&#x27; 如果需求是要在前面使用模糊查询， 使用MySQL内置函数INSTR(str,substr) 来匹配，作用类似于java中的indexOf()，查询字符串出现的角标位置 使用FullText全文索引，用match against 检索 数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级 当表数据量较少（几千条儿那种），别整花里胡哨的，直接用like ‘%xx%’。 2. 尽量避免使用in 和not in，会导致引擎走全表扫描。如下： 1SELECT * FROM t WHERE id IN (2,3) 优化方式：如果是连续数值，可以用between代替。如下： 1SELECT * FROM t WHERE id BETWEEN 2 AND 3 如果是子查询，可以用exists代替。如下： 1234-- 不走索引select * from A where A.id in (select id from B);-- 走索引select * from A where exists (select * from B where B.id = A.id); 3. 尽量避免使用 or，会导致数据库引擎放弃索引进行全表扫描。如下： 1SELECT * FROM t WHERE id = 1 OR id = 3 优化方式：可以用union代替or。如下： 123SELECT * FROM t WHERE id = 1 UNIONSELECT * FROM t WHERE id = 3 4. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下： 1SELECT * FROM t WHERE score IS NULL 优化方式：可以给字段添加默认值0，对0值进行判断。如下： 1SELECT * FROM t WHERE score = 0 5.尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。可以将表达式、函数操作移动到等号右侧。如下： 1234-- 全表扫描SELECT * FROM T WHERE score/10 = 9-- 走索引SELECT * FROM T WHERE score = 10*9 6. 当数据量大时，避免使用where 1&#x3D;1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下： 1SELECT username, age, sex FROM T WHERE 1=1 优化方式：用代码拼装sql时进行判断，没 where 条件就去掉 where，有where条件就加 and。 7. 查询条件不能用 &lt;&gt; 或者 !&#x3D;使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!&#x3D;等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。 8. where条件仅包含复合索引非前置列如下：复合（联合）索引包含key_part1，key_part2，key_part3三列，但SQL语句没有包含索引前置列”key_part1”，按照MySQL联合索引的最左匹配原则，不会走联合索引。 1select col1 from table where key_part2=1 and key_part3=2 9. 隐式类型转换造成不使用索引如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。 1select col1 from table where col_varchar=123; 10. order by 条件要与where中条件一致，否则order by不会利用索引进行排序12345-- 不走age索引SELECT * FROM t order by age; -- 走age索引SELECT * FROM t where age &gt; 0 order by age; 对于上面的语句，数据库的处理顺序是： 第一步：根据where条件和统计信息生成执行计划，得到数据。 第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。 第三步：返回排序后的数据。 当order by 中的字段出现在where条件中时，才会利用索引而不再二次排序，更准确的说，order by 中的字段在执行计划中利用了索引时，不用排序操作。 这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。 11. 正确使用hint优化语句MySQL中可以使用hint指定优化器在执行时选择或忽略特定的索引。一般而言，处于版本变更带来的表结构索引变化，更建议避免使用hint，而是通过Analyze table多收集统计信息。但在特定场合下，指定hint可以排除其他索引干扰而指定更优的执行计划。 USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供希望 MySQL 去参考的索引列表，就可以让 MySQL 不再考虑其他可用的索引。例子: SELECT col1 FROM table USE INDEX (mod_time, name)… IGNORE INDEX 如果只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。例子: SELECT col1 FROM table IGNORE INDEX (priority) … FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用FORCE INDEX 作为Hint。例子: SELECT col1 FROM table FORCE INDEX (mod_time) … 在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用FORCE INDEX强制查询使用指定的索引。 例如： 1SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC; 二、SELECT语句其他优化**1. 避免出现select **首先，select * 操作在任何类型数据库中都不是一个好的SQL编写习惯。 使用select * 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I&#x2F;O,内存和CPU消耗。 建议提出业务实际需要的列数，将指定列名以取代select *。 2. 避免出现不确定结果的函数特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now()、rand()、sysdate()、current_user()等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。 3.多表关联查询时，小表在前，大表在后。在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。 例如：表1有50条数据，表2有30亿条数据；如果全表扫描表2，你品，那就先去吃个饭再说吧是吧。 4. 使用表的别名当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。 5. 用where字句替换HAVING字句避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。 where和having的区别：where后面不能使用组函数 6.调整Where字句中的连接顺序MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。 三、增删改 DML 语句优化1. 大批量插入数据如果同时执行大量的插入，建议使用多个值的INSERT语句(方法二)。这比使用分开INSERT语句快（方法一），一般情况下批量插入效率有几倍的差别。 方法一： 12345insert into T values(1,2); insert into T values(1,3); insert into T values(1,4); 方法二： 1Insert into T values(1,2),(1,3),(1,4); 选择后一种方法的原因有三。 减少SQL语句解析的操作，MySQL没有类似Oracle的share pool，采用方法二，只需要解析一次就能进行数据的插入操作； 在特定场景可以减少对DB连接次数 SQL语句较短，可以减少网络传输的IO。 2. 适当使用commit适当使用commit可以释放事务占用的资源而减少消耗，commit后能释放的资源如下： 事务占用的undo数据块； 事务在redo log中记录的数据块； 释放事务施加的，减少锁争用影响性能。特别是在需要使用delete删除大量数据的时候，必须分解删除量并定期commit。 3. 避免重复查询更新的数据针对业务中经常出现的更新行同时又希望获得改行信息的需求，MySQL并不支持PostgreSQL那样的UPDATE RETURNING语法，在MySQL中可以通过变量实现。 例如，更新一行记录的时间戳，同时希望查询当前记录中存放的时间戳是什么，简单方法实现： 123Update t1 set time=now() where col1=1; Select time from t1 where id =1; 使用变量，可以重写为以下方式： 123Update t1 set time=now () where col1=1 and @now: = now (); Select @now; 前后二者都需要两次网络来回，但使用变量避免了再次访问数据表，特别是当t1表数据量较大时，后者比前者快很多。 4.查询优先还是更新（insert、update、delete）优先MySQL 还允许改变语句调度的优先级，它可以使来自多个客户端的查询更好地协作，这样单个客户端就不会由于锁定而等待很长时间。改变优先级还可以确保特定类型的查询被处理得更快。我们首先应该确定应用的类型，判断应用是以查询为主还是以更新为主的，是确保查询效率还是确保更新的效率，决定是查询优先还是更新优先。 下面我们提到的改变调度策略的方法主要是针对只存在表锁的存储引擎，比如 MyISAM 、MEMROY、MERGE，对于Innodb 存储引擎，语句的执行是由获得行锁的顺序决定的。MySQL 的默认的调度策略可用总结如下： 1）写入操作优先于读取操作。 2）对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。 3）对某张数据表的多个读取操作可以同时地进行。MySQL 提供了几个语句调节符，允许你修改它的调度策略： LOW_PRIORITY关键字应用于DELETE、INSERT、LOAD DATA、REPLACE和UPDATE； HIGH_PRIORITY关键字应用于SELECT和INSERT语句； DELAYED关键字应用于INSERT和REPLACE语句。 如果写入操作是一个 LOW_PRIORITY（低优先级）请求，那么系统就不会认为它的优先级高于读取操作。在这种情况下，如果写入者在等待的时候，第二个读取者到达了，那么就允许第二个读取者插到写入者之前。只有在没有其它的读取者的时候，才允许写入者开始操作。这种调度修改可能存在 LOW_PRIORITY写入操作永远被阻塞的情况。 SELECT 查询的HIGH_PRIORITY（高优先级）关键字也类似。它允许SELECT 插入正在等待的写入操作之前，即使在正常情况下写入操作的优先级更高。另外一种影响是，高优先级的 SELECT 在正常的 SELECT 语句之前执行，因为这些语句会被写入操作阻塞。如果希望所有支持LOW_PRIORITY 选项的语句都默认地按照低优先级来处理，那么 请使用–low-priority-updates 选项来启动服务器。通过使用 INSERTHIGH_PRIORITY 来把 INSERT 语句提高到正常的写入优先级，可以消除该选项对单个INSERT语句的影响。 四、查询条件优化1. 对于复杂的查询，可以使用中间临时表 暂存数据2. 优化group by语句默认情况下，MySQL 会对GROUP BY分组的所有值进行排序，如 “GROUP BY col1，col2，….;” 查询的方法如同在查询中指定 “ORDER BY col1，col2，…;” 如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。 因此，如果查询包括 GROUP BY 但你并不想对分组的值进行排序，你可以指定 ORDER BY NULL禁止排序。例如： 1SELECT col1, col2, COUNT(*) FROM table GROUP BY col1, col2 ORDER BY NULL ; 3. 优化join语句MySQL中可以通过子查询来使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的 SQL 操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接(JOIN)..替代。 例子：假设要将所有没有订单记录的用户取出来，可以用下面这个查询完成： 1SELECT col1 FROM customerinfo WHERE CustomerID NOT in (SELECT CustomerID FROM salesinfo ) 如果使用连接(JOIN).. 来完成这个查询工作，速度将会有所提升。尤其是当 salesinfo表中对 CustomerID 建有索引的话，性能将会更好，查询如下： 123SELECT col1 FROM customerinfo LEFT JOIN salesinfoON customerinfo.CustomerID=salesinfo.CustomerID WHERE salesinfo.CustomerID IS NULL 连接(JOIN).. 之所以更有效率一些，是因为 MySQL 不需要在内存中创建临时表来完成这个逻辑上的需要两个步骤的查询工作。 4. 优化union查询MySQL通过创建并填充临时表的方式来执行union查询。除非确实要消除重复的行，否则建议使用union all。原因在于如果没有all这个关键词，MySQL会给临时表加上distinct选项，这会导致对整个临时表的数据做唯一性校验，这样做的消耗相当高。 高效： 12345SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION ALL SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &#x27;TEST&#x27;; 低效： 12345SELECT COL1, COL2, COL3 FROM TABLE WHERE COL1 = 10 UNION SELECT COL1, COL2, COL3 FROM TABLE WHERE COL3= &#x27;TEST&#x27;; 5.拆分复杂SQL为多个小SQL，避免大事务 简单的SQL容易使用到MySQL的QUERY CACHE； 减少锁表时间特别是使用MyISAM存储引擎的表； 可以使用多核CPU。 6. 使用truncate代替delete当删除全表中记录时，使用delete语句的操作会被记录到undo块中，删除记录也记录binlog，当确认需要删除全表时，会产生很大量的binlog并占用大量的undo数据块，此时既没有很好的效率也占用了大量的资源。 使用truncate替代，不会记录可恢复的信息，数据不能被恢复。也因此使用truncate操作有其极少的资源占用与极快的时间。另外，使用truncate可以回收表的水位，使自增字段值归零。 7. 使用合理的分页方式以提高分页效率使用合理的分页方式以提高分页效率 针对展现等分页需求，合适的分页方式能够提高分页的效率。 案例1： 12select * from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15; 上述例子通过一次性根据过滤条件取出所有字段进行排序返回。数据访问开销&#x3D;索引IO+索引全部记录结果对应的表数据IO。因此，该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。 适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。 案例2： 123select t.* from (select id from t where thread_id = 10000 and deleted = 0 order by gmt_create asc limit 0, 15) a, t where a.id = t.id; 上述例子必须满足t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)。通过先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。数据访问开销&#x3D;索引IO+索引分页后结果（例子中是15行）对应的表数据IO。因此，该写法每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。 适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。 五、建表优化1. 在表中建立索引，优先考虑where、order by使用到的字段。2. 尽量使用数字型字段（如性别，男：1 女：2），若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 3. 查询数据量大的表 会造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段分页进行查询，循环遍历，将结果合并处理进行展示。要查询100000到100050的数据，如下： 12SELECT * FROM (SELECT ROW_NUMBER() OVER(ORDER BY ID ASC) AS rowid,* FROM infoTab)t WHERE t.rowid &gt; 100000 AND t.rowid &lt;= 100050 4. 用varchar&#x2F;nvarchar 代替 char&#x2F;nchar尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。","tags":["MySQL","DataBase","SQL优化"],"categories":["DataBase"]},{"title":"TCP/IP简述","path":"/2023/12/25/TCP-IP简述/","content":"一、TCP&#x2F;IP模型TCP&#x2F;IP协议模型（Transmission Control Protocol&#x2F;Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。 基于TCP&#x2F;IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP&#x2F;IP模型与OSI模型各层的对照关系。 TCP&#x2F;IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp 等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 上图清楚地表示了TCP&#x2F;IP协议中每个层的作用，而TCP&#x2F;IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。 上图以HTTP协议为例，具体说明。 二、数据链路层物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。 透明传输: 零比特填充、转义字符。 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC): 接收者检测错误,如果发现差错，丢弃该帧。 三、网络层1、IP协议IP协议是TCP&#x2F;IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。 1.1 IP地址在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。 32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。 A类IP地址: 0.0.0.0127.0.0.0B类IP地址:128.0.0.1191.255.0.0C类IP地址:192.168.0.0~239.255.255.0 1.2 IP协议头 这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。 这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。 2、ARP及RARP协议ARP 是根据IP地址获取MAC地址的一种协议。 ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 3、ICMP协议IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 四、pingping可以说是ICMP的最著名的应用，是TCP&#x2F;IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。 例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下: ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请求，受到请求的主机则用类型码为8的ICMP回应。 五、TracerouteTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL&#x3D;1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL&#x3D;2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 六、TCP&#x2F;UDPTCP&#x2F;UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。 面向报文 面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。 面向字节流 面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。 关于拥塞控制，流量控制，是TCP的重点，后面讲解。 TCP和UDP协议的一些应用 什么时候应该使用TCP？ 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？ 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 七、DNSDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 八、TCP连接的建立与终止1、三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手？ 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。 于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 2、四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手？ TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么要等待2MSL？ MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二： 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失 第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 九、TCP流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd &#x3D; 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd &#x3D; 300 ，第二次又减到了 rwnd &#x3D; 100 ，最后减到 rwnd &#x3D; 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK &#x3D; 1 ，只有在ACK&#x3D;1时确认号字段才有意义。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 十、TCP拥塞控制发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法： 当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。 另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下： 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd &#x3D; ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。拥塞避免 拥塞避免 让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。 如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。 2、快重传和快恢复快重传快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。 显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。 但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。 快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。 由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。 快恢复与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。","tags":["计算机网络","TCP/IP"],"categories":["计算机网络"]},{"title":"Java 泛型 T，E，K，V，?，傻傻分不清？","path":"/2023/12/24/Java-泛型-T，E，K，V，-，傻傻分不清？/","content":"前言Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 泛型带来的好处在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。 那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。 12345678910111213141516171819202122232425262728293031323334353637public class GlmapperGeneric&lt;T&gt; &#123; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public static void main(String[] args) &#123; // do nothing &#125; /** * 不指定类型 */ public void noSpecifyType() &#123; GlmapperGeneric glmapperGeneric = new GlmapperGeneric(); glmapperGeneric.set(&quot;test&quot;); // 需要强制类型转换 String test = (String) glmapperGeneric.get(); System.out.println(test); &#125; /** * 指定类型 */ public void specifyType() &#123; GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric(); glmapperGeneric.set(&quot;test&quot;); // 不需要强制类型转换 String test = glmapperGeneric.get(); System.out.println(test); &#125;&#125; 上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上。 泛型中通配符我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？ 常用的 T，E，K，V，？本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的： ？表示不确定的 java 类型 T (type) 表示具体的一个java类型 K V (key value) 分别代表java键值中的Key Value E (element) 代表Element ？无界通配符先从一个小例子看起 。 我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的： 1List&lt;Animal&gt; listAnimals 但是老板的想法确实这样的： 1List&lt;? extends Animal&gt; listAnimals 为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。 123456789101112131415161718192021static int countLegs (List&lt;? extends Animal &gt; animals ) &#123; int retVal = 0; for ( Animal animal : animals ) &#123; retVal += animal.countLegs(); &#125; return retVal;&#125;static int countLegs1 (List&lt; Animal &gt; animals ) &#123; int retVal = 0; for ( Animal animal : animals ) &#123; retVal += animal.countLegs(); &#125; return retVal;&#125;public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); // 不会报错 countLegs( dogs ); // 报错 countLegs1(dogs);&#125; 当调用 countLegs1 时，就会飘红，提示的错误信息如下： 所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。 上界通配符 &lt; ? extends E&gt; 上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。 在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处： 如果传入的类型不是 E 或者 E 的子类，编译不成功 泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用 12345private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2) &#123; E result = arg2; arg2.compareTo(arg1); //..... return result;&#125; 类型参数列表中如果有多个类型参数上限，用逗号分开 下界通配符 &lt; ? super E&gt; 下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object 在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。 1234567891011121314private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src) &#123; for (T t : src) &#123; dst.add(t); &#125;&#125;public static void main(String[] args) &#123; List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;(); List&lt;Animal&gt; animals = new ArrayList&lt;&gt;(); new Test3().test(animals,dogs);&#125;// Dog 是 Animal 的子类class Dog extends Animal &#123;&#125; dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。 ？和 T 的区别 ？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ： 1234// 可以T t = operate();// 不可以？car = operate(); 简单总结下： T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。 区别1：通过 T 来 确保 泛型参数的一致性12345// 通过 T 来 确保 泛型参数的一致性public &lt;T extends Number&gt; voidtest(List&lt;T&gt; dest, List&lt;T&gt; src)//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型public void test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src) 像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。 不能保证两个 List 具有相同的元素类型的情况 1234GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();List&lt;String&gt; dest = new ArrayList&lt;&gt;();List&lt;Number&gt; src = new ArrayList&lt;&gt;();glmapperGeneric.testNon(dest,src); 上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。 区别2：类型参数可以多重限定而通配符不行 使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。 区别3：通配符可以使用超类限定而类型参数不行类型参数 T 只具有 一种 类型限定方式： 1T extends A 但是通配符 ? 可以进行 两种限定： 1? extends A? super A ** Class 和 Class&lt;?&gt; 区别**前面介绍了 ？和 T 的区别，那么对于，Class 和 &lt;Class 又有什么区别呢？Class 和 Class 最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。 123// 通过反射的方式生成 multiLimit // 对象，这里比较明显的是，我们需要使用强制类型转换MultiLimit multiLimit = (MultiLimit)Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance(); 对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。 对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题： Class 在实例化的时候，T 要替换成具体类。Class&lt;?&gt; 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明： 1234// 可以public Class&lt;?&gt; clazz;// 不可以，因为 T 需要指定类型public Class&lt;T&gt; clazzT; 所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;。 那如果也想 public Class clazzT; 这样的话，就必须让当前的类也指定 T ， 123public class Test3&lt;T&gt; &#123; public Class&lt;?&gt; clazz; // 不会报错 public Class&lt;T&gt; clazzT; 小结本文零碎整理了下 JAVA 泛型中的一些点，不是很全，仅供参考。","tags":["Java","泛型"],"categories":["Java"]},{"title":"Docker从入门到干活，看这一篇足矣","path":"/2023/12/24/Docker从入门到干活，看这一篇足矣/","content":"1. 容器简介1.1. 什么是 Linux 容器Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由该镜像提供支持进程所需的全部文件。 容器提供的镜像包含了应用的所有依赖项，因而在从开发到测试再到生产的整个过程中，它都具有可移植性和一致性。 更加详细地来说，请您假定您在开发一个应用。您使用的是一台笔记本电脑，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用依赖于您当前的配置，还要依赖于某些特定文件。 与此同时，您的企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。 您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。 因此，您要如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的问题，也无需重新编写代码和进行故障修复？答案就是使用容器。 容器可以确保您的应用拥有必需的配置和文件，使得这些应用能够在从开发到测试、再到生产的整个流程中顺利运行，而不出现任何不良问题。这样可以避免危机，做到皆大欢喜。 虽然这只是简化的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用 Linux 容器通过很多方式解决难题。 无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。 1.2. 容器不就是虚拟化吗是，但也不竟然。我们用一种简单方式来思考一下： 虚拟化使得许多操作系统可同时在单个系统上运行。 容器则可共享同一个操作系统内核，将应用进程与系统其他部分隔离开。 图 - 普通虚拟化技术和Docker的对比 这意味着什么？首先，让多个操作系统在单个虚拟机监控程序上运行以实现虚拟化，并不能达成和使用容器同等的轻量级效果。 事实上，在仅拥有容量有限的有限资源时，您需要能够可以进行密集部署的轻量级应用。 Linux 容器可从单个操作系统运行，在所有容器中共享该操作系统，因此应用和服务能够保持轻量级，并行快速运行。 1.3. 容器发展简史 我们现在称为容器技术的概念最初出现在 2000 年，当时称为 FreeBSD jail，这种技术可将 FreeBSD 系统分区为多个子系统（也称为 Jail）。 Jail 是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些 Jail。 Jail 的目的是让进程在经过修改的 chroot 环境中创建，而不会脱离和影响整个系统 — 在 chroot 环境中，对文件系统、网络和用户的访问都实现了虚拟化。 尽管 Jail 在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。 但这个概念非常有吸引力。 2001 年，通过 Jacques Gélinas 的 VServer 项目，隔离环境的实施进入了 Linux 领域。 正如 Gélinas 所说，这项工作的目的是“在高度独立且安全的单一环境中运行多个通用 Linux 服务器 [sic]。” 在完成了这项针对 Linux 中多个受控制用户空间的基础性工作后，Linux 容器开始逐渐成形并最终发展成了现在的模样。 2. 什么是 Docker？“Docker” 一词指代多种事物，包括开源社区项目、开源项目使用的工具、主导支持此类项目的公司 Docker Inc. 以及该公司官方支持的工具。技术产品和公司使用同一名称，的确让人有点困惑。 🎍 IT 软件中所说的 “Docker” ，是指容器化技术，用于支持创建和使用 Linux 容器。 🎍 开源 Docker 社区致力于改进这类技术，并免费提供给所有用户，使之获益。 🎍 Docker Inc. 公司凭借 Docker 社区产品起家，它主要负责提升社区版本的安全性，并将改进后的版本与更广泛的技术社区分享。此外，它还专门对这些技术产品进行完善和安全固化，以服务于企业客户。 借助 Docker ，您可将容器当做重量轻、模块化的虚拟机使用。同时，您还将获得高度的灵活性，从而实现对容器的高效创建、部署及复制，并能将其从一个环境顺利迁移至另一个环境。 2.1. Docker 如何工作？Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。 这种独立性正是采用容器的目的所在；它可以独立运行多种进程、多个应用程序，更加充分地发挥基础设施的作用，同时保持各个独立系统的安全性。 容器工具（包括 Docker）可提供基于镜像的部署模式。这使得它能够轻松跨多种环境，与其依赖程序共享应用或服务组。Docker 还可在这一容器环境中自动部署应用程序（或者合并多种流程，以构建单个应用程序）。 此外，由于这些工具基于 Linux 容器构建，使得 Docker 既易于使用，又别具一格 —— 它可为用户提供前所未有的高度应用程访问权限、快速部署以及版本控制和分发能力。 2.2. Docker 技术是否与传统的 Linux 容器相同？否。Docker 技术最初是基于 LXC 技术构建（大多数人都会将这一技术与“传统的” Linux 容器联系在一起），但后来它逐渐摆脱了对这种技术的依赖。 就轻量级 虚拟化 这一功能来看，LXC 非常有用，但它无法提供出色的开发人员或用户体验。除了运行容器之外，Docker 技术还具备其他多项功能，包括简化用于构建容器、传输镜像以及控制镜像版本的流程。 传统的 Linux 容器使用 init 系统来管理多种进程。这意味着，所有应用程序都作为一个整体运行。与此相反，Docker 技术鼓励应用程序各自独立运行其进程，并提供相应工具以实现这一功能。这种精细化运作模式自有其优势。 2.3. docker的目标docker的主要目标是”Build,Ship and Run any App,Angwhere”,构建，运输，处处运行 构建：做一个docker镜像 运输：docker pull 运行：启动一个容器 每一个容器，他都有自己的文件系统rootfs. 3. 安装Docker环境说明 123456789# 需要两台几点进行安装[root@docker01 ~]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) [root@docker01 ~]# uname -r 3.10.0-327.el7.x86_64[root@docker01 ~]# hostname -I10.0.0.100 172.16.1.100 [root@docker02 ~]# hostname -I10.0.0.101 172.16.1.101 在两个节点上都进行操作 123wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.reposed -i &#x27;s#download.docker.com#mirrors.ustc.edu.cn/docker-ce#g&#x27; /etc/yum.repos.d/docker-ce.repoyum install docker-ce -y 修改在docker01配置： 1234567# 修改启动文件，监听远程端口vim /usr/lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://10.0.0.100:2375systemctl daemon-reloadsystemctl enable docker.service systemctl restart docker.service# ps -ef检查进行，是否启动 在docker02测试 123456789[root@docker02 ~]# docker -H 10.0.0.100 infoContainers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 17.12.0-ceStorage Driver: devicemapper··· 3.1. Docker基础命令操作查看docker相关信息 1234567891011121314151617[root@docker01 ~]# docker version Client: Version: 17.12.0-ce API version: 1.35 Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:10:14 2017 OS/Arch: linux/amd64Server: Engine: Version: 17.12.0-ce API version: 1.35 (minimum version 1.12) Go version: go1.9.2 Git commit: c97c6d6 Built: Wed Dec 27 20:12:46 2017 OS/Arch: linux/amd64 Experimental: false 配置docker镜像加速 1234vi /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125; 3.2. 启动第一个容器12345678910[root@docker01 ~]# docker run -d -p 80:80 nginxUnable to find image &#x27;nginx:latest&#x27; locallylatest: Pulling from library/nginxe7bb522d92ff: Pull complete 6edc05228666: Pull complete cd866a17e81f: Pull complete Digest: sha256:285b49d42c703fdf257d1e2422765c4ba9d3e37768d6ea83d7fe2043dad6e63dStatus: Downloaded newer image for nginx:latest8d8f81da12b5c10af6ba1a5d07f4abc041cb95b01f3d632c3d638922800b0b4d# 容器启动后，在浏览器进行访问测试 参数说明 3.3. Docker镜像生命周期 4. Docker镜像相关操作4.1. 搜索官方仓库镜像1234[root@docker01 ~]# docker search centosNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 3992 [OK] ansible/centos7-ansible Ansible on Centos7 105 [OK] 列表说明 4.2. 获取镜像根据镜像名称拉取镜像 1234[root@docker01 ~]# docker pull centosUsing default tag: latestlatest: Pulling from library/centosaf4b0a2388c6: Downloading 34.65MB/73.67MB 查看当前主机镜像列表 1234[root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest ff426288ea90 3 weeks ago 207MBnginx latest 3f8a4339aadd 5 weeks ago 108MB 拉第三方镜像方法 1docker pull index.tenxcloud.com/tenxcloud/httpd 4.3. 导出镜像123456[root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest ff426288ea90 3 weeks ago 207MBnginx latest 3f8a4339aadd 5 weeks ago 108MB# 导出[root@docker01 ~]# docker image save centos &gt; docker-centos.tar.gz 4.4. 删除镜像1234[root@docker01 ~]# docker image rm centos:latest[root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZEnginx latest 3f8a4339aadd 5 weeks ago 108MB 4.5. 导入镜像1234567[root@docker01 ~]# docker image load -i docker-centos.tar.gz e15afa4858b6: Loading layer 215.8MB/215.8MBLoaded image: centos:latest[root@docker01 ~]# docker image list REPOSITORY TAG IMAGE ID CREATED SIZEcentos latest ff426288ea90 3 weeks ago 207MBnginx latest 3f8a4339aadd 5 weeks ago 108MB 4.6. 查看镜像的详细信息1[root@docker01 ~]# docker image inspect centos 5. 容器的日常管理5.1. 容器的起&#x2F;停最简单的运行一个容器 1[root@docker01 ~]# docker run nginx 创建容器，两步走（不常用） 1234[root@docker01 ~]# docker create centos:latest /bin/bashbb7f32368ecf0492adb59e20032ab2e6cf6a563a0e6751e58930ee5f7aaef204[root@docker01 ~]# docker start stupefied_nobelstupefied_nobel 快速启动容器方法 1[root@docker01 ~]# docker run centos:latest /usr/bin/sleep 20; 容器内的第一个进程必须一直处于运行的状态，否则这个容器，就会处于退出状态！ 查看正在运行的容器 12345[root@docker01 ~]# docker container ls 或[root@docker01 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8708e93fd767 nginx &quot;nginx -g &#x27;daemon of…&quot; 6 seconds ago Up 4 seconds 80/tcp keen_lewin 查看你容器详细信息&#x2F;ip 1[root@docker01 ~]# docker container inspect 容器名称/id 查看你所有容器（包括未运行的） 12345[root@docker01 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8708e93fd767 nginx &quot;nginx -g &#x27;daemon of…&quot; 4 minutes ago Exited (0) 59 seconds ago keen_lewinf9f3e6af7508 nginx &quot;nginx -g &#x27;daemon of…&quot; 5 minutes ago Exited (0) 5 minutes ago optimistic_haibt8d8f81da12b5 nginx &quot;nginx -g &#x27;daemon of…&quot; 3 hours ago Exited (0) 3 hours ago lucid_bohr 停止容器 123[root@docker01 ~]# docker stop 容器名称/id 或[root@docker01 ~]# docker container kill 容器名称/id 5.2. 进入容器方法启动时进去方法 123[root@docker01 ~]# docker run -it #参数：-it 可交互终端[root@docker01 ~]# docker run -it nginx:latest /bin/bashroot@79241093859e:/# 退出&#x2F;离开容器 1ctrl+p &amp; ctrl+q 启动后进入容器的方法 启动一个docker 12345[root@docker01 ~]# docker run -it centos:latest [root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 15:47 pts/0 00:00:00 /bin/bashroot 13 1 0 15:47 pts/0 00:00:00 ps -ef attach进入容器，使用pts&#x2F;0 ，会让所用通过此方法进如放入用户看到同样的操作。 12345[root@docker01 ~]# docker attach 1bf0f43c4d2f[root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 15:47 pts/0 00:00:00 /bin/bashroot 14 1 0 15:49 pts/0 00:00:00 ps -ef 自命名启动一个容器 –name 12345[root@docker01 ~]# docker attach 1bf0f43c4d2f[root@1bf0f43c4d2f /]# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 15:47 pts/0 00:00:00 /bin/bashroot 14 1 0 15:49 pts/0 00:00:00 ps -ef exec 进入容器方法（推荐使用） 1234567[root@docker01 ~]# docker exec -it clsn1 /bin/bash [root@b20fa75b4b40 /]# 重新分配一个终端[root@b20fa75b4b40 /]# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 16:11 pts/0 00:00:00 /bin/bashroot 13 0 0 16:14 pts/1 00:00:00 /bin/bashroot 26 13 0 16:14 pts/1 00:00:00 ps -ef 5.3. 删除所有容器12[root@docker01 ~]# docker rm -f `docker ps -a -q`# -f 强制删除 5.4. 启动时进行端口映射-p参数端口映射 12[root@docker01 ~]# docker run -d -p 8888:80 nginx:latest 287bec5c60263166c03e1fc5b0b8262fe76507be3dfae4ce5cd2ee2d1e8a89a9 不同指定映射方法 随机映射 1docker run -P （大P）# 需要镜像支持 6. Docker 数据卷的管理6.1. 挂载时创建卷挂载卷 12[root@docker01 ~]# docker run -d -p 80:80 -v /data:/usr/share/nginx/html nginx:latest079786c1e297b5c5031e7a841160c74e91d4ad06516505043c60dbb78a259d09 容器内站点目录: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html 在宿主机写入数据，查看 123[root@docker01 ~]# echo &quot;http://www.nmtui.com&quot; &gt;/data/index.html[root@docker01 ~]# curl 10.0.0.100http://www.nmtui.com 设置共享卷，使用同一个卷启动一个新的容器 1234[root@docker01 ~]# docker run -d -p 8080:80 -v /data:/usr/share/nginx/html nginx:latest 351f0bd78d273604bd0971b186979aa0f3cbf45247274493d2490527babb4e42[root@docker01 ~]# curl 10.0.0.100:8080http://www.nmtui.com 查看卷列表 12[root@docker01 ~]# docker volume lsDRIVER VOLUME NAME 6.2. 创建卷后挂载创建一个卷 12345[root@docker01 ~]# docker volume create f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521[root@docker01 ~]# docker volume ls DRIVER VOLUME NAMElocal f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521 指定卷名 1234[root@docker01 ~]# docker volume ls DRIVER VOLUME NAMElocal clsnlocal f3b95f7bd17da220e63d4e70850b8d7fb3e20f8ad02043423a39fdd072b83521 查看卷路径 123456789101112[root@docker01 ~]# docker volume inspect clsn [ &#123; &quot;CreatedAt&quot;: &quot;2018-02-01T00:39:25+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: &#123;&#125;, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/clsn/_data&quot;, &quot;Name&quot;: &quot;clsn&quot;, &quot;Options&quot;: &#123;&#125;, &quot;Scope&quot;: &quot;local&quot; &#125;] 使用卷创建 123456[root@docker01 ~]# docker run -d -p 9000:80 -v clsn:/usr/share/nginx/html nginx:latest 1434559cff996162da7ce71820ed8f5937fb7c02113bbc84e965845c219d3503# 宿主机测试[root@docker01 ~]# echo &#x27;blog.nmtui.com&#x27; &gt;/var/lib/docker/volumes/clsn/_data/index.html [root@docker01 ~]# curl 10.0.0.100:9000blog.nmtui.com 设置卷 12[root@docker01 ~]# docker run -d -P --volumes-from 079786c1e297 nginx:latest b54b9c9930b417ab3257c6e4a8280b54fae57043c0b76b9dc60b4788e92369fb 查看使用的端口 123456789101112[root@docker01 ~]# netstat -lntup Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 1400/sshd tcp 0 0 10.0.0.100:2375 0.0.0.0:* LISTEN 26218/dockerd tcp6 0 0 :::9000 :::* LISTEN 32015/docker-proxy tcp6 0 0 :::8080 :::* LISTEN 31853/docker-proxy tcp6 0 0 :::80 :::* LISTEN 31752/docker-proxy tcp6 0 0 :::22 :::* LISTEN 1400/sshd tcp6 0 0 :::32769 :::* LISTEN 32300/docker-proxy [root@docker01 ~]# curl 10.0.0.100:32769http://www.nmtui.com 6.3. 手动将容器保存为镜像本次是基于docker官方centos 6.8 镜像创建 官方镜像列表： https://hub.docker.com/explore/ 启动一个centos6.8的镜像 123456[root@docker01 ~]# docker pull centos:6.8[root@docker01 ~]# docker run -it -p 1022:22 centos:6.8 /bin/bash# 在容器种安装sshd服务，并修改系统密码[root@582051b2b92b ~]# yum install openssh-server -y [root@582051b2b92b ~]# echo &quot;root:123456&quot; |chpasswd[root@582051b2b92b ~]# /etc/init.d/sshd start 启动完成后镜像ssh连接测试 将容器提交为镜像 1[root@docker01 ~]# docker commit brave_mcclintock centos6-ssh 使用新的镜像启动容器 12[root@docker01 ~]# docker run -d -p 1122:22 centos6-ssh:latest /usr/sbin/sshd -D 5b8161fda2a9f2c39c196c67e2eb9274977e7723fe51c4f08a0190217ae93094 在容器安装httpd服务 1[root@5b8161fda2a9 /]# yum install httpd -y 编写启动脚本脚本 123456[root@5b8161fda2a9 /]# cat init.sh #!/bin/bash /etc/init.d/httpd start /usr/sbin/sshd -D[root@5b8161fda2a9 /]# chmod +x init.sh # 注意执行权限 再次提交为新的镜像 12[root@docker01 ~]# docker commit 5b8161fda2a9 centos6-httpd sha256:705d67a786cac040800b8485cf046fd57b1828b805c515377fc3e9cea3a481c1 启动镜像，做好端口映射。并在浏览器中测试访问 12[root@docker01 ~]# docker run -d -p 1222:22 -p 80:80 centos6-httpd /init.sh 46fa6a06644e31701dc019fb3a8c3b6ef008d4c2c10d46662a97664f838d8c2c 7. Dockerfile自动构建docker镜像官方构建dockerffile文件参考 https://github.com/CentOS/CentOS-Dockerfiles 7.1. Dockerfile指令集dockerfile主要组成部分： 基础镜像信息 FROM centos:6.8 制作镜像操作指令RUN yum insatll openssh-server -y 容器启动时执行指令 CMD [“&#x2F;bin&#x2F;bash”] dockerfile常用指令： FROM 这个镜像的妈妈是谁？（指定基础镜像） MAINTAINER 告诉别人，谁负责养它？（指定维护者信息，可以没有） RUN 你想让它干啥（在命令前面加上RUN即可） ADD 给它点创业资金（COPY文件，会自动解压） WORKDIR 我是cd,今天刚化了妆（设置当前工作目录） VOLUME 给它一个存放行李的地方（设置卷，挂载主机目录） EXPOSE 它要打开的门是啥（指定对外的端口） CMD 奔跑吧，兄弟！（指定容器启动后的要干的事情） dockerfile其他指令： COPY 复制文件 ENV 环境变量 ENTRYPOINT 容器启动后执行的命令 7.2. 创建一个Dockerfile创建第一个Dockerfile文件 123456789# 创建目录[root@docker01 base]# cd /opt/base# 创建Dcokerfile文件，注意大小写[root@docker01 base]# vim DockerfileFROM centos:6.8RUN yum install openssh-server -y RUN echo &quot;root:123456&quot; |chpasswdRUN /etc/init.d/sshd start CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;] 使用自构建的镜像启动 12[root@docker01 base]# docker image build -t centos6.8-ssh . -t 为镜像标签打标签 . 表示当前路径 使用自构建的镜像启动 12[root@docker01 base]# docker run -d -p 2022:22 centos6.8-ssh-b dc3027d3c15dac881e8e2aeff80724216f3ac725f142daa66484f7cb5d074e7a 7.3. 使用Dcokerfile安装kodexplorerDockerfile文件内容 12345678FROM centos:6.8RUN yum install wget unzip php php-gd php-mbstring -y &amp;&amp; yum clean all# 设置工作目录，之后的操作都在这个目录中WORKDIR /var/www/html/RUN wget -c http://static.kodcloud.com/update/download/kodexplorer4.25.zipRUN unzip kodexplorer4.25.zip &amp;&amp; rm -f kodexplorer4.25.zipRUN chown -R apache.apache .CMD [&quot;/usr/sbin/apachectl&quot;,&quot;-D&quot;,&quot;FOREGROUND&quot;] 更多的Dockerfile可以参考官方方法。 8. Docker中的镜像分层参考文档： http://www.maiziedu.com/wiki/cloud/dockerimage/ Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。 从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。 8.1. Docker 镜像为什么分层镜像分层最大的一个好处就是共享资源。 比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。 如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 &#x2F;etc 下的文件，这时其他容器的 &#x2F;etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。 8.2. 可写的容器层当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。 所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 8.3. 容器层的细节说明镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 &#x2F;a，上层的 &#x2F;a 会覆盖下层的 &#x2F;a，也就是说用户只能访问到上层中的文件 &#x2F;a。在容器层中，用户看到的是一个叠加之后的文件系统。 文件操作的 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 这样就解释了我们前面提出的问题：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。 9. 使用docker运行zabbix-server9.1. 容器间的互联在运行zabbix之前务必要了解容器间互联的方法 123456# 创建一个nginx容器docker run -d -p 80:80 nginx# 创建容器，做link，并进入容器中docker run -it --link quirky_brown:web01 centos-ssh /bin/bash# 在容器中访问nginx容器可以ping通ping web01 命令执行过程 12345678910111213141516171819# 启动apache容器[root@docker01 ~]# docker run -d httpd:2.4 3f1f7fc554720424327286bd2b04aeab1b084a3fb011a785b0deab6a34e56955^[[A[root@docker01 docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3f1f7fc55472 httpd:2.4 &quot;httpd-foreground&quot; 6 seconds ago Up 5 seconds 80/tcp determined_clarke# 拉取一个busybox 镜像[root@docker01 ~]# docker pull busybox # 启动容器[root@docker01 ~]# docker run -it --link determined_clarke:web busybox:latest /bin/sh / # # 使用新的容器访问最初的web容器/ # ping web PING web (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.058 ms^C--- web ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.058/0.058/0.058 ms 9.2. 启动zabbix容器1、启动一个mysql的容器 1234567docker run --name mysql-server -t \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; \\ -d mysql:5.7 \\ --character-set-server=utf8 --collation-server=utf8_bin 2、启动java-gateway容器监控java服务 12docker run --name zabbix-java-gateway -t \\ -d zabbix/zabbix-java-gateway:latest 3、启动zabbix-mysql容器使用link连接mysql与java-gateway。 1234567891011docker run --name zabbix-server-mysql -t \\ -e DB_SERVER_HOST=&quot;mysql-server&quot; \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; \\ -e ZBX_JAVAGATEWAY=&quot;zabbix-java-gateway&quot; \\ --link mysql-server:mysql \\ --link zabbix-java-gateway:zabbix-java-gateway \\ -p 10051:10051 \\ -d zabbix/zabbix-server-mysql:latest 4、启动zabbix web显示，使用link连接zabbix-mysql与mysql。 12345678910docker run --name zabbix-web-nginx-mysql -t \\ -e DB_SERVER_HOST=&quot;mysql-server&quot; \\ -e MYSQL_DATABASE=&quot;zabbix&quot; \\ -e MYSQL_USER=&quot;zabbix&quot; \\ -e MYSQL_PASSWORD=&quot;zabbix_pwd&quot; \\ -e MYSQL_ROOT_PASSWORD=&quot;root_pwd&quot; \\ --link mysql-server:mysql \\ --link zabbix-server-mysql:zabbix-server \\ -p 80:80 \\ -d zabbix/zabbix-web-nginx-mysql:latest 9.3. 关于zabbix API关于zabbix API可以参考官方文档： https://www.zabbix.com/documentation/3.4/zh/manual/api 1、获取token方法 123456789101112# 获取token[root@docker02 ~]# curl -s -X POST -H &#x27;Content-Type:application/json&#x27; -d &#x27;&#123;&quot;jsonrpc&quot;: &quot;2.0&quot;,&quot;method&quot;: &quot;user.login&quot;,&quot;params&quot;: &#123;&quot;user&quot;: &quot;Admin&quot;,&quot;password&quot;: &quot;zabbix&quot;&#125;,&quot;id&quot;: 1&#125;&#x27; http://10.0.0.100/api_jsonrpc.php&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;result&quot;:&quot;d3be707f9e866ec5d0d1c242292cbebd&quot;,&quot;id&quot;:1&#125; 10. docker 仓库（registry）10.1. 创建一个普通仓库1、创建仓库 1docker run -d -p 5000:5000 --restart=always --name registry -v /opt/myregistry:/var/lib/registry registry 2、修改配置文件，使之支持http 12345[root@docker01 ~]# cat /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;insecure-registries&quot;: [&quot;10.0.0.100:5000&quot;]&#125; 重启docker让修改生效 1[root@docker01 ~]# systemctl restart docker.service 3、修改镜像标签 123456[root@docker01 ~]# docker tag busybox:latest 10.0.0.100:5000/clsn/busybox:1.0[root@docker01 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos6-ssh latest 3c2b1e57a0f5 18 hours ago 393MBhttpd 2.4 2e202f453940 6 days ago 179MB10.0.0.100:5000/clsn/busybox 1.0 5b0d59026729 8 days ago 1.15MB 4、将新打标签的镜像上传镜像到仓库 1[root@docker01 ~]# docker push 10.0.0.100:5000/clsn/busybox 10.2. 带basic认证的仓库1、安装加密工具 1[root@docker01 clsn]# yum install httpd-tools -y 2、设置认证密码 12mkdir /opt/registry-var/auth/ -phtpasswd -Bbn clsn 123456 &gt; /opt/registry-var/auth/htpasswd 3、启动容器，在启动时传入认证参数 1docker run -d -p 5000:5000 -v /opt/registry-var/auth/:/auth/ -e &quot;REGISTRY_AUTH=htpasswd&quot; -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd registry 4、使用验证用户测试 12345678910111213141516171819202122232425# 登陆用户[root@docker01 ~]# docker login 10.0.0.100:5000 Username: clsn Password: 123456Login Succeeded# 推送镜像到仓库[root@docker01 ~]# docker push 10.0.0.100:5000/clsn/busybox The push refers to repository [10.0.0.100:5000/clsn/busybox]4febd3792a1f: Pushed 1.0: digest: sha256:4cee1979ba0bf7db9fc5d28fb7b798ca69ae95a47c5fecf46327720df4ff352d size: 527#认证文件的保存位置[root@docker01 ~]# cat .docker/config.json &#123; &quot;auths&quot;: &#123; &quot;10.0.0.100:5000&quot;: &#123; &quot;auth&quot;: &quot;Y2xzbjoxMjM0NTY=&quot; &#125;, &quot;https://index.docker.io/v1/&quot;: &#123; &quot;auth&quot;: &quot;Y2xzbjpIenNAMTk5Ng==&quot; &#125; &#125;, &quot;HttpHeaders&quot;: &#123; &quot;User-Agent&quot;: &quot;Docker-Client/17.12.0-ce (linux)&quot; &#125;&#125; 至此，一个简单的docker镜像仓库搭建完成 11. docker-compose编排工具11.1. 安装docker-compose1234# 下载pip软件yum install -y python2-pip# 下载 docker-composepip install docker-compose 国内开启pip 下载加速： http://mirrors.aliyun.com/help/pypi 1234567mkdir ~/.pip/cat &gt; ~/.pip/pip.conf &lt;&lt;&#x27;EOF&#x27;[global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.comEOF 11.2. 编排启动镜像1、创建文件目录 12[root@docker01 ~]# mkdir /opt/my_wordpress/[root@docker01 ~]# cd /opt/my_wordpress/ 2、编写编排文件 1234567891011121314151617181920212223242526[root@docker01 my_wordpress]# vim docker-compose.ymlversion: &#x27;3&#x27;services: db: image: mysql:5.7 volumes: - /data/db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /data/web_data:/var/www/html ports: - &quot;8000:80&quot; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress 3、启动 123[root@docker01 my_wordpress]# docker-compose up #启动方法：docker-compose up #后台启动方法：docker-compose up -d 4、浏览器上访问http://10.0.0.100:8000 进行wordpress的安装即可 11.3. haproxy代理后端docker容器1、修改编排脚本 1234567891011121314151617181920212223242526[root@docker01 my_wordpress]# cat docker-compose.yml version: &#x27;3&#x27;services: db: image: mysql:5.7 volumes: - /data/db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest volumes: - /data/web_data:/var/www/html ports: - &quot;80&quot; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress 2、同时启动两台wordpress 1234[root@docker01 my_wordpress]# docker-compose scale wordpress=2 WARNING: The scale command is deprecated. Use the up command with the --scale flag instead.Starting mywordpress_wordpress_1 ... doneCreating mywordpress_wordpress_2 ... done 3、安装haproxy 1[root@docker01 ~]# yum install haproxy -y 4、修改haproxy配置文件 关于配置文件的详细说明，参考： https://www.cnblogs.com/MacoLee/p/5853413.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@docker01 ~]#cp /etc/haproxy/haproxy.cfg&#123;,.bak&#125;[root@docker01 ~]# vim /etc/haproxy/haproxy.cfgglobal log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon stats socket /var/lib/haproxy/stats level admin #支持命令行控制defaults mode http log global option httplog option dontlognull option http-server-close option forwardfor except 127.0.0.0/8 option redispatch retries 3 timeout http-request 10s timeout queue 1m timeout connect 10s timeout client 1m timeout server 1m timeout http-keep-alive 10s timeout check 10s maxconn 3000listen stats mode http bind 0.0.0.0:8888 stats enable stats uri /haproxy-status stats auth admin:123456frontend frontend_www_example_com bind 10.0.0.100:8000 mode http option httplog log global default_backend backend_www_example_combackend backend_www_example_com option forwardfor header X-REAL-IP option httpchk HEAD / HTTP/1.0 balance roundrobin server web-node1 10.0.0.100:32768 check inter 2000 rise 30 fall 15 server web-node2 10.0.0.100:32769 check inter 2000 rise 30 fall 15 5、启动haproxy 12systemctl start haproxysystemctl enable haproxy 6、使用浏览器访问hapeoxy监听的8000端口可以看到负载的情况 7、使用浏览器访问 http://10.0.0.100:8888/haproxy-status 可以看到后端节点的监控状况， 11.4. 安装socat 直接操作socket控制haproxy1、安装软件 1yum install socat.x86_64 -y 2、查看帮助 1[root@docker01 web_data]# echo &quot;help&quot;|socat stdio /var/lib/haproxy/stats 3、下线后端节点 1echo &quot;disable server backend_www_example_com/web-node2&quot;|socat stdio /var/lib/haproxy/stats 4、上线后端节点 1echo &quot;enable server backend_www_example_com/web-node3&quot;|socat stdio /var/lib/haproxy/stats 5、编写php测试页，放到&#x2F;data&#x2F;web_data下，在浏览器中访问可以查看当前的节点 123456789101112[root@docker01 web_data]# vim check.php&lt;html&gt; &lt;head&gt; &lt;title&gt;PHP测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php echo &#x27;&lt;p&gt;Hello World &lt;/p&gt;&#x27;; ?&gt; &lt;?php echo &quot;访问的服务器地址是:&quot;.&quot;&lt;fontcolor=red&gt;&quot;.$_SERVER[&#x27;SERVER_ADDR&#x27;].&quot;&lt;/font&gt;&quot;.&quot;&lt;br&gt;&quot;; echo&quot;访问的服务器域名是:&quot;.&quot;&lt;fontcolor=red&gt;&quot;.$_SERVER[&#x27;SERVER_NAME&#x27;].&quot;&lt;/font&gt;&quot;.&quot;&lt;br&gt;&quot;; ?&gt; &lt;/body&gt;&lt;/html&gt; 12. 重启docker服务，容器全部退出的解决办法12.1. 在启动是指定自动重启1docker run --restart=always 12.1. 修改docker默认配置文件12# 添加上下面这行&quot;live-restore&quot;: true docker server配置文件 &#x2F;etc&#x2F;docker&#x2F;daemon.json 参考 1234567[root@docker02 ~]# cat /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;graph&quot;: &quot;/opt/mydocker&quot;, # 修改数据的存放目录到/opt/mydocker/，原/var/lib/docker/ &quot;insecure-registries&quot;: [&quot;10.0.0.100:5000&quot;], &quot;live-restore&quot;: true&#125; 重启生效，只对在此之后启动的容器生效 1[root@docker01 ~]# systemctl restart docker.service 13. Docker网络类型 13.1. docker的网络类型 Bridge默认docker网络隔离基于网络命名空间，在物理机上创建docker容器时会为每一个docker容器分配网络命名空间，并且把容器IP桥接到物理机的虚拟网桥上。 13.2. 不为容器配置网络功能此模式下创建容器是不会为容器配置任何网络参数的，如：容器网卡、IP、通信路由等，全部需要自己去配置。 123456[root@docker01 ~]# docker run -it --network none busybox:latest /bin/sh / # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 13.3. 与其他容器共享网络配置(Container）此模式和host模式很类似，只是此模式创建容器共享的是其他容器的IP和端口而不是物理机，此模式容器自身是不会配置网络和端口，创建此模式容器进去后，你会发现里边的IP是你所指定的那个容器IP并且端口也是共享的，而且其它还是互相隔离的，如进程等。 12345678910[root@docker01 ~]# docker run -it --network container:mywordpress_db_1 busybox:latest /bin/sh / # ip a1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever105: eth0@if106: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue link/ether 02:42:ac:12:00:03 brd ff:ff:ff:ff:ff:ff inet 172.18.0.3/16 brd 172.18.255.255 scope global eth0 valid_lft forever preferred_lft forever 13.4. 使用宿主机网络此模式创建的容器没有自己独立的网络命名空间，是和物理机共享一个Network Namespace，并且共享物理机的所有端口与IP，并且这个模式认为是不安全的。 1[root@docker01 ~]# docker run -it --network host busybox:latest /bin/shshell 13.5. 查看网络列表123456[root@docker01 ~]# docker network list NETWORK ID NAME DRIVER SCOPEb15e8a720d3b bridge bridge local345d65b4c2a0 host host localbc5e2a32bb55 mywordpress_default bridge localebf76eea91bb none null local 用PIPEWORK为docker容器配置独立IP 参考文档： blog.csdn.net&#x2F;design321&#x2F;article&#x2F;details&#x2F;48264825 官方网站： github.com&#x2F;jpetazzo&#x2F;pipework 宿主环境：centos7.2 1、安装pipework 1234wget https://github.com/jpetazzo/pipework/archive/master.zipunzip master.zip cp pipework-master/pipework /usr/local/bin/chmod +x /usr/local/bin/pipework 2、配置桥接网卡 安装桥接工具 1yum install bridge-utils.x86_64 -y 修改网卡配置，实现桥接 1234567891011121314151617181920# 修改eth0配置，让br0实现桥接[root@docker01 ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 TYPE=EthernetBOOTPROTO=staticNAME=eth0DEVICE=eth0ONBOOT=yesBRIDGE=br0[root@docker01 ~]# cat /etc/sysconfig/network-scripts/ifcfg-br0 TYPE=BridgeBOOTPROTO=staticNAME=br0DEVICE=br0ONBOOT=yesIPADDR=10.0.0.100NETMASK=255.255.255.0GATEWAY=10.0.0.254DNS1=223.5.5.5# 重启网络[root@docker01 ~]# /etc/init.d/network restart 3、运行一个容器镜像测试： 1pipework br0 $(docker run -d -it -p 6880:80 --name httpd_pw httpd) 10.0.0.220/24@10.0.0.254 在其他主机上测试端口及连通性 12345[root@docker01 ~]# curl 10.0.0.220&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;[root@docker01 ~]# ping 10.0.0.220 -c 1PING 10.0.0.220 (10.0.0.220) 56(84) bytes of data.64 bytes from 10.0.0.220: icmp_seq=1 ttl=64 time=0.043 ms 4、再运行一个容器，设置网路类型为none： 1pipework br0 $(docker run -d -it --net=none --name test httpd:2.4) 10.0.0.221/24@10.0.0.254 进行访问测试 12[root@docker01 ~]# curl 10.0.0.221&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 5、重启容器后需要再次指定： 12pipework br0 testduliip 172.16.146.113/24@172.16.146.1pipework br0 testduliip01 172.16.146.112/24@172.16.146.1 Dcoker跨主机通信之overlay可以参考： cnblogs.com&#x2F;CloudMan6&#x2F;p&#x2F;7270551.html 13.6. Docker跨主机通信之macvlan创建网络 12[root@docker01 ~]# docker network create --driver macvlan --subnet 10.1.0.0/24 --gateway 10.1.0.254 -o parent=eth0 macvlan_133a1f41dcc074f91b5bd45e7dfedabfb2b8ec82db16542f05213839a119b62ca 设置网卡为混杂模式 1ip link set eth0 promisc on 创建使用macvlan网络容器 1[root@docker02 ~]# docker run -it --network macvlan_1 --ip=10.1.0.222 busybox /b 14. docker企业级镜像仓库harbor容器管理 123[root@docker01 harbor]# pwd/opt/harbor[root@docker01 harbor]# docker-compose stop 1、安装docker、docker-compose 下载 harbor 12cd /opt &amp;&amp; https://storage.googleapis.com/harbor-releases/harbor-offline-installer-v1.3.0.tgztar xf harbor-offline-installer-v1.3.0.tgz 2、修改主机及web界面密码 12345[root@docker01 harbor]# vim harbor.cfg ··· hostname = 10.0.0.100 harbor_admin_password = Harbor12345 ··· 3、执行安装脚本 1[root@docker01 harbor]# ./install.sh 浏览器访问 http://10.0.0.11 添加一个项目 4、镜像推送到仓库的指定项目 1234567891011[root@docker02 ~]# docker tag centos:6.8 10.0.0.100/clsn/centos6.8:1.0[root@docker02 ~]# [root@docker02 ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZEbusybox latest 5b0d59026729 8 days ago 1.15MB10.0.0.100/clsn/centos6.8 1.0 6704d778b3ba 2 months ago 195MBcentos 6.8 6704d778b3ba 2 months ago 195MB[root@docker02 ~]# docker login 10.0.0.100Username: adminPassword: Login Succeeded 5、推送镜像 123[root@docker02 ~]# docker push 10.0.0.100/clsn/centos6.8 The push refers to repository [10.0.0.100/clsn/centos6.8]e00c9229b481: Pushing 13.53MB/194.5MB 6、在web界面里查看 14.1. 使用容器的建议 不要以拆分方式进行应用程序发布 不要创建大型镜像 不要在单个容器中运行多个进程 不要再镜像内保存凭证，不要依赖IP地址 以非root用户运行进程 不要使用“最新”标签 不要利用运行中的容器创建镜像 不要使用单层镜像 不要将数据存放在容器内 14.2. 关于Docker容器的监控容器的基本信息 包括容器的数量、ID、名称、镜像、启动命令、端口等信息 容器的运行状态 统计各状态的容器的数量，包括运行中、暂停、停止及异常退出 容器的用量信息 统计容器的CPU使用率、内存使用量、块设备I&#x2F;O使用量、网络使用情况等资源的使用情况 参考文献 redhat.com&#x2F;zh&#x2F;topics&#x2F;containers&#x2F;whats-a-linux-container redhat.com&#x2F;zh&#x2F;topics&#x2F;containers&#x2F;what-is-docker blog.51cto.com&#x2F;dihaifeng&#x2F;1713512 cnblogs.com&#x2F;Bourbon-tian&#x2F;p&#x2F;6867796.html cnblogs.com&#x2F;CloudMan6&#x2F;p&#x2F;6806193.html","tags":["开发工具","Docker"],"categories":["开发工具"]},{"title":"MySQL大表优化方案","path":"/2023/12/24/MySQL大表优化方案/","content":"当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化： 单表优化除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量： 字段 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED VARCHAR的长度只分配真正需要的空间 使用枚举或整数代替字符串类型 尽量使用TIMESTAMP而非DATETIME， 单表不要有太多字段，建议在20以内 避免使用NULL字段，很难查询优化且占用额外索引空间 用整型来存IP 索引 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描 值分布很稀少的字段不适合建索引，例如”性别”这种只有两三个值的字段 字符字段只建前缀索引 字符字段最好不要做主键 不用外键，由程序保证约束 尽量不用UNIQUE，由程序保证约束 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引 查询SQL 可通过开启慢查询日志来找出较慢的SQL 不做列运算：SELECT id WHERE age + 1 &#x3D; 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边 sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库 不用SELECT * OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内 不用函数和触发器，在应用程序实现 避免%xxx式查询 少用JOIN 使用同类型进行比较，比如用’123’和’123’比，123和123比 尽量避免在WHERE子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大 引擎目前广泛使用的是MyISAM和InnoDB两种引擎： MyISAMMyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是： 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁 不支持事务 不支持外键 不支持崩溃后的安全恢复 在表有读取查询的同时，支持往表中插入新纪录 支持BLOB和TEXT的前500个字符索引，支持全文索引 支持延迟更新索引，极大提升写入性能 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用 InnoDBInnoDB在MySQL 5.5后成为默认索引，它的特点是： 支持行锁，采用MVCC来支持高并发 支持事务 支持外键 支持崩溃后的安全恢复 不支持全文索引 总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表 系统调优参数可以使用下面几个工具来做基准测试： sysbench：一个模块化，跨平台以及多线程的性能测试工具 iibench-mysql：基于 Java 的 MySQL&#x2F;Percona&#x2F;MariaDB 索引进行插入性能测试工具 tpcc-mysql：Percona开发的TPC-C测试工具 具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数： back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500 wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时 max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限 thread_concurrency：并发线程数，设为CPU核数的两倍 skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问 key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like ‘key_read%’，保证key_reads &#x2F; key_read_requests在0.1%以下最好 innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like ‘Innodb_buffer_pool_read%’，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) &#x2F; Innodb_buffer_pool_read_requests越高越好 innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小 innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits&#x2F;(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.可以通过命令show status like ‘Qcache_%’查看目前系统Query catch使用大小 read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能 sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小 read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。 record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值 thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的 table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM 升级硬件Scale up，这个不多说了，根据MySQL是CPU密集型还是I&#x2F;O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能 读写分离也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离 缓存缓存可以发生在这些层次： MySQL内部：在系统调优参数介绍了相关设置 数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象Persistence Object 应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象Data Transfer Object Web层：针对web页面做缓存 浏览器客户端：用户端的缓存 可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式： 直写式（Write Through）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如Spring Cache的工作方式。这种实现非常简单，同步好，但效率一般。 回写式（Write Back）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。 表分区MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码 对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引 用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上： 12345678mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+| 1 | SIMPLE | user_partition | p1,p4 | range | PRIMARY | PRIMARY | 8 | NULL | 5 | Using where; Using index |+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+1 row in set (0.00 sec) 分区的好处是： 可以让单表存储更多的数据 分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作 部分查询能够从查询条件确定只落在少数分区上，速度会很快 分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备 可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争 可以备份和恢复单个分区 分区的限制和缺点： 一个表最多只能有1024个分区 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来 分区表无法使用外键约束 NULL值会使分区过滤无效 所有分区必须使用相同的存储引擎 分区的类型： RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区 LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择 HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式 KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值 分区适合的场景有： 最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示： 1234567891011121314CREATE TABLE members ( firstname VARCHAR(25) NOT NULL, lastname VARCHAR(25) NOT NULL, username VARCHAR(16) NOT NULL, email VARCHAR(35), joined DATE NOT NULL)PARTITION BY RANGE( YEAR(joined) ) ( PARTITION p0 VALUES LESS THAN (1960), PARTITION p1 VALUES LESS THAN (1970), PARTITION p2 VALUES LESS THAN (1980), PARTITION p3 VALUES LESS THAN (1990), PARTITION p4 VALUES LESS THAN MAXVALUE); 查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。 如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存 另外MySQL有一种早期的简单的分区实现 - 合并表（merge table），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代 垂直拆分垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联 比如原始的用户表是： 垂直拆分后是： 垂直拆分的优点是： 可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I&#x2F;O次数(每次查询时读取的Block 就少) 可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起 数据维护简单 缺点是： 主键出现冗余，需要管理冗余列 会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力 依然存在单表数据量过大的问题（需要水平拆分） 事务处理复杂 水平拆分概述水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。 前面的表分区本质上也是一种特殊的库内分表 库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决 前面垂直拆分的用户表如果进行水平拆分，结果是： 实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表 水平拆分的优点是: 不存在单库大数据和高并发的性能瓶颈 应用端改造较少 提高了系统的稳定性和负载能力 缺点是： 分片事务一致性难以解决 跨节点Join性能差，逻辑复杂 数据多次扩展难度跟维护量极大 分片原则 能不分就不分，参考单表优化 分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量 分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容 尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题 查询条件尽量优化，尽量避免Select * 的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。 通过数据冗余和表分区赖降低跨库Join的可能 这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。 总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。 解决方案由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。 客户端架构通过修改数据访问层，如JDBC、Data Source、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现 这是一个客户端架构的例子： 可以看到分片的实现是和应用服务器在一起的，通过修改Spring JDBC层来实现 客户端架构的优点是： 应用直连数据库，降低外围系统依赖所带来的宕机风险 集成成本低，无需额外运维的组件 缺点是： 限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心 将分片逻辑的压力放在应用服务器上，造成额外风险 代理架构通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件 这是一个代理架构的例子： 代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理 代理架构的优点是： 能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强 对于应用服务器透明且没有增加任何额外负载 缺点是： 需部署和运维独立的代理中间件，成本高 应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险 各方案比较 出品方 架构模型 支持数据库 分库 分表 读写分离 外部依赖 是否开源 实现语言 支持语言 最后更新 Github星数 MySQL Fabric MySQL官方 代理架构 MySQL 有 有 有 无 是 python 无限制 4个月前 35 Cobar 阿里巴巴 代理架构 MySQL 有 无 无 无 是 Java 无限制 两年前 1287 Cobar Client 阿里巴巴 客户端架构 MySQL 有 无 无 无 是 Java Java 三年前 344 TDDL 淘宝 客户端架构 无限制 有 有 有 Diamond 只开源部分 Java Java 未知 519 Atlas 奇虎360 代理架构 MySQL 有 有 有 无 是 C 无限制 10个月前 1941 Heisenberg 百度熊照 代理架构 MySQL 有 有 有 无 是 Java 无限制 2个月前 197 TribeDB 个人 代理架构 MySQL 有 有 有 无 是 NodeJS 无限制 3个月前 126 ShardingJDBC 当当 客户端架构 MySQL 有 有 有 无 是 Java Java 当天 1144 Shark 个人 客户端架构 MySQL 有 有 无 无 是 Java Java 两天前 84 KingShard 个人 代理架构 MySQL 有 有 有 无 是 Golang 无限制 两天前 1836 OneProxy 平民软件 代理架构 MySQL 有 有 有 无 否 未知 无限制 未知 未知 MyCat 社区 代理架构 MySQL 有 有 有 无 是 Java 无限制 两天前 1270 Vitess Youtube 代理架构 MySQL 有 有 有 无 是 Golang 无限制 当天 3636 Mixer 个人 代理架构 MySQL 有 有 无 无 是 Golang 无限制 9个月前 472 JetPants Tumblr 客户端架构 MySQL 有 有 无 无 是 Ruby Ruby 10个月前 957 HibernateShard Hibernate 客户端架构 无限制 有 有 无 无 是 Java Java 4年前 57 MybatisShard MakerSoft 客户端架构 无限制 有 有 无 无 是 Java Java 11个月前 119 Gizzard Twitter 代理架构 无限制 有 有 无 无 是 Java 无限制 3年前 2087 如此多的方案，如何进行选择？可以按以下思路来考虑： 确定是使用代理架构还是客户端架构。中小型规模或是比较简单的场景倾向于选择客户端架构，复杂场景或大规模系统倾向选择代理架构 具体功能是否满足，比如需要跨节点ORDER BY，那么支持该功能的优先考虑 不考虑一年内没有更新的产品，说明开发停滞，甚至无人维护和技术支持 最好按大公司-&gt;社区-&gt;小公司-&gt;个人这样的出品方顺序来选择 选择口碑较好的，比如github星数、使用者数量质量和使用者反馈 开源的优先，往往项目有特殊需求可能需要改动源代码 按照上述思路，推荐以下选择： 客户端架构：ShardingJDBC 代理架构：MyCat或者Atlas 兼容MySQL且可水平扩展的数据库目前也有一些开源数据库兼容MySQL协议，如： TiDB Cubrid 但其工业品质和MySQL尚有差距，且需要较大的运维投入，如果想将原始的MySQL迁移到可水平扩展的新数据库中，可以考虑一些云数据库： 阿里云PetaData 阿里云OceanBase 腾讯云DCDB NoSQL在MySQL上做Sharding是一种戴着镣铐的跳舞，事实上很多大表本身对MySQL这种RDBMS的需求并不大，并不要求ACID，可以考虑将这些表迁移到NoSQL，彻底解决水平扩展问题，例如： 日志类、监控类、统计类数据 非结构化或弱结构化数据 对事务要求不强，且无太多关联操作的数据","tags":["MySQL","DataBase","SQL优化"],"categories":["DataBase"]},{"title":"MyBatis 的执行流程","path":"/2023/12/24/MyBatis-的执行流程！/","content":"概要在MyBatis中，利用编程式进行数据查询，主要就是下面几行代码： 123SqlSession session = sqlSessionFactory.openSession();UserMapper userMapper = session.getMapper(UserMapper.class);List&lt;LwUser&gt; userList = userMapper.listUserByUserName(&quot;孤狼1号&quot;); 第一行是获取一个SqlSession对象在上一篇文章分析过了，第二行就是获取UserMapper接口，第三行一行代码就实现了整个查询语句的流程，接下来我们就来仔细分析一下第二和第三步。 获取Mapper接口(getMapper)第二步是通过SqlSession对象是获取一个Mapper接口，这个流程还是相对简单的，下面就是我们调用session.getMapper方法之后的运行时序图： 1、在调用getMapper之后，会去Configuration对象中获取Mapper对象，因为在项目启动的时候就会把Mapper接口加载并解析存储到Configuration对象 2、通过Configuration对象中的MapperRegistry对象属性，继续调用getMapper方法 3、根据type类型，从MapperRegistry对象中的knownMappers获取到当前类型对应的代理工厂类，然后通过代理工厂类生成对应Mapper的代理类 4、最终获取到我们接口对应的代理类MapperProxy对象 而MapperProxy可以看到实现了InvocationHandler，使用的就是JDK动态代理。 至此获取Mapper流程结束了，那么就有一个问题了MapperRegistry对象内的HashMap属性knownMappers中的数据是什么时候存进去的呢？ Mapper接口和映射文件是何时关联的Mapper接口及其映射文件是在加载mybatis-config配置文件的时候存储进去的，下面就是时序图： 1、首先我们会手动调用SqlSessionFactoryBuilder方法中的build()方法： 2、然后会构造一个XMLConfigBuilder对象，并调用其parse方法： 3、然后会继续调用自己的parseConfiguration来解析配置文件，这里面就会分别去解析全局配置文件的顶级节点，其他的我们先不看，我们直接看最后解析mappers节点 4、继续调用自己的mapperElement来解析mappers文件（这个方法比较长，为了方便截图完整，所以把字体缩小了1号），可以看到，这里面分了四种方式来解析mappers节点的配置，对应了4种mapper配置方式，而其中红框内的两种方式是直接配置的xml映射文件，蓝框内的两种方式是解析直接配置Mapper接口的方式，从这里也可以说明，不论配置哪种方式，最终MyBatis都会将xml映射文件和Mapper接口进行关联。 5、我们先看第2种和第3中（直接配置xml映射文件的解析方式），会构建一个XMLMapperBuilder对象并调用其parse方法。 当然，这个还是会被解析的，后面执行查询的时候会再次通过不断遍历去全部解析完毕，不过有一点需要注意的是，互相引用这种是会导致解析失败报错的，所以在开发过程中我们应该避免循环依赖的产生。 6、解析完映射文件之后，调用自身方法bindMapperForNamespace，开始绑定Mapper接口和映射文件： 7、调用Configuration对象的addMapper 8、调用Configuration对象的属性MapperRegistry内的addMapper方法，这个方法就是正式将Mapper接口添加到knownMappers，所以上面getMapper可以直接获取： 到这里我们就完成了Mapper接口和xml映射文件的绑定 9、注意上面红框里面的代码，又调用了一次parse方法，这个parse方法主要是解析注解，比如下面的语句： 12@Select(&quot;select * from lw_user&quot;)List&lt;LwUser&gt; listAllUser(); 所以这个方法里面会去解析@Select等注解，需要注意的是，parse方法里面会同时再解析一次xml映射文件，因为上面我们提到了mappers节点有4种配置方式，其中两种配置的是Mapper接口，而配置Mapper接口会直接先调用addMapper接口，并没有解析映射文件，所以进入注解解析方法parse之中会需要再尝试解析一次XML映射文件。 解析完成之后，还会对Mapper接口中的方法进行解析，并将每个方法的全限定类名作为key存入存入Configuration中的mappedStatements属性。 需要指出的是，这里存储的时候，同一个value会存储2次，**一个全限定名作为key，另一个就是只用方法名(sql语句的id)来作为key**： 所以最终mappedStatements会是下面的情况： 事实上如果我们通过接口的方式来编程的话，最后来getStatement的时候，都是根据全限定名来取的，所以即使有重名对我们也没有影响，而之所以要这么做的原因其实还是为了兼容早期版本的用法，那就是不通过接口，而是直接通过方法名的方式来进行查询： 1session.selectList(&quot;com.lonelyWolf.mybatis.mapper.UserMapper.listAllUser&quot;); 这里如果shortName没有重复的话，是可以直接通过简写来查询的： 1session.selectList(&quot;listAllUser&quot;); 但是通过简写来查询一旦shortName重复了就会抛出以下异常： 这里的异常其实就是StrickMap的get方法抛出来的： sql执行流程分析上面我们讲到了，获取到的Mapper接口实际上被包装成为了代理对象，所以我们执行查询语句肯定是执行的代理对象方法，接下来我们就以Mapper接口的代理对象MapperProxy来分析一下查询流程。 整个sql执行流程可以分为两大步骤： 一、寻找sql 二、执行sql语句 寻找sql首先还是来看一下寻找sql语句的时序图： 1、了解代理模式的应该都知道，调用被代理对象的方法之后实际上执行的就是代理对象的invoke方法 2、因为我们这里并没有调用Object类中的方法，所以肯定走的else。else中会继续调用MapperProxy内部类MapperMethodInvoker中的方法cachedInvoker，这里面会有一个判断，判断一下我们是不是default方法，因为Jdk1.8中接口中可以新增default方法，而default方法是并不是一个抽象方法，所以也需要特殊处理（刚开始会从缓存里面取，缓存相关知识我们这里先不讲，后面会单独写一篇来分析一下缓存)）。 3、接下来，是构造一个MapperMethod对象,这个对象封装了Mapper接口中对应的方法信息以及对应的sql语句信息： 这里面就会把要执行的sql语句，请求参数，方法返回值全部解析封装成MapperMethod对象，然后后面就可以开始准备执行sql语句了 执行sql语句还是先来看一下执行Sql语句的时序图： 1、我们继续上面的流程进入execute方法： 2、这里面会根据语句类型以及返回值类型来决定如何执行，本人这里返回的是一个集合，故而我们进入executeForMany方法： 3、这里面首先会将前面存好的参数进行一次转换，然后绕了这么一圈，回到了起点SqlSession对象，继续调用selectList方法： 3、接下来又讲流程委派给了Execute去执行query方法，最终又会去调用queryFromDatabase方法： 4、到这里之后，终于要进入正题了，一般带了这种do开头的方法就是真正做事的，Spring中很多地方也是采用的这种命名方式： 注意，前面我们的sql语句还是占位符的方式，并没有将参数设置进去，所以这里在return上面一行调用prepareStatement方法创建Statement对象的时候会去设置参数，替换占位符。参数如何设置我们先跳过，等把流程执行完了我们在单独分析参数映射和结果集映射。 5、继续进入PreparedStatementHandler对象的query方法，可以看到，这一步就是调用了jdbc操作对象PreparedStatement中的execute方法，最后一步就是转换结果集然后返回。 到这里，整个SQL语句执行流程分析就结束了，中途有一些参数的存储以及转换并没有深入进去，因为参数的转换并不是核心，只要清楚整个数据的流转流程，我们自己也可以有自己的实现方式，只要存起来最后我们能重新解析读出来就行。 参数映射现在我们来看一下上面在执行查询之前参数是如何进行设置的，我们先进入prepareStatement方法： 我们发现，最终是调用了StatementHandler中的parameterize进行参数设置，接下来这里为了节省篇幅，我们不会一步步点进去，直接进入设置参数的方法： 上面的BaseTypeHandler是一个抽象类，setNonNullParameter并没有实现，都是交给子类去实现，而每一个子类就是对应了数据库的一种类型。下图中就是默认的一个子类StringTypeHandler，里面没什么其他逻辑，就是设置参数。 可以看到String里面调用了jdbc中的setString方法，而如果是int也会调用setInt方法。看到这些子类如果大家之前阅读过我前面讲的MyBatis参数配置，应该就很明显可以知道，这些子类就是系统默认提供的一些typeHandler。而这些默认的typeHandler会默认被注册并和Java对象进行绑定： 正是因为MyBatis中默认提供了常用数据类型的映射，所以我们写Sql的时候才可以省略参数映射关系，可以直接采用下面的方式，系统可以根据我们参数的类型，自动选择合适的typeHander进行映射： 1select user_id,user_name from lw_user where user_name=#&#123;userName&#125; 上面这条语句实际上和下面这条是等价的： 1select user_id,user_name from lw_user where user_name=#&#123;userName,jdbcType=VARCHAR&#125; 或者说我们可以直接指定typeHandler： 1select user_id,user_name from lw_user where user_name = #&#123;userName,jdbcType=VARCHAR,typeHandler=org.apache.ibatis.type.IntegerTypeHandler&#125; 这里因为我们配置了typeHandler，所以会优先以配置的typeHandler为主不会再去读取默认的映射，如果类型不匹配就会直接报错了： 看到这里很多人应该就知道了，如果我们自己自定义一个typeHandler，然后就可以配置成我们自己的自定义类。所以接下来就让我们看看如何自定义一个typeHandler 自定义typeHandler自定义typeHandler需要实现BaseTypeHandler接口，BaseTypeHandler有4个方法，包括结果集映射，为了节省篇幅，代码没有写上来： 1234567891011121314151617package com.lonelyWolf.mybatis.typeHandler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class MyTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException &#123; System.out.println(&quot;自定义typeHandler生效了&quot;); preparedStatement.setString(index,param); &#125; 然后我们改写一下上面的查询语句： 1select user_id,user_name from lw_user where user_name=#&#123;userName,jdbcType=VARCHAR,typeHandler=com.lonelyWolf.mybatis.typeHandler.MyTypeHandler&#125; 然后执行，可以看到，自定义的typeHandler生效了： 结果集映射接下来让我们看看结果集的映射，回到上面执行sql流程的最后一个方法： 1resultSetHandler.handleResultSets(ps) 结果集映射里面的逻辑相对来说还是挺复杂的，因为要考虑到非常多的情况，这里我们就不会去深究每一个细节，直接进入到正式解析结果集的代码，下面的5个代码片段就是一个简单的但是完整的解析流程： 从上面的代码片段我们也可以看到，实际上解析结果集还是很复杂的，就如我们上一篇介绍的复杂查询一样，一个查询可以不断嵌套其他查询，还有延迟加载等等一些复杂的特性的处理，所以逻辑分支是有很多，但是不管怎么处理，最后的核心还是上面的一套流程，最终还是会调用typeHandler来获取查询到的结果。 是的，你没猜错，这个就是上面我们映射参数的typeHandler，因为typeHandler里面不只是一个设置参数方法，还有获取结果集方法(上面设置参数的时候省略了)。 自定义typeHandler结果集所以说我们还是用上面那个MyTypeHandler 例子来重写一下取值方法(省略了设置参数方法)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.lonelyWolf.mybatis.typeHandler;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class MyTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; /** * 设置参数 */ @Override public void setNonNullParameter(PreparedStatement preparedStatement, int index, String param, JdbcType jdbcType) throws SQLException &#123; System.out.println(&quot;设置参数-&gt;自定义typeHandler生效了&quot;); preparedStatement.setString(index,param); &#125; /** * 根据列名获取结果 */ @Override public String getNullableResult(ResultSet resultSet, String columnName) throws SQLException &#123; System.out.println(&quot;根据columnName获取结果-&gt;自定义typeHandler生效了&quot;); return resultSet.getString(columnName); &#125; /** * 根据列的下标来获取结果 */ @Override public String getNullableResult(ResultSet resultSet, int columnIndex) throws SQLException &#123; System.out.println(&quot;根据columnIndex获取结果-&gt;自定义typeHandler生效了&quot;); return resultSet.getString(columnIndex); &#125; /** * 处理存储过程的结果集 */ @Override public String getNullableResult(CallableStatement callableStatement, int columnIndex) throws SQLException &#123; return callableStatement.getString(columnIndex); &#125;&#125; 改写Mapper映射文件配置： 12345678&lt;resultMap id=&quot;MyUserResultMap&quot; type=&quot;lwUser&quot;&gt; &lt;result column=&quot;user_id&quot; property=&quot;userId&quot; jdbcType=&quot;VARCHAR&quot; typeHandler=&quot;com.lonelyWolf.mybatis.typeHandler.MyTypeHandler&quot; /&gt; &lt;result column=&quot;user_name&quot; property=&quot;userName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;&lt;/resultMap&gt;&lt;select id=&quot;listUserByUserName&quot; parameterType=&quot;String&quot; resultMap=&quot;MyUserResultMap&quot;&gt; select user_id,user_name from lw_user where user_name=#&#123;userName,jdbcType=VARCHAR,typeHandler=com.lonelyWolf.mybatis.typeHandler.MyTypeHandler&#125;&lt;/select&gt; 执行之后输出如下： 因为我们属性上面只配置了一个属性，所以只输出了一次。 工作流程图上面介绍了代码的流转，可能绕来绕去有点晕，所以我们来画一个主要的对象之间流程图来更加清晰的展示一下MyBatis主要工作流程： 从上面的工作流程图上我们可以看到，SqlSession下面还有4大对象，这4大对象也很重要，后面学习拦截器的时候就是针对这4大对象进行的拦截，关于这4大对象的具体详情，我们下一篇文章再展开分析。 总结本文主要分析了MyBatis的SQL执行流程。在分析流程的过程中，我们也举例论证了如何自定义typeHandler来实现自定义的参数映射和结果集映射，不过MyBatis中提供的默认映射其实可以满足大部分的需求，如果我们对某些属性需要特殊处理，那么就可以采用自定义的typeHandler来实现，相信如果本文如果读懂了，以下几点大家应该至少会有一个清晰的认识： 1、Mapper接口和映射文件是如何进行绑定的 2、MyBatis中SQL语句的执行流程 3、自定义MyBatis中的参数设置处理器typeHandler 4、自定义MyBatis中结果集处理器typeHandler 当然，其中很多细节并没有提到，而看源码我们也并不需要追求每一行代码都能看懂，就比如我们一个稍微复杂一点的业务系统，即使我们是项目开发者如果某一个模块不是本人负责的，恐怕也很难搞清楚每一行代码的含义。所以对于MyBatis及其他框架的源码中也是一样，首先应该从大局入手，掌握整体流程和设计思想，然后如果对某些实现细节感兴趣，再深入进行了解。","tags":["MyBatis","框架"],"categories":["框架"]},{"title":"用“状态模式”代替if-else","path":"/2023/12/24/用“状态模式”代替if-else/","content":"简介 状态模式是行为型设计模式的一种。其设计理念是当对象的内部状态发生改变时，随之改变其行为。状态和行为之间是一一对应的。 该模式主要用于，对象的行为依赖于它的状态，并且其行为是随着状态的改变而切换时。 状态模式UML类图类图讲解 State：抽象状态接口（也可以定义成抽象类），该接口封装了所有状态所对应的行为。ConcreteStateA&#x2F;B：具体状态类，该类实现了抽象状态接口，会根据自身对应的状态来实现接口中定义的方法，还有另一个功能是指明如何过渡到下一个状态。Context：环境（上下文）角色，该类负责状态的切换，还持有一个State实例，代表当前环境所处状态。 案例讲解案例：通过状态模式来实现自助售卖机的功能。 状态接口12345678public interface State &#123; // 挑选商品 void choose(); // 付款 boolean payment(); // 分发商品 void dispenseCommodity();&#125; 挑选商品状态类123456789101112131415161718192021222324252627282930public class ChooseGoods implements State &#123; VendingMachine machine; public ChooseGoods(VendingMachine machine) &#123; this.machine = machine; &#125; @Override public void choose() &#123; if (machine.getCount() &gt; 0) &#123; System.out.println(&quot;商品挑选成功，请及时付款！&quot;); machine.setState(machine.getPaymentState()); &#125; else &#123; System.out.println(&quot;很遗憾，商品售罄了！&quot;); machine.setState(machine.getEmptyState()); &#125; &#125; @Override public boolean payment() &#123; System.out.println(&quot;请先挑选商品！&quot;); return false; &#125; @Override public void dispenseCommodity() &#123; System.out.println(&quot;请先挑选商品！&quot;); &#125;&#125; 付款状态类12345678910111213141516171819202122232425262728293031public class PaymentState implements State &#123; VendingMachine machine; public PaymentState(VendingMachine machine) &#123; this.machine = machine; &#125; @Override public void choose() &#123; System.out.println(&quot;商品已选购完成请勿重复挑选&quot;); &#125; @Override public boolean payment() &#123; Random random = new Random(); int num = random.nextInt(10); if(num % 2 == 0)&#123; System.out.println(&quot;付款成功！&quot;); machine.setState(machine.getDispenseCommodityState()); return true; &#125; System.out.println(&quot;付款失败，请重新支付！&quot;); return false; &#125; @Override public void dispenseCommodity() &#123; System.out.println(&quot;请先完成支付！&quot;); &#125;&#125; 商品售罄状态类123456789101112131415161718192021222324public class EmptyState implements State &#123; VendingMachine machine; public EmptyState(VendingMachine machine) &#123; this.machine = machine; &#125; @Override public void choose() &#123; System.out.println(&quot;对不起商品已售罄！&quot;); &#125; @Override public boolean payment() &#123; System.out.println(&quot;对不起商品已售罄！&quot;); return false; &#125; @Override public void dispenseCommodity() &#123; System.out.println(&quot;对不起商品已售罄！&quot;); &#125;&#125; 分发商品状态类12345678910111213141516171819202122232425public class DispenseCommodityState implements State &#123; VendingMachine machine; public DispenseCommodityState(VendingMachine machine) &#123; this.machine = machine; &#125; @Override public void choose() &#123; System.out.println(&quot;请及时取走您的商品！&quot;); &#125; @Override public boolean payment() &#123; System.out.println(&quot;请及时取走您的商品！&quot;); return false; &#125; @Override public void dispenseCommodity() &#123; System.out.println(&quot;请及时取走您的商品！&quot;); machine.setState(machine.getChooseGoods()); &#125;&#125; 自动售货机 &#x3D;&gt; Context角色123456789101112131415161718192021222324252627282930313233public class VendingMachine &#123; // 表示当前状态 private State state = null; // 商品数量 private int count = 0; private State chooseGoods = new ChooseGoods(this); private State paymentState = new PaymentState(this); private State dispenseCommodityState = new DispenseCommodityState(this); private State emptyState = new EmptyState(this); public VendingMachine(int count) &#123; this.count = count; this.state = this.getChooseGoods(); &#125; // 购买商品 public void purchase() &#123; // 挑选商品 state.choose(); // 支付成功 if (state.payment()) &#123; // 分发商品 state.dispenseCommodity(); &#125; &#125; // 获取商品后将商品减一 public int getCount() &#123; return count--; &#125; // get和set方法 ... &#125; 客户端测试类12345678910public class Client &#123; public static void main(String[] args) &#123; VendingMachine machine = new VendingMachine(1); for (int i = 1; i &lt; 4; i++) &#123; System.out.println(&quot;第&quot; + i + &quot;次购买。&quot;); machine.purchase(); &#125; &#125;&#125; 执行结果总结1、状态模式将每个状态所对应的行为封装到一个类中，大大提高了代码的可读性。并且通过这样的设计还可以消除多余的if-else语句，方便代码的维护。 2、状态模式符合“开闭原则”，容易增加和删除状态。 3、任何事情都有利弊，状态模式也不例外。其最显著的问题是，每个状态都要对应一个类，当状态过多时会产生大量的类，从而加大维护成本。 4、应用场景：当一个需求有很多状态，并且状态之间会进行转换，不同状态还对应不同的行为时就可以考虑使用“状态模式”。","tags":["设计模式"],"categories":["设计模式"]},{"title":"Google 开源的 Guava 工具库","path":"/2023/12/24/Google-开源的-Guava-工具库/","content":"目前Google Guava在实际应用中非常广泛，本篇博客将以博主对Guava使用的认识以及在项目中的经验来给大家分享！正如标题所言，学习使用Google Guava可以让你快乐编程，写出优雅的JAVA代码！ 以面向对象思想处理字符串:Joiner&#x2F;Splitter&#x2F;CharMatcher JDK提供的String还不够好么？ 也许还不够友好，至少让我们用起来还不够爽，还得操心！ 举个栗子，比如String提供的split方法，我们得关心空字符串吧，还得考虑返回的结果中存在null元素吧，只提供了前后trim的方法（如果我想对中间元素进行trim呢）。 那么，看下面的代码示例，guava让你不必在操心这些： 123456789101112131415// 连接器private static final Joiner joiner = Joiner.on(&quot;,&quot;).skipNulls();// 分割器private static final Splitter splitter = Splitter.on(&quot;,&quot;).trimResults().omitEmptyStrings();public static void main(String[] args) &#123; // 把集合/数组中的元素 join 在一起 String join = joiner.join(Lists.newArrayList(&quot;a&quot;, null, &quot;b&quot;)); System.out.println(&quot;join=&quot; + join); for(String tmp : splitter.split(&quot;a, ,b,,&quot;)) &#123; System.out.println(&quot;|&quot; + tmp + &quot;|&quot;); &#125;&#125; Joiner&#x2F;Splitter Joiner是连接器，Splitter是分割器，通常我们会把它们定义为static final，利用on生成对象后在应用到String进行处理，这是可以复用的。要知道apache commons StringUtils提供的都是static method。 更加重要的是，guava提供的Joiner&#x2F;Splitter是经过充分测试，它的稳定性和效率要比apache高出不少，这个你可以自行测试下~ 发现没有我们想对String做什么操作，就是生成自己定制化的Joiner&#x2F;Splitter，多么直白，简单，流畅的API！ 对于Joiner，常用的方法是 跳过NULL元素：skipNulls() &#x2F; 对于NULL元素使用其他替代：useForNull(String) 对于Splitter，常用的方法是：trimResults()&#x2F;omitEmptyStrings()。注意拆分的方式，有字符串，还有正则，还有固定长度分割（太贴心了！） 其实除了Joiner&#x2F;Splitter外，guava还提供了字符串匹配器：CharMatcher 123456789101112private static final CharMatcher charMatcherDigit = CharMatcher.DIGIT;private static final Charmatcher charMatcherAny = CharMatcher.ANY;public static void main(String[] args) &#123; // 只保留匹配的字符，其他移除 System.out.println(charMatcherDigit.retainFrom(&quot;abc2def134f~&quot;)); // 移除匹配的字符 System.out.println(charMatcherDigit.removeFrom(&quot;yes,i love you 1314&quot;)); System.out.println(charMatcherAny.inRange(&#x27;a&#x27;, &#x27;f&#x27;).or(charMatcherAny.is(&#x27;a&#x27;)).replaceFrom(&quot;abcdefg&quot;,&quot;*&quot;));&#125; CharMatcher CharMatcher，将字符的匹配和处理解耦，并提供丰富的方法供你使用！ 对基本类型进行支持 guava对JDK提供的原生类型操作进行了扩展，使得功能更加强大！ 1234567891011121314151617// 快速完成到集合的转换List&lt;Integer&gt; list = Ints.asList(1, 3, 5, 7, 9);System.out.println(Ints.join(&quot;,&quot;, 1, 3, 1, 4));// 原生类型数据快速合并int[] newIntArray = Ints.concat(new int[]&#123;1, 2&#125;, new int[]&#123;2, 3, 4&#125;);System.out.println(newIntArray.length);// 最大/最小System.out.println(Ints.max(newIntArray) + &quot;,&quot; + Ints.min(newIntArray));// 是否包含System.out.println(Ints.contains(newArray, 6));// 集合到数组的转换int[] someArray = Ints.toArray(list); Ints guava提供了 Bytes&#x2F;Shorts&#x2F;Ints&#x2F;Iongs&#x2F;Floats&#x2F;Doubles&#x2F;Chars&#x2F;Booleans 这些基本数据类型的扩展支持，只有你想不到的，没有它没有的！ 对JDK集合的有效补充灰色地带:Multiset JDK的集合，提供了有序且可以重复的List，无序且不可以重复的Set。那这里其实对于集合涉及到了2个概念，一个order，一个dups。那么List vs Set，and then some ? Multiset Multiset是什么，我想上面的图，你应该了解它的概念了。Multiset就是无序的，但是可以重复的集合，它就是游离在List&#x2F;Set之间的“灰色地带”！（至于有序的，不允许重复的集合嘛，guava还没有提供，当然在未来应该会提供UniqueList，我猜的，哈哈） 来看一个Multiset的示例： 12345678910Multiset&lt;String&gt; multiset = HashMultiset.create();multiset.add(&quot;a&quot;);multiset.add(&quot;a&quot;);multiset.add(&quot;b&quot;);multiset.add(&quot;c&quot;);multiset.add(&quot;b&quot;);System.out.println(multiset.size());System.out.println(multiset.count(&quot;a&quot;)); Multiset Code Multiset自带一个有用的功能，就是可以跟踪每个对象的数量。 Immutable vs unmodifiable来我们先看一个unmodifiable的例子： 1234567891011121314// List 的不可变设置List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);// 这种视图，不够安全，不是真正意义上的快照，怎么能随着而变化呢？List&lt;String&gt; readOnlyList = Collections.unmodifiableList(list);// readOnlyList.add(&quot;c&quot;);// 抛异常：java.lang.UnsupportedOperationExceptionlist.acc(&quot;c&quot;);System.out.println(reaOnlyList.size()); // 3 unmodifiable 你看到JDK提供的unmodifiable的缺陷了吗？ 实际上，Collections.unmodifiableXxx所返回的集合和源集合是同一个对象，只不过可以对集合做出改变的API都被override，会抛出UnsupportedOperationException。 也即是说我们改变源集合，导致不可变视图（unmodifiable View）也会发生变化，oh my god! 当然，在不使用guava的情况下，我们是怎么避免上面的问题的呢？ 1234567// List 的不可变性设置List&lt;String&gt; list = new ArrayList&lt;~&gt;();list.add(&quot;a&quot;);list.add(&quot;b&quot;);// new Object ; CopyList&lt;String&gt; readOnList = Collections.unmodifiableList(new ArrayList&lt;String&gt;(list)); defensive copies 上面揭示了一个概念：Defensive Copies，保护性拷贝。 OK，unmodifiable看上去没有问题呢，但是guava依然觉得可以改进，于是提出了Immutable的概念，来看： 12345678910// guava 是如何做的呢？List&lt;String&gt; immutable = ImmutabeList.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// immutable.add(&quot;d&quot;);// 抛异常：java.lang.UnsupportedOperationExceptionList&lt;String&gt; immutable2 = ImmutableList.copyOf(list);list.add(&quot;d&quot;);// 视图不随着源而改变 guava 只读设置安全可靠 简单易用System.out.println(&quot;list size:&quot; + list.size() + &quot; immutable2.size:&quot; + immutables.size()); Immutable 就一个copyOf，你不会忘记，如此cheap~ 用Google官方的说法是：we’re using just one class,just say exactly what we mean，很了不起吗（不仅仅是个概念，Immutable在COPY阶段还考虑了线程的并发性等，很智能的！），O(∩_∩)O哈哈~ guava提供了很多Immutable集合，比如 ImmutableList&#x2F;ImmutableSet&#x2F;ImmutableSortedSet&#x2F;ImmutableMap&#x2F;…… 看一个ImmutableMap的例子： 123ImmutableMap&lt;String, String&gt; immutableMap = ImmutableMap.of(&quot;name&quot;, &quot;hubert&quot;, &quot;sex&quot;, &quot;man&quot;);immutableMap.put(&quot;wife&quot;, &quot;no...&quot;); // UnsupportedOperationException ImmutableMap 可不可以一对多：Multimap JDK提供给我们的Map是一个键，一个值，一对一的，那么在实际开发中，显然存在一个KEY多个VALUE的情况（比如一个分类下的书本），我们往往这样表达：Map&lt;k,List&lt;v&gt;&gt;，好像有点臃肿！臃肿也就算了，更加不爽的事，我们还得判断KEY是否存在来决定是否new 一个LIST出来，有点麻烦！更加麻烦的事情还在后头，比如遍历，比如删除，so hard…… 来看guava如何替你解决这个大麻烦的： 1234567Multimap&lt;String, String&gt; multiMap = ArrayListMultimap.create();multiMap.put(&quot;hubert&quot;, &quot;man&quot;);multiMap.put(&quot;hubert&quot;, &quot;yes&quot;);multiMap.put(&quot;lucy&quot;, &quot;woman&quot;);System.out.println(multiMap.get(&quot;hubert&quot;)); //collection Multimap 友情提示下，guava所有的集合都有create方法，这样的好处在于简单，而且我们不必在重复泛型信息了。 get()&#x2F;keys()&#x2F;keySet()&#x2F;values()&#x2F;entries()&#x2F;asMap()都是非常有用的返回view collection的方法。 Multimap的实现类有： ArrayListMultimap&#x2F;HashMultimap&#x2F;LinkedHashMultimap&#x2F;TreeMultimap&#x2F;ImmutableMultimap&#x2F;…… 可不可以双向：BiMap JDK提供的MAP让我们可以find value by key，那么能不能通过find key by value呢，能不能KEY和VALUE都是唯一的呢。这是一个双向的概念，即forward+backward。 在实际场景中有这样的需求吗？比如通过用户ID找到mail，也需要通过mail找回用户名。没有guava的时候，我们需要create forward map AND create backward map，and now just let guava do that for you. 12345678910111213BiMap&lt;String, String&gt; biMap = HashBiMap.create();biMap.put(&quot;name&quot;, &quot;hubert&quot;);// java.lang.IllegaArgumentException: value already present: hubert// value 重复会报错biMap.put(&quot;nick&quot;, &quot;hubert&quot;);// 强制覆盖 name:hubertbiMap.forcePut(&quot;nick&quot;, &quot;hubert&quot;);biMap.put(&quot;123&quot;, &quot;hubertwongcn@163.com&quot;);System.out.println(biMap.inverse().get(&quot;hubertwongcn@163.com&quot;)); // 123 BiMap biMap &#x2F; biMap.inverse() &#x2F; biMap.inverse().inverse() 它们是什么关系呢？ 你可以稍微看一下BiMap的源码实现，实际上，当你创建BiMap的时候，在内部维护了2个map，一个forward map，一个backward map，并且设置了它们之间的关系。 因此，biMap.inverse() !&#x3D; biMap ；biMap.inverse().inverse() &#x3D;&#x3D; biMap 可不可以多个KEY：Table 我们知道数据库除了主键外，还提供了复合索引，而且实际中这样的多级关系查找也是比较多的，当然我们可以利用嵌套的Map来实现：Map&lt;k1,Map&lt;k2,v2&gt;&gt;。为了让我们的代码看起来不那么丑陋，guava为我们提供了Table。 1234567Table&lt;String, String, Integer&gt; table = HashBaseTable.create();table.put(&quot;张三&quot;, &quot;计算机&quot;, 80);table.put(&quot;张三&quot;, &quot;数学&quot;, 90);table.put(&quot;张三&quot;, &quot;语文&quot;, 70);table.put(&quot;李四&quot;, &quot;计算机&quot;, 70);table.put(&quot;李四&quot;, &quot;数学&quot;, 60);table.put(&quot;李四&quot;, &quot;语文&quot;, 100); Table Table涉及到3个概念：rowKey,columnKey,value，并提供了多种视图以及操作方法让你更加轻松的处理多个KEY的场景。 函数式编程：Functions12345678910111213141516171819202122List&lt;String&gt; list = Lists.newArrayList(&quot;hello world&quot;, &quot;yes&quot;, &quot;hubert&quot;);Function&lt;String, String&gt; f1 = new Function&lt;String, String&gt;() &#123; @Override public String apply(String s) &#123; return s.length() &lt;= 5 ? s : s.substring(0, 5); &#125;&#125;;Function&lt;String, String&gt; f2 = new Function&lt;String, String&gt;() &#123; @Override public String apply(String s) &#123; return s.toUpperCase(); &#125;&#125;;Function&lt;String, String&gt; f3 = Functions.compose(f1, f2);Collection&lt;String&gt; collection = Collections2.transform(list, f3);for(String s : collection) &#123; System.out.println(s);&#125; Functions 上面的代码是为了完成将List集合中的元素，先截取5个长度，然后转成大写。 函数式编程的好处在于在集合遍历操作中提供自定义Function的操作，比如transform转换。我们再也不需要一遍遍的遍历集合，显著的简化了代码！ 12345678910Iterables.transform(Iterable, Function);Iterators.transform(Iterator, Function);Collections2.transform(Collection, Function);Lists.transform(List, Function);Maps.transformValues(Map, Function);Multimaps.transformValues(Multimap, Function);Multimaps.transformValues(ListMultimap, Funtion);Tables.transformValues(Table, Function);Maps.transformEntries(Map, EntryTransformer);// ... 对集合的transform操作可以通过Function完成 断言：Predicate12345678910111213List&lt;String&gt; list = Lists.newArrayList(&quot;moom&quot;, &quot;dad&quot;, &quot;refer&quot;, &quot;yes&quot;);Collection&lt;String&gt; collection = Collections2.filter(list, new Predicate&lt;String&gt;)) &#123; @Override public boolean apply(String s) &#123; // 业务逻辑 return new StringBuilder(s).reverse().toString().equals(s); &#125;&#125;;for(String s : collection) &#123; System.out.println(s);&#125; Predicate最常用的功能就是运用在集合的过滤当中！ 12345678Iterables.filter(Iterable, Predicate);Iterators.filter(Iterator, Predicate);Collectios2.filter(Collection, Predicate);Sets.filter(Set, Predicate);Sets.filter(SortedSet, Predicate);Maps.filterKeys(Map, Predicate);Multimaps.filterKeys(Multimap, Predicate);// ... filter 需要注意的是Lists并没有提供filter方法，不过你可以使用Collections2.filter完成！ check null and other：Optional、Preconditions在guava中，对于null的处理手段是快速失败，你可以看看guava的源码，很多方法的第一行就是：Preconditions.checkNotNull(elements); 要知道null是模糊的概念，是成功呢，还是失败呢，还是别的什么含义呢？ 12345678910111213public static void test(String name, int age, Map&lt;String, String&gt; extInfo) &#123; Preconditions.checkNotNull(name, &quot;name must be given!&quot;); Preconditions.checkArgument(age &gt;= 18, &quot;the game you can not play it, your age is under 18!&quot;); Map&lt;String, String&gt; defaulExtInfo = Maps.newHashMap(); defaultExtInfo.put(&quot;sex&quot;, &quot;man&quot;); extInfo = Optional.fromNullable(extInfo).or(defaultExtInfo); for(Map.Entry&lt;String, Stirng&gt; entry : extInfo.entrySet())) &#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); &#125;&#125; Preconditions&#x2F;Optional Cache is king 对于大多数互联网项目而言，缓存的重要性，不言而喻！ 如果我们的应用系统，并不想使用一些第三方缓存组件（如redis），我们仅仅想在本地有一个功能足够强大的缓存，很可惜JDK提供的那些SET&#x2F;MAP还不行！ 12345678910111213141516171819202122232425// 定义缓存的实现private static final CacheLoader&lt;Long, User&gt; userCacheLoader = new CacheLoader&lt;Long, User&gt;() &#123; @Override public User load(Long along) throws Exception &#123; // 模拟从数据库/Redis/缓存中加载数据 User user = new User(); user.setId(along); user.setName(Thread.currentThread().getName() + &quot;-&quot; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;).format(new Date()) + &quot;-&quot; + along); System.out.println(&quot;load:&quot; + user); return user; &#125;&#125;;// 定义缓存的策略，提供对外访问缓存private static final LoadingCache&lt;Long, User&gt; userCacheData = CacheBuilder.newBuilder() .expireAfterAccess(2, TimeUnit.SECONDS) .expireAfterWrite(2, TimeUnit.SECONDS) .refreshAfterWrite(3, TimeUnit.SECONS) .maximumSize(10000L) .bulid(userCacheLoader); CacheLoader 首先，这是一个本地缓存，guava提供的cache是一个简洁、高效，易于维护的。为什么这么说呢？因为并没有一个单独的线程用于刷新 OR 清理cache，对于cache的操作，都是通过访问&#x2F;读写带来的，也就是说在读写中完成缓存的刷新操作！ 其次，我们看到了，我们非常通俗的告诉cache，我们的缓存策略是什么，SO EASY！在如此简单的背后，是guava帮助我们做了很多事情，比如线程安全。 让异步回调更加简单 JDK中提供了Future&#x2F;FutureTask&#x2F;Callable来对异步回调进行支持，但是还是看上去挺复杂的，能不能更加简单呢？比如注册一个监听回调。 12345678910111213141516171819202122232425262728// JDK 所提供的线程池ExecutorService es = Executors.newFixedThreadPool(3);// 经过guava封装的带有监听回调功能的线程池ListeningExecutorService listeningExecutorService = MoreExecutors.listeningDecorator(es);ListenableFuture listenableFuture = listeningExecutorService.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; if (new Random().nextInt(3) == 2) &#123; throw new NullPointerException(); &#125; return 1; &#125;&#125;);FutureCallback futureCallback = new FutureCallback&lt;Integer&gt; &#123; @Override public void onSuccess(final Integer o) &#123; System.out.println(&quot;------&quot; + o); &#125; @Override public void onFailure(final Throwable throwable) &#123; System.out.println(&quot;======&quot; + throwable.getMessage()); &#125;&#125;;Futures.addCallback(listenableFuture, futureCallback); 异步回调 我们可以通过guava对JDK提供的线程池进行装饰，让其具有异步回调监听功能，然后在设置监听器即可！ Summary到这里，这篇文章也只介绍了guava的冰山一角，其实还有很多内容： guava package 比如反射、注解、网络、并发、IO等等","tags":["工具","开源","Google"],"categories":["工具"]}]