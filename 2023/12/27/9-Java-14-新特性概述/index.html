<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.0.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.21.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>9.Java 14 新特性概述 - Hubert's Blog</title>

  
    <meta name="description" content="Java 14 已如期于 2020 年 3 月 17 日正式发布，此次更新是继半年前 Java 13 这大版本发布之后的又一次常规版本更新，即便在全球疫情如此严峻形势下，依然保持每六个月的版本更新频率，为大家及时带来改进和增强，这一点值得点赞。在这一版中，主要带来了 ZGC 增强、instanceof 增强、Switch 表达式更新为标准版等方面的改动、增强和新功能。本文主要介绍 Java 14">
<meta property="og:type" content="article">
<meta property="og:title" content="9.Java 14 新特性概述">
<meta property="og:url" content="https://hubertwongcn.github.io/2023/12/27/9-Java-14-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/index.html">
<meta property="og:site_name" content="Hubert&#39;s Blog">
<meta property="og:description" content="Java 14 已如期于 2020 年 3 月 17 日正式发布，此次更新是继半年前 Java 13 这大版本发布之后的又一次常规版本更新，即便在全球疫情如此严峻形势下，依然保持每六个月的版本更新频率，为大家及时带来改进和增强，这一点值得点赞。在这一版中，主要带来了 ZGC 增强、instanceof 增强、Switch 表达式更新为标准版等方面的改动、增强和新功能。本文主要介绍 Java 14">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312271221180.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312271225219.png">
<meta property="article:published_time" content="2023-12-27T04:20:12.000Z">
<meta property="article:modified_time" content="2023-12-27T04:20:12.000Z">
<meta property="article:author" content="Hubert Wong">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="新特性">
<meta property="article:tag" content="Java14">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312271221180.png">
  
  
  
  <meta name="keywords" content="Java,新特性,Java14">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">Hubert's Blog</div><div class="sub cap"> Hubert爱猫爱生活</div></a></div>

<nav class="menu dis-select"></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">9.Java 14 新特性概述</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB"><span class="toc-text">知识体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="toc-text">语言特性增强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-359-Switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E6%AD%A3%E5%BC%8F%E7%89%88%EF%BC%89"><span class="toc-text">JEP 359: Switch 表达式（正式版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E5%BA%93%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-text">新功能和库的更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-358-%E6%94%B9%E8%BF%9B-NullPointerExceptions-%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">JEP 358: 改进 NullPointerExceptions 提示信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A7%E5%8A%9F%E8%83%BD%E7%9A%84%E5%88%A0%E9%99%A4%E5%92%8C%E5%BC%83%E7%94%A8"><span class="toc-text">旧功能的删除和弃用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-367-%E5%88%A0%E9%99%A4-pack200-%E5%92%8C-unpack200-%E5%B7%A5%E5%85%B7"><span class="toc-text">JEP 367: 删除 pack200 和 unpack200 工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E7%9B%B8%E5%85%B3"><span class="toc-text">JVM 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-345-G1-%E7%9A%84-NUMA-%E5%8F%AF%E8%AF%86%E5%88%AB%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">JEP 345: G1 的 NUMA 可识别内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-363-%E5%88%A0%E9%99%A4-CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-text">JEP 363: 删除 CMS 垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-364-365-ZGC-%E6%94%AF%E6%8C%81-MacOS-%E5%92%8C-Windows-%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%AE%9E%E9%AA%8C%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">JEP 364&amp;365: ZGC 支持 MacOS 和 Windows 系统（实验阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-366-%E5%BC%83%E7%94%A8-ParallelScavenge-%E5%92%8C-SerialOld-GC-%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">JEP 366: 弃用 ParallelScavenge 和 SerialOld GC 的组合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E9%A2%84%E8%A7%88%E5%92%8C%E5%AE%9E%E9%AA%8C"><span class="toc-text">新功能的预览和实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-305-instanceof-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%88%E9%A2%84%E8%A7%88%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">JEP 305: instanceof 模式匹配（预览阶段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-359-Record-%E7%B1%BB%E5%9E%8B%EF%BC%88%E9%A2%84%E8%A7%88%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="toc-text">JEP 359: Record 类型（预览功能）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-368-%E6%96%87%E6%9C%AC%E5%9D%97%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%A2%84%E8%A7%88%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">JEP 368: 文本块（第二预览版本）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-343-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%EF%BC%88%E5%AD%B5%E5%8C%96%E5%99%A8%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-text">JEP 343: 打包工具（孵化器版本）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JEP-370-%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE-API%EF%BC%88%E5%AD%B5%E5%8C%96%E5%99%A8%E7%89%88%EF%BC%89"><span class="toc-text">JEP 370: 外部存储器访问 API（孵化器版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F%E8%AF%AD"><span class="toc-text">结束语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Java/%E6%96%B0%E7%89%B9%E6%80%A7/">新特性</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Java/%E6%96%B0%E7%89%B9%E6%80%A7/Java14/">Java14</a></div><div id="post-meta">
    <span>发布于&nbsp;<time datetime="2023-12-27T04:20:12.000Z">2023-12-27</time></span>
    
    <span>更新于&nbsp;<time datetime="2023-12-27T04:20:12.000Z">2023-12-27</time></span>
    </div></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>9.Java 14 新特性概述</span></h1>
<blockquote>
<p>Java 14 已如期于 2020 年 3 月 17 日正式发布，此次更新是继半年前 Java 13 这大版本发布之后的又一次常规版本更新，即便在全球疫情如此严峻形势下，依然保持每六个月的版本更新频率，为大家及时带来改进和增强，这一点值得点赞。在这一版中，主要带来了 ZGC 增强、instanceof 增强、Switch 表达式更新为标准版等方面的改动、增强和新功能。本文主要介绍 Java 14 中的主要新特性，带您快速了解 Java 14 带来了哪些不一样的体验和便利。</p>
</blockquote>
<h2 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h2><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312271221180.png"/></div></div>

<h2 id="语言特性增强"><a href="#语言特性增强" class="headerlink" title="语言特性增强"></a>语言特性增强</h2><h3 id="JEP-359-Switch-表达式（正式版）"><a href="#JEP-359-Switch-表达式（正式版）" class="headerlink" title="JEP 359: Switch 表达式（正式版）"></a>JEP 359: Switch 表达式（正式版）</h3><p>switch 表达式在之前的 Java 12 和 Java 13 中都是处于预览阶段，而在这次更新的 Java 14 中，终于成为稳定版本，能够正式可用。</p>
<p>switch 表达式带来的不仅仅是编码上的简洁、流畅，也精简了 switch 语句的使用方式，同时也兼容之前的 switch 语句的使用；之前使用 switch 语句时，在每个分支结束之前，往往都需要加上 break 关键字进行分支跳出，以防 switch 语句一直往后执行到整个 switch 语句结束，由此造成一些意想不到的问题。switch 语句一般使用冒号 ：来作为语句分支代码的开始，而 switch 表达式则提供了新的分支切换方式，即 -&gt; 符号右则表达式方法体在执行完分支方法之后，自动结束 switch 分支，同时 -&gt; 右则方法块中可以是表达式、代码块或者是手动抛出的异常。以往的 switch 语句写法如下：</p>
<p>清单 9. Switch 语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dayOfWeek;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">    <span class="keyword">case</span> FRIDAY:</span><br><span class="line">    <span class="keyword">case</span> SUNDAY:</span><br><span class="line">        dayOfWeek = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        dayOfWeek = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY:</span><br><span class="line">    <span class="keyword">case</span> SATURDAY:</span><br><span class="line">        dayOfWeek = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">        dayOfWeek = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        dayOfWeek = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而现在 Java 14 可以使用 switch 表达式正式版之后，上面语句可以转换为下列写法：</p>
<p>清单 10. Switch 表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">case</span> WEDNESDAY              -&gt; <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">default</span>              -&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显，switch 表达式将之前 switch 语句从编码方式上简化了不少，但是还是需要注意下面几点：</p>
<ul>
<li>需要保持与之前 switch 语句同样的 case 分支情况。</li>
<li>之前需要用变量来接收返回值，而现在直接使用 yield 关键字来返回 case 分支需要返回的结果。</li>
<li>现在的 switch 表达式中不再需要显式地使用 return、break 或者 continue 来跳出当前分支。</li>
<li>现在不需要像之前一样，在每个分支结束之前加上 break 关键字来结束当前分支，如果不加，则会默认往后执行，直到遇到 break 关键字或者整个 switch 语句结束，在 Java 14 表达式中，表达式默认执行完之后自动跳出，不会继续往后执行。</li>
<li>对于多个相同的 case 方法块，可以将 case 条件并列，而不需要像之前一样，通过每个 case 后面故意不加 break 关键字来使用相同方法块。</li>
</ul>
<p>使用 switch 表达式来替换之前的 switch 语句，确实精简了不少代码，提高了编码效率，同时也可以规避一些可能由于不太经意而出现的意想不到的情况，可见 Java 在提高使用者编码效率、编码体验和简化使用方面一直在不停的努力中，同时也期待未来有更多的类似 lambda、switch 表达式这样的新特性出来。</p>
<h2 id="新功能和库的更新"><a href="#新功能和库的更新" class="headerlink" title="新功能和库的更新"></a>新功能和库的更新</h2><h3 id="JEP-358-改进-NullPointerExceptions-提示信息"><a href="#JEP-358-改进-NullPointerExceptions-提示信息" class="headerlink" title="JEP 358: 改进 NullPointerExceptions 提示信息"></a>JEP 358: 改进 NullPointerExceptions 提示信息</h3><p>Java 14 改进 NullPointerException 的可查性、可读性，能更准确地定位 null 变量的信息。该特性能够帮助开发者和技术支持人员提高生产力，以及改进各种开发工具和调试工具的质量，能够更加准确、清楚地根据动态异常与程序代码相结合来理解程序。</p>
<p>相信每位开发者在实际编码过程中都遇到过 NullPointerException，每当遇到这种异常的时候，都需要根据打印出来的详细信息来分析、定位出现问题的原因，以在程序代码中规避或解决。例如，假设下面代码出现了一个 NullPointerException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.id = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>

<p>打印出来的 NullPointerException 信息如下：</p>
<p>清单 4. NullPointerException 信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">    at Book.main(Book.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>像上面这种异常，因为代码比较简单，并且异常信息中也打印出来了行号信息，开发者可以很快速定位到出现异常位置：book 为空而导致的 NullPointerException，而对于一些复杂或者嵌套的情况下出现 NullPointerException 时，仅根据打印出来的信息，很难判断实际出现问题的位置，具体见下面示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shoopingcart.buy.book.id = <span class="number">99</span>;</span><br></pre></td></tr></table></figure>

<p>对于这种比较复杂的情况下，仅仅单根据异常信息中打印的行号，则比较难判断出现 NullPointerException 的原因。</p>
<p>而 Java 14 中，则做了对 NullPointerException 打印异常信息的改进增强，通过分析程序的字节码信息，能够做到准确的定位到出现 NullPointerException 的变量，并且根据实际源代码打印出详细异常信息，对于上述示例，打印信息如下：</p>
<p>清单 5. NullPointerException 详细信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException: </span><br><span class="line">        Cannot assign field <span class="string">&quot;book&quot;</span> because <span class="string">&quot;shoopingcart.buy&quot;</span> is <span class="literal">null</span></span><br><span class="line">    at Book.main(Book.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>对比可以看出，改进之后的 NullPointerException 信息，能够准确打印出具体哪个变量导致的 NullPointerException，减少了由于仅带行号的异常提示信息带来的困惑。该改进功能可以通过如下参数开启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ShowCodeDetailsInExceptionMessages</span><br></pre></td></tr></table></figure>

<p>该增强改进特性，不仅适用于属性访问，还适用于方法调用、数组访问和赋值等有可能会导致 NullPointerException 的地方。</p>
<h2 id="旧功能的删除和弃用"><a href="#旧功能的删除和弃用" class="headerlink" title="旧功能的删除和弃用"></a>旧功能的删除和弃用</h2><h3 id="JEP-367-删除-pack200-和-unpack200-工具"><a href="#JEP-367-删除-pack200-和-unpack200-工具" class="headerlink" title="JEP 367: 删除 pack200 和 unpack200 工具"></a>JEP 367: 删除 pack200 和 unpack200 工具</h3><p>删除 pack200 和 unpack200 工具，以及 java.util.jar 包中的 Pack200 API。这些工具和 API 在 Java SE 11 中已被弃用，以便在未来的版本中删除它们。</p>
<h2 id="JVM-相关"><a href="#JVM-相关" class="headerlink" title="JVM 相关"></a>JVM 相关</h2><h3 id="JEP-345-G1-的-NUMA-可识别内存分配"><a href="#JEP-345-G1-的-NUMA-可识别内存分配" class="headerlink" title="JEP 345: G1 的 NUMA 可识别内存分配"></a>JEP 345: G1 的 NUMA 可识别内存分配</h3><p>Java 14 改进非一致性内存访问（NUMA）系统上的 G1 垃圾收集器的整体性能，主要是对年轻代的内存分配进行优化，从而提高 CPU 计算过程中内存访问速度。</p>
<p>NUMA 是 <strong>non-unified memory access</strong> 的缩写，主要是指在当前的多插槽物理计算机体系中，比较普遍是多核的处理器，并且越来越多的具有 NUMA 内存访问体系结构，即内存与每个插槽或内核之间的距离并不相等。同时套接字之间的内存访问具有不同的性能特征，对更远的套接字的访问通常具有更多的时间消耗。这样每个核对于每一块或者某一区域的内存访问速度会随着核和物理内存所在的位置的远近而有不同的时延差异。</p>
<p>Java 中，堆内存分配一般发生在线程运行的时候，当创建了一个新对象时，该线程会触发 G1 去分配一块内存出来，用来存放新创建的对象，在 G1 内存体系中，其实就是一块 region（大对象除外，大对象需要多个 region），在这个分配新内存的过程中，如果支持了 NUMA 感知内存分配，将会优先在与当前线程所绑定的 NUMA 节点空闲内存区域来执行 allocate 操作，同一线程创建的对象，尽可能的保留在年轻代的同一 NUMA 内存节点上，因为是基于同一个线程创建的对象大部分是短存活并且高概率互相调用的。</p>
<p>具体启用方式可以在 JVM 参数后面加上如下参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseNUMA</span><br></pre></td></tr></table></figure>

<p>通过这种方式来启用可识别的内存分配方式，能够提高一些大型计算机的 G1 内存分配回收性能。</p>
<h3 id="JEP-363-删除-CMS-垃圾回收器"><a href="#JEP-363-删除-CMS-垃圾回收器" class="headerlink" title="JEP 363: 删除 CMS 垃圾回收器"></a>JEP 363: 删除 CMS 垃圾回收器</h3><p>CMS 是老年代垃圾回收算法，通过标记-清除的方式进行内存回收，在内存回收过程中能够与用户线程并行执行。CMS 回收器可以与 Serial 回收器和 Parallel New 回收器搭配使用，CMS 主要通过并发的方式，适当减少系统的吞吐量以达到追求响应速度的目的，比较适合在追求 GC 速度的服务器上使用。</p>
<p>因为 CMS 回收算法在进行 GC 回收内存过程中是使用并行方式进行的，如果服务器 CPU 核数不多的情况下，进行 CMS 垃圾回收有可能造成比较高的负载。同时在 CMS 并行标记和并行清理时，应用线程还在继续运行，程序在运行过程中自然会创建新对象、释放不用对象，所以在这个过程中，会有新的不可达内存地址产生，而这部分的不可达内存是出现在标记过程结束之后，本轮 CMS 回收无法在周期内将它们回收掉，只能留在下次垃圾回收周期再清理掉。这样的垃圾就叫做浮动垃圾。由于垃圾收集和用户线程是并发执行的，因此 CMS 回收器不能像其他回收器那样进行内存回收，需要预留一些空间用来保存用户新创建的对象。由于 CMS 回收器在老年代中使用标记-清除的内存回收策略，势必会产生内存碎片，内存当碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有空间但不能再保存对象的情况。</p>
<p>所以，早在几年前的 Java 9 中，就已经决定放弃使用 CMS 回收器了，而这次在 Java 14 中，是继之前 Java 9 中放弃使用 CMS 之后，彻底将其禁用，并删除与 CMS 有关的选项，同时清除与 CMS 有关的文档内容，至此曾经辉煌一度的 CMS 回收器，也将成为历史。</p>
<p>当在 Java 14 版本中，通过使用参数： <code>-XX:+UseConcMarkSweepGC</code>，尝试使用 CMS 时，将会收到下面信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> <span class="number">64</span>-Bit Server VM warning: Ignoring option UseConcMarkSweepGC; \</span><br><span class="line">support was removed in &lt;version&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JEP-364-365-ZGC-支持-MacOS-和-Windows-系统（实验阶段）"><a href="#JEP-364-365-ZGC-支持-MacOS-和-Windows-系统（实验阶段）" class="headerlink" title="JEP 364&amp;365: ZGC 支持 MacOS 和 Windows 系统（实验阶段）"></a>JEP 364&amp;365: ZGC 支持 MacOS 和 Windows 系统（实验阶段）</h3><p>ZGC 是最初在 Java 11 中引入，同时在后续几个版本中，不断进行改进的一款基于内存 Region，同时使用了内存读屏障、染色指针和内存多重映射等技，并且以可伸缩、低延迟为目标的内存垃圾回收器器，不过在 Java 14 之前版本中，仅仅只支持在 Linux&#x2F;x64 位平台。</p>
<p>此次 Java 14，同时支持 MacOS 和 Windows 系统，解决了开发人员需要在桌面操作系统中使用 ZGC 的问题。</p>
<p>在 MacOS 和 Windows 下面开启 ZGC 的方式，需要添加如下 JVM 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure>

<h3 id="JEP-366-弃用-ParallelScavenge-和-SerialOld-GC-的组合使用"><a href="#JEP-366-弃用-ParallelScavenge-和-SerialOld-GC-的组合使用" class="headerlink" title="JEP 366: 弃用 ParallelScavenge 和 SerialOld GC 的组合使用"></a>JEP 366: 弃用 ParallelScavenge 和 SerialOld GC 的组合使用</h3><p>由于 Parallel Scavenge 和 Serial Old 垃圾收集算法组合起来使用的情况比较少，并且在年轻代中使用并行算法，而在老年代中使用串行算法，这种并行、串行混搭使用的情况，本身已属罕见同时也很冒险。由于这两 GC 算法组合很少使用，却要花费巨大工作量来进行维护，所以在 Java 14 版本中，考虑将这两 GC 的组合弃用。</p>
<p>具体弃用情况如下，通过弃用组合参数：<code>-XX:+UseParallelGC -XX:-UseParallelOldGC</code>，来弃用年轻代、老年期中并行、串行混搭使用的情况；同时，对于单独使用参数：<code>-XX:-UseParallelOldGC</code> 的地方，也将显示该参数已被弃用的警告信息。</p>
<h2 id="新功能的预览和实验"><a href="#新功能的预览和实验" class="headerlink" title="新功能的预览和实验"></a>新功能的预览和实验</h2><h3 id="JEP-305-instanceof-模式匹配（预览阶段）"><a href="#JEP-305-instanceof-模式匹配（预览阶段）" class="headerlink" title="JEP 305: instanceof 模式匹配（预览阶段）"></a>JEP 305: instanceof 模式匹配（预览阶段）</h3><p>Java 14 中对 instanceof 的改进，主要目的是为了让创建对象更简单、简洁和高效，并且可读性更强、提高安全性。</p>
<p>在以往实际使用中，instanceof 主要用来检查对象的类型，然后根据类型对目标对象进行类型转换，之后进行不同的处理、实现不同的逻辑，具体可以参考清单 1：</p>
<p>清单 1. instanceof 传统使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) person;</span><br><span class="line">    student.say();</span><br><span class="line">   <span class="comment">// other student operations</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Teacher) &#123;</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher) person;</span><br><span class="line">    teacher.say();</span><br><span class="line">    <span class="comment">// other teacher operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们首先需要对 person 对象进行类型判断，判断 person 具体是 Student 还是 Teacher，因为这两种角色对应不同操作，亦即对应到的实际逻辑实现，判断完 person 类型之后，然后强制对 person 进行类型转换为局部变量，以方便后续执行属于该角色的特定操作。</p>
<p>上面这种写法，有下面两个问题：</p>
<ul>
<li>每次在检查类型之后，都需要强制进行类型转换。</li>
<li>类型转换后，需要提前创建一个局部变量来接收转换后的结果，代码显得多余且繁琐。</li>
</ul>
<p>Java 14 中，对 instanceof 进行模式匹配改进之后，上面示例代码可以改写成：</p>
<p>清单 2. instanceof 模式匹配使用方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person <span class="keyword">instanceof</span> Student student) &#123;</span><br><span class="line">    student.say();</span><br><span class="line">   <span class="comment">// other student operations</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Teacher teacher) &#123;</span><br><span class="line">    teacher.say();</span><br><span class="line">    <span class="comment">// other teacher operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清单 2 中，首先在 if 代码块中，对 person 对象进行类型匹配，校验 person 对象是否为 Student 类型，如果类型匹配成功，则会转换为 Student 类型，并赋值给模式局部变量 student，并且只有当模式匹配表达式匹配成功是才会生效和复制，同时这里的 student 变量只能在 if 块中使用，而不能在 else if&#x2F;else 中使用，否则会报编译错误。</p>
<p>注意，如果 if 条件中有 &amp;&amp; 运算符时，当 instanceof 类型匹配成功，模式局部变量的作用范围也可以相应延长，如下面代码：</p>
<p>清单 3. Instanceof 模式匹配 &amp;&amp; 方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s &amp;&amp; s.length() &gt; <span class="number">5</span>) &#123;.. s.contains(..) ..&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意，这种作用范围延长，并不适用于或 || 运算符，因为即便 || 运算符左边的 instanceof 类型匹配没有成功也不会造成短路，依旧会执行到||运算符右边的表达式，但是此时，因为 instanceof 类型匹配没有成功，局部变量并未定义赋值，此时使用会产生问题。</p>
<p>与传统写法对比，可以发现模式匹配不但提高了程序的安全性、健壮性，另一方面，不需要显式的去进行二次类型转换，减少了大量不必要的强制类型转换。模式匹配变量在模式匹配成功之后，可以直接使用，同时它还被限制了作用范围，大大提高了程序的简洁性、可读性和安全性。instanceof 的模式匹配，为 Java 带来的有一次便捷的提升，能够剔除一些冗余的代码，写出更加简洁安全的代码，提高码代码效率。</p>
<h3 id="JEP-359-Record-类型（预览功能）"><a href="#JEP-359-Record-类型（预览功能）" class="headerlink" title="JEP 359: Record 类型（预览功能）"></a>JEP 359: Record 类型（预览功能）</h3><p>Java 14 富有建设性地将 Record 类型作为预览特性而引入。Record 类型允许在代码中使用紧凑的语法形式来声明类，而这些类能够作为不可变数据类型的封装持有者。Record 这一特性主要用在特定领域的类上；与枚举类型一样，Record 类型是一种受限形式的类型，主要用于存储、保存数据，并且没有其它额外自定义行为的场景下。</p>
<p>在以往开发过程中，被当作数据载体的类对象，在正确声明定义过程中，通常需要编写大量的无实际业务、重复性质的代码，其中包括：构造函数、属性调用、访问以及 equals() 、hashCode()、toString() 等方法，因此在 Java 14 中引入了 Record 类型，其效果有些类似 Lombok 的 @Data 注解、Kotlin 中的 data class，但是又不尽完全相同，它们的共同点都是类的部分或者全部可以直接在类头中定义、描述，并且这个类只用于存储数据而已。对于 Record 类型，具体可以用下面代码来说明：</p>
<p>清单 6. Record 类型定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述代码进行编译，然后反编译之后可以看到如下结果：</p>
<p>清单 7. Record 类型反编译结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Record &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> java.lang.String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> java.lang.String age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(java.lang.String name, java.lang.String age)</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(java.lang.Object o)</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.String <span class="title function_">name</span><span class="params">()</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.lang.String <span class="title function_">age</span><span class="params">()</span> &#123; <span class="comment">/* compiled code */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据反编译结果，可以得出，当用 Record 来声明一个类时，该类将自动拥有下面特征：</p>
<ul>
<li>拥有一个构造方法</li>
<li>获取成员属性值的方法：name()、age()</li>
<li>hashCode() 方法和 euqals() 方法</li>
<li>toString() 方法</li>
<li>类对象和属性被 final 关键字修饰，不能被继承，类的示例属性也都被 final 修饰，不能再被赋值使用。</li>
<li>还可以在 Record 声明的类中定义静态属性、方法和示例方法。注意，不能在 Record 声明的类中定义示例字段，类也不能声明为抽象类等。</li>
</ul>
<p>可以看到，该预览特性提供了一种更为紧凑的语法来声明类，并且可以大幅减少定义类似数据类型时所需的重复性代码。</p>
<p>另外 Java 14 中为了引入 Record 这种新的类型，在 java.lang.Class 中引入了下面两个新方法：</p>
<p>清单 8. Record 新引入至 Class 中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RecordComponent[] getRecordComponents()</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isRecord</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>其中 getRecordComponents() 方法返回一组 java.lang.reflect.RecordComponent 对象组成的数组，java.lang.reflect.RecordComponent也是一个新引入类，该数组的元素与 Record 类中的组件相对应，其顺序与在记录声明中出现的顺序相同，可以从该数组中的每个 RecordComponent 中提取到组件信息，包括其名称、类型、泛型类型、注释及其访问方法。</p>
<p>而 isRecord() 方法，则返回所在类是否是 Record 类型，如果是，则返回 true。</p>
<h3 id="JEP-368-文本块（第二预览版本）"><a href="#JEP-368-文本块（第二预览版本）" class="headerlink" title="JEP 368: 文本块（第二预览版本）"></a>JEP 368: 文本块（第二预览版本）</h3><p>Java 13 引入了文本块来解决多行文本的问题，文本块主要以三重双引号开头，并以同样的以三重双引号结尾终止，它们之间的任何内容都被解释为文本块字符串的一部分，包括换行符，避免了对大多数转义序列的需要，并且它仍然是普通的 java.lang.String 对象，文本块可以在 Java 中能够使用字符串的任何地方进行使用，而与编译后的代码没有区别，还增强了 Java 程序中的字符串可读性。并且通过这种方式，可以更直观地表示字符串，可以支持跨越多行，而且不会出现转义的视觉混乱，将可以广泛提高 Java 类程序的可读性和可写性。</p>
<p>Java 14 在 Java 13 引入的文本块的基础之上，新加入了两个转义符，分别是：\ 和 \s，这两个转义符分别表达涵义如下：</p>
<ul>
<li><code>\</code>：行终止符，主要用于阻止插入换行符；</li>
<li><code>\s</code>：表示一个空格。可以用来避免末尾的白字符被去掉。</li>
</ul>
<p>在 Java 13 之前，多行字符串写法为：</p>
<p>清单 11. 多行字符串写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">literal</span> <span class="operator">=</span> <span class="string">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;elit, sed do eiusmod tempor incididunt ut labore &quot;</span> +</span><br><span class="line">                 <span class="string">&quot;et dolore magna aliqua.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在 Java 14 新引入两个转义符之后，上述内容可以写为：</p>
<p>清单 12. 多行文本块加上转义符的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              Lorem ipsum dolor sit amet, consectetur adipiscing \</span></span><br><span class="line"><span class="string">              elit, sed do eiusmod tempor incididunt ut labore \</span></span><br><span class="line"><span class="string">              et dolore magna aliqua.\</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>上述两种写法，text 实际还是只有一行内容。</p>
<p>对于转义符：<code>\s</code>，用法如下，能够保证下列文本每行正好都是六个字符长度：</p>
<p>清单 13. 多行文本块加上转义符的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">colors</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">             red  \s</span></span><br><span class="line"><span class="string">            green\s</span></span><br><span class="line"><span class="string">             blue \s</span></span><br><span class="line"><span class="string">             &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Java 14 带来的这两个转义符，能够简化跨多行字符串编码问题，通过转义符，能够避免对换行等特殊字符串进行转移，从而简化代码编写，同时也增强了使用 String 来表达 HTML、XML、SQL 或 JSON 等格式字符串的编码可读性，且易于维护。</p>
<p>同时 Java 14 还对 String 进行了方法扩展：</p>
<ul>
<li><code>stripIndent()</code> ：用于从文本块中去除空白字符</li>
<li><code>translateEscapes()</code>：用于翻译转义字符</li>
<li><code>formatted(Object... args)</code>：用于格式化</li>
</ul>
<h3 id="JEP-343-打包工具（孵化器版本）"><a href="#JEP-343-打包工具（孵化器版本）" class="headerlink" title="JEP 343: 打包工具（孵化器版本）"></a>JEP 343: 打包工具（孵化器版本）</h3><p>创建用于打包自包含 Java 应用程序的工具。</p>
<p>它基于 JavaFX javapackager 工具创建一个简单的打包工具，主要目标是：</p>
<ul>
<li>支持原生打包格式，为最终用户提供自然的安装体验。这些格式包括 Windows 上的 msi 和 exe，macOS 上的 pkg 和 dmg，以及 Linux 上的 deb 和 rpm。</li>
<li>允许在打包时指定启动时间参数。</li>
<li>可以从命令行直接调用，也可以通过 ToolProvider API 以编程方式调用。</li>
</ul>
<h3 id="JEP-370-外部存储器访问-API（孵化器版）"><a href="#JEP-370-外部存储器访问-API（孵化器版）" class="headerlink" title="JEP 370: 外部存储器访问 API（孵化器版）"></a>JEP 370: 外部存储器访问 API（孵化器版）</h3><blockquote>
<p>外存访问 API（二次孵化），可以允许 Java 应用程序安全有效地访问 Java 堆之外的外部内存。目的是引入一个 API，以允许 Java 程序安全、有效地访问 Java 堆之外的外部存储器。如本机、持久和托管堆。如下内容来源于<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/8304c894c4e38318d38ceb116%EF%BC%8C%E4%BD%9C%E8%80%85%E6%98%AF%E4%B9%9D%E5%8F%94">https://xie.infoq.cn/article/8304c894c4e38318d38ceb116，作者是九叔</a></p>
</blockquote>
<p>在实际的开发过程中，绝大多数的开发人员基本都不会直接与堆外内存打交道，但这并不代表你从未接触过堆外内存，像大家经常使用的诸如：RocketMQ、MapDB 等中间件产品底层实现都是基于堆外存储的，换句话说，我们几乎每天都在间接与堆外内存打交道。那么究竟为什么需要使用到堆外内存呢？简单来说，主要是出于以下 3 个方面的考虑：</p>
<ul>
<li>减少 GC 次数和降低 Stop-the-world 时间；</li>
<li>可以扩展和使用更大的内存空间；</li>
<li>可以省去物理内存和堆内存之间的数据复制步骤。</li>
</ul>
<p>在 Java14 之前，如果开发人员想要操作堆外内存，通常的做法就是使用 ByteBuffer 或者 Unsafe，甚至是 JNI 等方式，但无论使用哪一种方式，均<strong>无法同时有效解决安全性和高效性等 2 个问题</strong>，并且，堆外内存的释放也是一个令人头痛的问题。以 DirectByteBuffer 为例，该对象仅仅只是一个引用，其背后还关联着一大段堆外内存，由于 DirectByteBuffer 对象实例仍然是存储在堆空间内，只有当 DirectByteBuffer 对象被 GC 回收时，其背后的堆外内存才会被进一步释放。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312271225219.png"/></div></div>

<p>在此大家需要注意，程序中通过 ByteBuffer.allocateDirect()方法来申请物理内存资源所耗费的成本远远高于直接在 on-heap 中的操作，而且实际开发过程中还需要考虑数据结构如何设计、序列化&#x2F;反序列化如何支撑等诸多难题，所以与其使用语法层面的 API 倒不如直接使用 MapDB 等开源产品来得更实惠。</p>
<p>如今，在堆外内存领域，我们似乎又多了一个选择，<strong>从 Java14 开始，Java 的设计者们在语法层面为大家带来了崭新的 Memory Access API，极大程度上简化了开发难度，并得以有效的解决了安全性和高效性等 2 个核心问题</strong>。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取内存访问var句柄</span></span><br><span class="line"><span class="type">var</span> <span class="variable">handle</span> <span class="operator">=</span> MemoryHandles.varHandle(<span class="type">char</span>.class,</span><br><span class="line">        ByteOrder.nativeOrder());</span><br><span class="line"><span class="comment">// 申请200字节的堆外内存</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">MemorySegment</span> <span class="variable">segment</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">200</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">        handle.set(segment, i &lt;&lt; <span class="number">2</span>, (<span class="type">char</span>) (i + <span class="number">1</span> + <span class="number">64</span>));</span><br><span class="line">        System.out.println(handle.get(segment, i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于堆外内存段的释放，Memory Access API 提供有显式和隐式 2 种方式，开发人员除了可以在程序中通过 MemorySegment 的 close()方法来显式释放所申请的内存资源外，还可以注册 Cleaner 清理器来实现资源的隐式释放，后者会在 GC 确定目标内存段不再可访问时，释放与之关联的堆外内存资源。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>Java 在更新版本周期为每半年发布一次之后，目前来看，确实是严格保持每半年更新的节奏。Java 14 版本的发布带来了不少新特性、功能实用性的增强、性能提升和 GC 方面的改进尝试。本文仅针对其中对使用人员影响较大的以及其中主要的特性做了介绍，如有兴趣，您还可以自行下载相关代码，继续深入研究。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>本文转载自 <a target="_blank" rel="noopener" href="https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-14/">https://developer.ibm.com/zh/technologies/java/articles/the-new-features-of-java-14/</a></li>
</ul>



<div class="article-footer reveal fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/12/27/10-Java-15-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/">10.Java 15 新特性概述</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/12/27/8-Java-13-%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%BF%B0/">8.Java 13 新特性概述</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"></div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.21.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.21.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img, .gallery img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
