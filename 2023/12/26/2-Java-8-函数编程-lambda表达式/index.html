<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 7.0.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.21.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>2.Java 8 - 函数编程(lambda表达式) - Hubert's Blog</title>

  
    <meta name="description" content="我们关心的是如何写出好代码，而不是符合函数编程风格的代码。  简介 在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。   这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来">
<meta property="og:type" content="article">
<meta property="og:title" content="2.Java 8 - 函数编程(lambda表达式)">
<meta property="og:url" content="https://hubertwongcn.github.io/2023/12/26/2-Java-8-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hubert&#39;s Blog">
<meta property="og:description" content="我们关心的是如何写出好代码，而不是符合函数编程风格的代码。  简介 在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。   这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312262238553.png">
<meta property="article:published_time" content="2023-12-26T14:36:16.000Z">
<meta property="article:modified_time" content="2023-12-26T14:36:16.000Z">
<meta property="article:author" content="Hubert Wong">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="新特性">
<meta property="article:tag" content="Java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312262238553.png">
  
  
  
  <meta name="keywords" content="Java,新特性,Java8">

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">Hubert's Blog</div><div class="sub cap"> Hubert爱猫爱生活</div></a></div>

<nav class="menu dis-select"></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">2.Java 8 - 函数编程(lambda表达式)</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-text">惰性求值方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8A%E6%97%A9%E6%B1%82%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-text">及早求值方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stream-parallelStream"><span class="toc-text">stream &amp; parallelStream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stream-parallelStream-1"><span class="toc-text">stream &amp; parallelStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parallelStream%E5%8E%9F%E7%90%86"><span class="toc-text">parallelStream原理:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E4%B8%8EparallelStream%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%AF%B9%E6%AF%94"><span class="toc-text">stream与parallelStream性能测试对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B"><span class="toc-text">Stream中常用方法如下:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-text">常用例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%AE%80%E5%86%99"><span class="toc-text">匿名类简写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter-Predicate"><span class="toc-text">Filter &amp; Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map-Reduce"><span class="toc-text">Map&amp;Reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collectors"><span class="toc-text">Collectors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-text">flatMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#distinct"><span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#count"><span class="toc-text">count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Match"><span class="toc-text">Match</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-max-summaryStatistics"><span class="toc-text">min,max,summaryStatistics</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peek"><span class="toc-text">peek</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FunctionalInterface"><span class="toc-text">FunctionalInterface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%B3%A8%E8%A7%A3-FunctionInterface"><span class="toc-text">理解注解 @FunctionInterface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">自定义函数接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="toc-text">内置四大函数接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90"><span class="toc-text">一些例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div class="left"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Java/">Java</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Java/%E6%96%B0%E7%89%B9%E6%80%A7/">新特性</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/Java/%E6%96%B0%E7%89%B9%E6%80%A7/Java8/">Java8</a></div><div id="post-meta">
    <span>发布于&nbsp;<time datetime="2023-12-26T14:36:16.000Z">2023-12-26</time></span>
    
    <span>更新于&nbsp;<time datetime="2023-12-26T14:36:16.000Z">2023-12-26</time></span>
    </div></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>2.Java 8 - 函数编程(lambda表达式)</span></h1>
<blockquote>
<p>我们关心的是如何写出好代码，而不是符合函数编程风格的代码。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>在Java世界里面，面向对象还是主流思想，对于习惯了面向对象编程的开发者来说，抽象的概念并不陌生。面向对象编程是对数据进行抽象，而函数式编程是对行为进行抽象。现实世界中，数据和行为并存，程序也是如此，因此这两种编程方式我们都得学。</p>
</blockquote>
<blockquote>
<p>这种新的抽象方式还有其他好处。很多人不总是在编写性能优先的代码，对于这些人来说，函数式编程带来的好处尤为明显。程序员能编写出更容易阅读的代码——这种代码更多地表达了业务逻辑，而不是从机制上如何实现。易读的代码也易于维护、更可靠、更不容易出错。</p>
</blockquote>
<blockquote>
<p>在写回调函数和事件处理器时，程序员不必再纠缠于匿名内部类的冗繁和可读性，函数式编程让事件处理系统变得更加简单。能将函数方便地传递也让编写惰性代码变得容易，只有在真正需要的时候，才初始化变量的值。</p>
</blockquote>
<p>面向对象编程是对数据进行抽象；函数式编程是对行为进行抽象。</p>
<p>核心思想: 使用不可变值和函数，函数对一个值进行处理，映射成另一个值。</p>
<p>对核心类库的改进主要包括集合类的API和新引入的流Stream。流使程序员可以站在更高的抽象层次上对集合进行操作。</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><ul>
<li>lambda表达式仅能放入如下代码: 预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM(Single Abstract Method 单个抽象方法)类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</li>
<li>lambda表达式内可以使用<code>方法引用</code>，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(n -&gt; System.out.println(n)); </span><br><span class="line">list.forEach(System.out::println);  <span class="comment">// 使用方法引用</span></span><br></pre></td></tr></table></figure>

<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach((String s) -&gt; System.out.println(<span class="string">&quot;*&quot;</span> + s + <span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。</p>
<ul>
<li>lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</li>
<li>Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</li>
<li>Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.lang.Object lambda$<span class="number">0</span>(java.lang.String);</span><br></pre></td></tr></table></figure>

<ul>
<li>lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; primes = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">primes.forEach(element -&gt; &#123; factor++; &#125;);</span><br></pre></td></tr></table></figure>

<p>Compile time error : “local variables referenced from a lambda expression must be final or effectively final” 另外，只是访问它而不作修改是可以的，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; primes = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;);</span><br><span class="line"><span class="type">int</span> <span class="variable">factor</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="惰性求值方法"><a href="#惰性求值方法" class="headerlink" title="惰性求值方法"></a>惰性求值方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lists.stream().filter(f -&gt; f.getName().equals(<span class="string">&quot;p1&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>如上示例，这行代码并未做什么实际性的工作，filter只是<strong>描述</strong>了Stream，<strong>没有产生新的集合</strong>。</p>
<p>如果是多个条件组合，可以通过代码块{}</p>
<h3 id="及早求值方法"><a href="#及早求值方法" class="headerlink" title="及早求值方法"></a>及早求值方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; list2 = lists.stream().filter(f -&gt; f.getName().equals(<span class="string">&quot;p1&quot;</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>如上示例，collect最终会从Stream产生新值，拥有终止操作。</p>
<p>理想方式是形成一个惰性求值的链，最后用一个及早求值的操作返回想要的结果。与建造者模式相似，建造者模式先是使用一系列操作设置属性和配置，最后调用build方法，创建对象。</p>
<h2 id="stream-parallelStream"><a href="#stream-parallelStream" class="headerlink" title="stream &amp; parallelStream"></a>stream &amp; parallelStream</h2><h3 id="stream-parallelStream-1"><a href="#stream-parallelStream-1" class="headerlink" title="stream &amp; parallelStream"></a>stream &amp; parallelStream</h3><p>每个Stream都有两种模式: 顺序执行和并行执行。</p>
<p>顺序流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List &lt;Person&gt; people = list.getStream.collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>并行流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List &lt;Person&gt; people = list.getStream.parallel().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>顾名思义，当使用顺序方式去遍历时，每个item读完后再读下一个item。而使用并行去遍历时，数组会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。</p>
<h3 id="parallelStream原理"><a href="#parallelStream原理" class="headerlink" title="parallelStream原理:"></a>parallelStream原理:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">originalList</span> <span class="operator">=</span> someData;</span><br><span class="line">split1 = originalList(<span class="number">0</span>, mid);<span class="comment">//将数据分小部分</span></span><br><span class="line">split2 = originalList(mid,end);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Runnable</span>(split1.process());<span class="comment">//小部分执行操作</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Runnable</span>(split2.process());</span><br><span class="line"><span class="type">List</span> <span class="variable">revisedList</span> <span class="operator">=</span> split1 + split2;<span class="comment">//将结果合并</span></span><br></pre></td></tr></table></figure>

<p>大家对hadoop有稍微了解就知道，里面的 MapReduce 本身就是用于并行处理大数据集的软件框架，其 处理大数据的核心思想就是大而化小，分配到不同机器去运行map，最终通过reduce将所有机器的结果结合起来得到一个最终结果，与MapReduce不同，Stream则是利用多核技术可将大数据通过多核并行处理，而MapReduce则可以分布式的。</p>
<h3 id="stream与parallelStream性能测试对比"><a href="#stream与parallelStream性能测试对比" class="headerlink" title="stream与parallelStream性能测试对比"></a>stream与parallelStream性能测试对比</h3><p>如果是多核机器，理论上并行流则会比顺序流快上一倍，下面是测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个范围100万整数流,求能被2整除的数字，toArray()是终点方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[]=IntStream.range(<span class="number">0</span>, <span class="number">1_000_000</span>).filter(p -&gt; p % <span class="number">2</span>==<span class="number">0</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//和上面功能一样，这里是用并行流来计算</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b[]=IntStream.range(<span class="number">0</span>, <span class="number">1_000_000</span>).parallel().filter(p -&gt; p % <span class="number">2</span>==<span class="number">0</span>).toArray();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">//我本机的结果是serial: 0.06s, parallel 0.02s，证明并行流确实比顺序流快</span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">&quot;serial: %.2fs, parallel %.2fs%n&quot;</span>, (t1 - t0) * <span class="number">1e-9</span>, (t2 - t1) * <span class="number">1e-9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Stream中常用方法如下"><a href="#Stream中常用方法如下" class="headerlink" title="Stream中常用方法如下:"></a>Stream中常用方法如下:</h3><ul>
<li><code>stream()</code>, <code>parallelStream()</code></li>
<li><code>filter()</code></li>
<li><code>findAny()</code> <code>findFirst()</code></li>
<li><code>sort</code></li>
<li><code>forEach</code> void</li>
<li><code>map(), reduce()</code></li>
<li><code>flatMap()</code> - 将多个Stream连接成一个Stream</li>
<li><code>collect(Collectors.toList())</code></li>
<li><code>distinct</code>, <code>limit</code></li>
<li><code>count</code></li>
<li><code>min</code>, <code>max</code>, <code>summaryStatistics</code></li>
</ul>
<p>看下所有API:</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://cdn.jsdelivr.net/gh/HubertWongCN/image_host/img/202312262238553.png"/></div></div>

<h2 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h2><h3 id="匿名类简写"><a href="#匿名类简写" class="headerlink" title="匿名类简写"></a>匿名类简写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>( () -&gt; System.out.println(<span class="string">&quot;In Java8, Lambda expression rocks !!&quot;</span>) ).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line">(params) -&gt; expression</span><br><span class="line">(params) -&gt; statement</span><br><span class="line">(params) -&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="type">List</span> <span class="variable">features</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;Lambdas&quot;</span>, <span class="string">&quot;Default Method&quot;</span>, <span class="string">&quot;Stream API&quot;</span>, <span class="string">&quot;Date and Time API&quot;</span>);</span><br><span class="line">features.forEach(n -&gt; System.out.println(n));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，</span></span><br><span class="line">features.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p><em>构造引用</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supplier&lt;Student&gt; s = () -&gt; new Student();</span></span><br><span class="line">Supplier&lt;Student&gt; s = Student::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<p><em>对象::实例方法</em> Lambda表达式的(形参列表)与实例方法的(实参列表)类型，个数是对应</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// set.forEach(t -&gt; System.out.println(t));</span></span><br><span class="line">set.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><em>类名::静态方法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream&lt;Double&gt; stream = Stream.generate(() -&gt; Math.random());</span></span><br><span class="line">Stream&lt;Double&gt; stream = Stream.generate(Math::random);</span><br></pre></td></tr></table></figure>

<p><em>类名::实例方法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;((s1,s2) -&gt; s1.compareTo(s2));</span></span><br><span class="line"><span class="comment">/*  这里如果使用第一句话，编译器会有提示: Can be replaced with Comparator.naturalOrder，这句话告诉我们</span></span><br><span class="line"><span class="comment">  String已经重写了compareTo()方法，在这里写是多此一举，这里为什么这么写，是因为为了体现下面</span></span><br><span class="line"><span class="comment">  这句编译器的提示: Lambda can be replaced with method reference。好了，下面的这句就是改写成方法引用之后: </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(String::compareTo);</span><br></pre></td></tr></table></figure>

<h3 id="Filter-Predicate"><a href="#Filter-Predicate" class="headerlink" title="Filter &amp; Predicate"></a>Filter &amp; Predicate</h3><p>常规用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(args[])</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">languages</span> <span class="operator">=</span> Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Scala&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Haskell&quot;</span>, <span class="string">&quot;Lisp&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which starts with J :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.startsWith(<span class="string">&quot;J&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Languages which ends with a &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.endsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print all languages :&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print no language : &quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;<span class="literal">false</span>);</span><br><span class="line"> </span><br><span class="line">    System.out.println(<span class="string">&quot;Print language whose length greater than 4:&quot;</span>);</span><br><span class="line">    filter(languages, (str)-&gt;str.length() &gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">filter</span><span class="params">(List names, Predicate condition)</span> &#123;</span><br><span class="line">    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个Predicate组合filter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以用and()、or()和xor()逻辑函数来合并Predicate，</span></span><br><span class="line"><span class="comment">// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入</span></span><br><span class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(<span class="string">&quot;J&quot;</span>);</span><br><span class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == <span class="number">4</span>;</span><br><span class="line">names.stream()</span><br><span class="line">    .filter(startsWithJ.and(fourLetterLong))</span><br><span class="line">    .forEach((n) -&gt; System.out.print(<span class="string">&quot;nName, which starts with &#x27;J&#x27; and four letter long is : &quot;</span> + n));</span><br></pre></td></tr></table></figure>

<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map&amp;Reduce"></a>Map&amp;Reduce</h3><p>map将集合类(例如列表)元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">costBeforeTax</span> <span class="operator">=</span> Arrays.asList(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="number">500</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">bill</span> <span class="operator">=</span> costBeforeTax.stream().map((cost) -&gt; cost + <span class="number">.12</span>*cost).reduce((sum, cost) -&gt; sum + cost).get();</span><br><span class="line">System.out.println(<span class="string">&quot;Total : &quot;</span> + bill);</span><br></pre></td></tr></table></figure>

<h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串换成大写并用逗号链接起来</span></span><br><span class="line">List&lt;String&gt; G7 = Arrays.asList(<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;France&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;Italy&quot;</span>, <span class="string">&quot;U.K.&quot;</span>,<span class="string">&quot;Canada&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">G7Countries</span> <span class="operator">=</span> G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(G7Countries);</span><br></pre></td></tr></table></figure>

<ul>
<li>Collectors.joining(“, “)</li>
<li>Collectors.toList()</li>
<li>Collectors.toSet() ，生成set集合</li>
<li>Collectors.toMap(MemberModel::getUid, Function.identity())</li>
<li>Collectors.toMap(ImageModel::getAid, o -&gt; IMAGE_ADDRESS_PREFIX + o.getUrl())</li>
</ul>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>将多个Stream连接成一个Stream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; result= Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">3</span>),Arrays.asList(<span class="number">5</span>,<span class="number">6</span>)).flatMap(a-&gt;a.stream()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>结果: [1, 3, 5, 6]</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LikeDO&gt; likeDOs=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LikeDO&gt;();</span><br><span class="line">List&lt;Long&gt; likeTidList = likeDOs.stream().map(LikeDO::getTid)</span><br><span class="line">                .distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>计总数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> countOfAdult=persons.stream()</span><br><span class="line">                       .filter(p -&gt; p.getAge() &gt; <span class="number">18</span>)</span><br><span class="line">                       .map(person -&gt; <span class="keyword">new</span> <span class="title class_">Adult</span>(person))</span><br><span class="line">                       .count();</span><br></pre></td></tr></table></figure>

<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">anyStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">allStartsWithA</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">&quot;a&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">noneStartsWithZ</span> <span class="operator">=</span></span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">&quot;z&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="min-max-summaryStatistics"><a href="#min-max-summaryStatistics" class="headerlink" title="min,max,summaryStatistics"></a>min,max,summaryStatistics</h3><p>最小值，最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1L</span>, <span class="string">&quot;p1&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">2L</span>, <span class="string">&quot;p2&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3L</span>, <span class="string">&quot;p3&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">4L</span>, <span class="string">&quot;p4&quot;</span>));</span><br><span class="line"><span class="type">Person</span> <span class="variable">a</span> <span class="operator">=</span> lists.stream().max(Comparator.comparing(t -&gt; t.getId())).get();</span><br><span class="line">System.out.println(a.getId());</span><br></pre></td></tr></table></figure>

<p>如果比较器涉及多个条件，比较复杂，可以定制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">a</span> <span class="operator">=</span> lists.stream().min(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (o1.getId() &gt; o2.getId()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (o1.getId() &lt; o2.getId()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>

<p>summaryStatistics</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取数字的个数、最小值、最大值、总和以及平均值</span></span><br><span class="line">List&lt;Integer&gt; primes = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>);</span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> primes.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">&quot;Highest prime number in List : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;Lowest prime number in List : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;Sum of all prime numbers : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;Average of all prime numbers : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>

<h3 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h3><p>可以使用peek方法，peek方法可只包含一个空的方法体，只要能设置断点即可，但有些IDE不允许空，可以如下文示例，简单写一个打印逻辑。</p>
<p>注意，调试完后要删掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; lists = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1L</span>, <span class="string">&quot;p1&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">2L</span>, <span class="string">&quot;p2&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3L</span>, <span class="string">&quot;p3&quot;</span>));</span><br><span class="line">lists.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">4L</span>, <span class="string">&quot;p4&quot;</span>));</span><br><span class="line">System.out.println(lists);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; list2 = lists.stream()</span><br><span class="line">				 .filter(f -&gt; f.getName().startsWith(<span class="string">&quot;p&quot;</span>))</span><br><span class="line">                .peek(t -&gt; &#123;</span><br><span class="line">                    System.out.println(t.getName());</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<h2 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="FunctionalInterface"></a>FunctionalInterface</h2><h3 id="理解注解-FunctionInterface"><a href="#理解注解-FunctionInterface" class="headerlink" title="理解注解 @FunctionInterface"></a>理解注解 @FunctionInterface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface&#x27;s abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>interface做注解的注解类型，被定义成java语言规范</li>
<li>一个被它注解的接口只能有一个抽象方法，有两种例外</li>
<li>第一是接口允许有实现的方法，这种实现的方法是用default关键字来标记的(java反射中java.lang.reflect.Method#isDefault()方法用来判断是否是default方法)</li>
<li>第二如果声明的方法和java.lang.Object中的某个方法一样，它可以不当做未实现的方法，不违背这个原则: 一个被它注解的接口只能有一个抽象方法, 比如: <code>java public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj); &#125; </code></li>
<li>如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件:<ul>
<li>这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class</li>
<li>这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。</li>
</ul>
</li>
<li>编译器会自动把满足function interface要求的接口自动识别为function interface，所以你才不需要对上面示例中的 ITest接口增加@FunctionInterface注解。</li>
</ul>
<h3 id="自定义函数接口"><a href="#自定义函数接口" class="headerlink" title="自定义函数接口"></a>自定义函数接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.isea.java;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestIMyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IMyInterface</span> <span class="variable">iMyInterface</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;I like study&quot;</span>);</span><br><span class="line">        iMyInterface.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置四大函数接口"><a href="#内置四大函数接口" class="headerlink" title="内置四大函数接口"></a>内置四大函数接口</h3><ul>
<li>消费型接口: Consumer&lt; T&gt; void accept(T t)有参数，无返回值的抽象方法；</li>
</ul>
<blockquote>
<p>比如: map.forEach(BiConsumer&lt;A, T&gt;)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">&quot;Hello, &quot;</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Luke&quot;</span>, <span class="string">&quot;Skywalker&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>供给型接口: Supplier &lt; T&gt; T get() 无参有返回值的抽象方法；</li>
</ul>
<blockquote>
<p>以stream().collect(Collector&lt;? super T, A, R&gt; collector)为例:</p>
</blockquote>
<p>比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<p>再如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Collectors.toSet</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">	Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_UNORDERED_ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CollectorImpl</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;A&gt; supplier;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiConsumer&lt;A, T&gt; accumulator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BinaryOperator&lt;A&gt; combiner;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Function&lt;A, R&gt; finisher;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Characteristics&gt; characteristics;</span><br><span class="line"></span><br><span class="line">CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">              BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">              BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">              Function&lt;A,R&gt; finisher,</span><br><span class="line">              Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">    <span class="built_in">this</span>.supplier = supplier;</span><br><span class="line">    <span class="built_in">this</span>.accumulator = accumulator;</span><br><span class="line">    <span class="built_in">this</span>.combiner = combiner;</span><br><span class="line">    <span class="built_in">this</span>.finisher = finisher;</span><br><span class="line">    <span class="built_in">this</span>.characteristics = characteristics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CollectorImpl(Supplier&lt;A&gt; supplier,</span><br><span class="line">              BiConsumer&lt;A, T&gt; accumulator,</span><br><span class="line">              BinaryOperator&lt;A&gt; combiner,</span><br><span class="line">              Set&lt;Characteristics&gt; characteristics) &#123;</span><br><span class="line">    <span class="built_in">this</span>(supplier, accumulator, combiner, castingIdentity(), characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// collect()方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> P_OUT, A, R&gt; collector)</span> &#123;</span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;</span><br><span class="line">        container = collector.supplier().get();</span><br><span class="line">        BiConsumer&lt;A, ? <span class="built_in">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)</span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>断定型接口: Predicate<T> boolean test(T t):有参，但是返回值类型是固定的boolean</li>
</ul>
<blockquote>
<p>比如: steam().filter()中参数就是Predicate</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);              <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>

<ul>
<li>函数型接口: Function&lt;T,R&gt; R apply(T t)有参有返回值的抽象方法；</li>
</ul>
<blockquote>
<p>比如: steam().map() 中参数就是Function&lt;? super T, ? extends R&gt;；reduce()中参数BinaryOperator<T> (ps: BinaryOperator<T> extends BiFunction&lt;T,T,T&gt;)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">&quot;123&quot;</span>);     <span class="comment">// &quot;123&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><ul>
<li>输出 年龄&gt;25的女程序员中名字排名前3位的姓名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javaProgrammers.stream()</span><br><span class="line">          .filter((p) -&gt; (p.getAge() &gt; <span class="number">25</span>))</span><br><span class="line">          .filter((p) -&gt; (<span class="string">&quot;female&quot;</span>.equals(p.getGender())))</span><br><span class="line">          .sorted((p, p2) -&gt; (p.getFirstName().compareTo(p2.getFirstName())))</span><br><span class="line">          .limit(<span class="number">3</span>)</span><br><span class="line">          <span class="comment">//.forEach(e -&gt; e.setSalary(e.getSalary() / 100 * 5 + e.getSalary()))//涨工资</span></span><br><span class="line">          .forEach((p) -&gt; System.out.printf(<span class="string">&quot;%s %s; &quot;</span>, p.getFirstName(), p.getLastName()));</span><br></pre></td></tr></table></figure>

<ul>
<li>工资最高的 Java programmer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> javaProgrammers</span><br><span class="line">          .stream()</span><br><span class="line">          .max((p, p2) -&gt; (p.getSalary() - p2.getSalary()))</span><br><span class="line">          .get()</span><br></pre></td></tr></table></figure>

<ul>
<li>将 Java programmers 的 first name 存放到 TreeSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;String&gt; javaDevLastName = javaProgrammers</span><br><span class="line">          .stream()</span><br><span class="line">          .map(Person::getLastName)</span><br><span class="line">          .collect(toCollection(TreeSet::<span class="keyword">new</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>计算付给 Java programmers 的所有money</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalSalary</span> <span class="operator">=</span> javaProgrammers</span><br><span class="line">          .parallelStream()</span><br><span class="line">          .mapToInt(p -&gt; p.getSalary())</span><br><span class="line">          .sum();</span><br></pre></td></tr></table></figure>

<ul>
<li>Comparator多属性排序: 先按名字不分大小写排，再按GID倒序排，最后按年龄正序排</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;Person&gt; personList = getTestList();</span><br><span class="line">	personList.sort(Comparator.comparing(Person::getName, String.CASE_INSENSITIVE_ORDER)</span><br><span class="line">			.thenComparing(Person::getGid, (a, b) -&gt; b.compareTo(a))</span><br><span class="line">			.thenComparingInt(Person::getAge));</span><br><span class="line">	personList.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Person&gt; <span class="title function_">getTestList</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Lists.newArrayList(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;301&quot;</span>, <span class="number">10</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;303&quot;</span>, <span class="number">10</span>),</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;303&quot;</span>, <span class="number">8</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;303&quot;</span>, <span class="number">6</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;303&quot;</span>, <span class="number">11</span>),</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;dai&quot;</span>, <span class="string">&quot;302&quot;</span>, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;302&quot;</span>, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhang&quot;</span>, <span class="string">&quot;301&quot;</span>, <span class="number">9</span>),</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Li&quot;</span>, <span class="string">&quot;301&quot;</span>, <span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=303, age=6]</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=303, age=8]</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=303, age=10]</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=303, age=11]</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=302, age=9]</span></span><br><span class="line"><span class="comment">// Person [name=dai, gid=301, age=10]</span></span><br><span class="line"><span class="comment">// Person [name=Li, gid=301, age=8]</span></span><br><span class="line"><span class="comment">// Person [name=zhang, gid=302, age=9]</span></span><br><span class="line"><span class="comment">// Person [name=zhang, gid=301, age=9]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>处理字符串</li>
</ul>
<p>两个新的方法可在字符串类上使用: join和chars。第一个方法使用指定的分隔符，将任何数量的字符串连接为一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.join(<span class="string">&quot;:&quot;</span>, <span class="string">&quot;foobar&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="comment">// =&gt; foobar:foo:bar</span></span><br></pre></td></tr></table></figure>

<p>第二个方法chars从字符串所有字符创建数据流，所以你可以在这些字符上使用流式操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;foobar:foo:bar&quot;</span></span><br><span class="line">    .chars()</span><br><span class="line">    .distinct()</span><br><span class="line">    .mapToObj(c -&gt; String.valueOf((<span class="type">char</span>)c))</span><br><span class="line">    .sorted()</span><br><span class="line">    .collect(Collectors.joining());</span><br><span class="line"><span class="comment">// =&gt; :abfor</span></span><br></pre></td></tr></table></figure>

<p>不仅仅是字符串，正则表达式模式串也能受益于数据流。我们可以分割任何模式串，并创建数据流来处理它们，而不是将字符串分割为单个字符的数据流，像下面这样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pattern.compile(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    .splitAsStream(<span class="string">&quot;foobar:foo:bar&quot;</span>)</span><br><span class="line">    .filter(s -&gt; s.contains(<span class="string">&quot;bar&quot;</span>))</span><br><span class="line">    .sorted()</span><br><span class="line">    .collect(Collectors.joining(<span class="string">&quot;:&quot;</span>));</span><br><span class="line"><span class="comment">// =&gt; bar:foobar</span></span><br></pre></td></tr></table></figure>

<p>此外，正则模式串可以转换为谓词。这些谓词可以像下面那样用于过滤字符串流:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;.*@gmail\\.com&quot;</span>);</span><br><span class="line">Stream.of(<span class="string">&quot;bob@gmail.com&quot;</span>, <span class="string">&quot;alice@hotmail.com&quot;</span>)</span><br><span class="line">    .filter(pattern.asPredicate())</span><br><span class="line">    .count();</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>上面的模式串接受任何以@gmail.com结尾的字符串，并且之后用作Java8的Predicate来过滤电子邮件地址流。</p>
<ul>
<li>Local Cache实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalCache</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Long&gt; cache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> cache.computeIfAbsent(i, (key) -&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Slow calculation of &quot;</span> + key);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> fibonacci(i - <span class="number">2</span>) + fibonacci(i - <span class="number">1</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// warm up</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">	        System.out.println(</span><br><span class="line">	            <span class="string">&quot;f(&quot;</span> + i + <span class="string">&quot;) = &quot;</span> + fibonacci(i));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// read -&gt; cal</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(fibonacci(<span class="number">100</span>));</span><br><span class="line">		System.out.println(System.currentTimeMillis()-current);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>集合–》取元素的一个属性–》去重—》组装成List–》返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;LikeDO&gt; likeDOs=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;LikeDO&gt;();</span><br><span class="line">List&lt;Long&gt; likeTidList = likeDOs.stream().map(LikeDO::getTid)</span><br><span class="line">                .distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>集合–》按表达式过滤–》遍历、每个元系处理–》放入预先定义的集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> Map&lt;String, StkProduct&gt; newStockName2Product = Maps.newConcurrentMap();</span><br><span class="line">       stockProducts.stream().filter(stkProduct -&gt; stkProduct.enabled).forEach(stkProduct -&gt; &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> BCConvert.bj2qj(StringUtils.replace(stkProduct.name, <span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">           newStockName2Product.put(newName, stkProduct);</span><br><span class="line">       &#125;);</span><br><span class="line">Set&lt;String&gt; qjStockNames;</span><br><span class="line">qjStockNames.stream().filter(name -&gt; !acAutomaton.getKey2link().containsKey(name)).forEach(name -&gt; &#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">           <span class="type">StkProduct</span> <span class="variable">stkProduct</span> <span class="operator">=</span> stockNameQj2Product.get(name);</span><br><span class="line">           <span class="keyword">if</span> (stkProduct != <span class="literal">null</span>) &#123;</span><br><span class="line">               value = stkProduct.name;</span><br><span class="line">           &#125;</span><br><span class="line">           acAutomaton.getKey2link().put(name, value);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>集合–》map</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ImageModel&gt; imageModelList = <span class="literal">null</span>;</span><br><span class="line">Map&lt;Long, String&gt; imagesMap = <span class="literal">null</span>;</span><br><span class="line">imagesMap = imageModelList.stream().collect(Collectors.toMap(ImageModel::getAid, o -&gt; IMAGE_ADDRESS_PREFIX + o.getUrl()));</span><br><span class="line">              </span><br><span class="line">             </span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; kvMap = postDetailCacheList.stream().collect(Collectors.toMap((detailCache) -&gt;</span><br><span class="line">                getBbsSimplePostKey(detailCache.getTid()), JSON::toJSONString));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Map&lt;Long, Long&gt; pidToTid；</span><br><span class="line">List&lt;String&gt; pidKeyList = pidToTid.entrySet().stream().map((o) -&gt; getKeyBbsReplyPid(o.getValue(), o.getKey())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>DO模型—》Model模型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;AdDO&gt; adDOList;</span><br><span class="line">adDOList.stream().map(adDo -&gt; convertAdModel(adDo))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>phones 是一个List<String>，将相同的元素分组、归类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; phones=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        phones.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        phones.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        phones.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        phones.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        phones.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        phones.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; phoneClassify = phones.stream().collect(Collectors.groupingBy(item -&gt; item));</span><br><span class="line">        System.out.println(phoneClassify);</span><br><span class="line">返回结果: </span><br><span class="line">&#123;a=[a, a, a], b=[b, b], c=[c]&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Xhr9aNEMr0fIUWh27mH1pw">Lambda 表达式的 10 个示例在新窗口打开</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/biezhi/learn-java8">learn-java8在新窗口打开</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aalansehaiyang/java8-tutorial">java8-tutorial在新窗口打开</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/9mgD2aV6gML57RAPIEbZeQ">一文让你明白lambda用法与源码分析在新窗口打开</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/renfufei/article/details/24600507">http://blog.csdn.net/renfufei/article/details/24600507在新窗口打开</a></li>
<li><a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html在新窗口打开</a></li>
<li>Java8 Lambda表达式教程 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ioriogami/article/details/12782141">https://blog.csdn.net/ioriogami/article/details/12782141</a></li>
<li>Java8 6个问题 <a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20%E7%9A%846%E4%B8%AA%E9%97%AE%E9%A2%98.html">https://wizardforcel.gitbooks.io/java8-tutorials/content/Java%208%20%E7%9A%846%E4%B8%AA%E9%97%AE%E9%A2%98.html</a></li>
</ul>



<div class="article-footer reveal fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/12/26/3-Java-8-Optional%E7%B1%BB%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/">3.Java 8 - Optional类深度解析</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/12/26/1-Java8%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/">1.Java8特性知识体系详解</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"></div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.21.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.21.0';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img, .gallery img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
